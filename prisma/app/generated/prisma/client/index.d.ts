
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model autre
 * 
 */
export type autre = $Result.DefaultSelection<Prisma.$autrePayload>
/**
 * Model autre_tags
 * 
 */
export type autre_tags = $Result.DefaultSelection<Prisma.$autre_tagsPayload>
/**
 * Model autre_tags_link
 * 
 */
export type autre_tags_link = $Result.DefaultSelection<Prisma.$autre_tags_linkPayload>
/**
 * Model experiences
 * 
 */
export type experiences = $Result.DefaultSelection<Prisma.$experiencesPayload>
/**
 * Model faq
 * 
 */
export type faq = $Result.DefaultSelection<Prisma.$faqPayload>
/**
 * Model photos
 * 
 */
export type photos = $Result.DefaultSelection<Prisma.$photosPayload>
/**
 * Model photos_albums
 * 
 */
export type photos_albums = $Result.DefaultSelection<Prisma.$photos_albumsPayload>
/**
 * Model photos_albums_link
 * 
 */
export type photos_albums_link = $Result.DefaultSelection<Prisma.$photos_albums_linkPayload>
/**
 * Model photos_experiences
 * 
 */
export type photos_experiences = $Result.DefaultSelection<Prisma.$photos_experiencesPayload>
/**
 * Model photos_tags
 * 
 */
export type photos_tags = $Result.DefaultSelection<Prisma.$photos_tagsPayload>
/**
 * Model photos_tags_link
 * 
 */
export type photos_tags_link = $Result.DefaultSelection<Prisma.$photos_tags_linkPayload>
/**
 * Model temoignages
 * 
 */
export type temoignages = $Result.DefaultSelection<Prisma.$temoignagesPayload>
/**
 * Model utilisateurs
 * 
 */
export type utilisateurs = $Result.DefaultSelection<Prisma.$utilisateursPayload>
/**
 * Model videos
 * 
 */
export type videos = $Result.DefaultSelection<Prisma.$videosPayload>
/**
 * Model videos_tags
 * 
 */
export type videos_tags = $Result.DefaultSelection<Prisma.$videos_tagsPayload>
/**
 * Model videos_tags_link
 * 
 */
export type videos_tags_link = $Result.DefaultSelection<Prisma.$videos_tags_linkPayload>
/**
 * Model photos_tags_recherche
 * 
 */
export type photos_tags_recherche = $Result.DefaultSelection<Prisma.$photos_tags_recherchePayload>
/**
 * Model photos_tags_recherche_link
 * 
 */
export type photos_tags_recherche_link = $Result.DefaultSelection<Prisma.$photos_tags_recherche_linkPayload>
/**
 * Model photos_albums_tags_link
 * 
 */
export type photos_albums_tags_link = $Result.DefaultSelection<Prisma.$photos_albums_tags_linkPayload>
/**
 * Model account
 * 
 */
export type account = $Result.DefaultSelection<Prisma.$accountPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model verification
 * 
 */
export type verification = $Result.DefaultSelection<Prisma.$verificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Autres
 * const autres = await prisma.autre.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Autres
   * const autres = await prisma.autre.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.autre`: Exposes CRUD operations for the **autre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autres
    * const autres = await prisma.autre.findMany()
    * ```
    */
  get autre(): Prisma.autreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autre_tags`: Exposes CRUD operations for the **autre_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autre_tags
    * const autre_tags = await prisma.autre_tags.findMany()
    * ```
    */
  get autre_tags(): Prisma.autre_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autre_tags_link`: Exposes CRUD operations for the **autre_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autre_tags_links
    * const autre_tags_links = await prisma.autre_tags_link.findMany()
    * ```
    */
  get autre_tags_link(): Prisma.autre_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experiences`: Exposes CRUD operations for the **experiences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiences
    * const experiences = await prisma.experiences.findMany()
    * ```
    */
  get experiences(): Prisma.experiencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.faqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos`: Exposes CRUD operations for the **photos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photos.findMany()
    * ```
    */
  get photos(): Prisma.photosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_albums`: Exposes CRUD operations for the **photos_albums** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_albums
    * const photos_albums = await prisma.photos_albums.findMany()
    * ```
    */
  get photos_albums(): Prisma.photos_albumsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_albums_link`: Exposes CRUD operations for the **photos_albums_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_albums_links
    * const photos_albums_links = await prisma.photos_albums_link.findMany()
    * ```
    */
  get photos_albums_link(): Prisma.photos_albums_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_experiences`: Exposes CRUD operations for the **photos_experiences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_experiences
    * const photos_experiences = await prisma.photos_experiences.findMany()
    * ```
    */
  get photos_experiences(): Prisma.photos_experiencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags`: Exposes CRUD operations for the **photos_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags
    * const photos_tags = await prisma.photos_tags.findMany()
    * ```
    */
  get photos_tags(): Prisma.photos_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags_link`: Exposes CRUD operations for the **photos_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags_links
    * const photos_tags_links = await prisma.photos_tags_link.findMany()
    * ```
    */
  get photos_tags_link(): Prisma.photos_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.temoignages`: Exposes CRUD operations for the **temoignages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temoignages
    * const temoignages = await prisma.temoignages.findMany()
    * ```
    */
  get temoignages(): Prisma.temoignagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utilisateurs`: Exposes CRUD operations for the **utilisateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateurs.findMany()
    * ```
    */
  get utilisateurs(): Prisma.utilisateursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos`: Exposes CRUD operations for the **videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.videos.findMany()
    * ```
    */
  get videos(): Prisma.videosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos_tags`: Exposes CRUD operations for the **videos_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos_tags
    * const videos_tags = await prisma.videos_tags.findMany()
    * ```
    */
  get videos_tags(): Prisma.videos_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos_tags_link`: Exposes CRUD operations for the **videos_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos_tags_links
    * const videos_tags_links = await prisma.videos_tags_link.findMany()
    * ```
    */
  get videos_tags_link(): Prisma.videos_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags_recherche`: Exposes CRUD operations for the **photos_tags_recherche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags_recherches
    * const photos_tags_recherches = await prisma.photos_tags_recherche.findMany()
    * ```
    */
  get photos_tags_recherche(): Prisma.photos_tags_rechercheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags_recherche_link`: Exposes CRUD operations for the **photos_tags_recherche_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags_recherche_links
    * const photos_tags_recherche_links = await prisma.photos_tags_recherche_link.findMany()
    * ```
    */
  get photos_tags_recherche_link(): Prisma.photos_tags_recherche_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_albums_tags_link`: Exposes CRUD operations for the **photos_albums_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_albums_tags_links
    * const photos_albums_tags_links = await prisma.photos_albums_tags_link.findMany()
    * ```
    */
  get photos_albums_tags_link(): Prisma.photos_albums_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.accountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.verificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.1
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    autre: 'autre',
    autre_tags: 'autre_tags',
    autre_tags_link: 'autre_tags_link',
    experiences: 'experiences',
    faq: 'faq',
    photos: 'photos',
    photos_albums: 'photos_albums',
    photos_albums_link: 'photos_albums_link',
    photos_experiences: 'photos_experiences',
    photos_tags: 'photos_tags',
    photos_tags_link: 'photos_tags_link',
    temoignages: 'temoignages',
    utilisateurs: 'utilisateurs',
    videos: 'videos',
    videos_tags: 'videos_tags',
    videos_tags_link: 'videos_tags_link',
    photos_tags_recherche: 'photos_tags_recherche',
    photos_tags_recherche_link: 'photos_tags_recherche_link',
    photos_albums_tags_link: 'photos_albums_tags_link',
    account: 'account',
    session: 'session',
    user: 'user',
    verification: 'verification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "autre" | "autre_tags" | "autre_tags_link" | "experiences" | "faq" | "photos" | "photos_albums" | "photos_albums_link" | "photos_experiences" | "photos_tags" | "photos_tags_link" | "temoignages" | "utilisateurs" | "videos" | "videos_tags" | "videos_tags_link" | "photos_tags_recherche" | "photos_tags_recherche_link" | "photos_albums_tags_link" | "account" | "session" | "user" | "verification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      autre: {
        payload: Prisma.$autrePayload<ExtArgs>
        fields: Prisma.autreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.autreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.autreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>
          }
          findFirst: {
            args: Prisma.autreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.autreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>
          }
          findMany: {
            args: Prisma.autreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>[]
          }
          create: {
            args: Prisma.autreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>
          }
          createMany: {
            args: Prisma.autreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.autreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>
          }
          update: {
            args: Prisma.autreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>
          }
          deleteMany: {
            args: Prisma.autreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.autreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.autreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autrePayload>
          }
          aggregate: {
            args: Prisma.AutreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutre>
          }
          groupBy: {
            args: Prisma.autreGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutreGroupByOutputType>[]
          }
          count: {
            args: Prisma.autreCountArgs<ExtArgs>
            result: $Utils.Optional<AutreCountAggregateOutputType> | number
          }
        }
      }
      autre_tags: {
        payload: Prisma.$autre_tagsPayload<ExtArgs>
        fields: Prisma.autre_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.autre_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.autre_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>
          }
          findFirst: {
            args: Prisma.autre_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.autre_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>
          }
          findMany: {
            args: Prisma.autre_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>[]
          }
          create: {
            args: Prisma.autre_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>
          }
          createMany: {
            args: Prisma.autre_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.autre_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>
          }
          update: {
            args: Prisma.autre_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>
          }
          deleteMany: {
            args: Prisma.autre_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.autre_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.autre_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tagsPayload>
          }
          aggregate: {
            args: Prisma.Autre_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutre_tags>
          }
          groupBy: {
            args: Prisma.autre_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Autre_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.autre_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Autre_tagsCountAggregateOutputType> | number
          }
        }
      }
      autre_tags_link: {
        payload: Prisma.$autre_tags_linkPayload<ExtArgs>
        fields: Prisma.autre_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.autre_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.autre_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.autre_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.autre_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>
          }
          findMany: {
            args: Prisma.autre_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>[]
          }
          create: {
            args: Prisma.autre_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>
          }
          createMany: {
            args: Prisma.autre_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.autre_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>
          }
          update: {
            args: Prisma.autre_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.autre_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.autre_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.autre_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$autre_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Autre_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutre_tags_link>
          }
          groupBy: {
            args: Prisma.autre_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Autre_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.autre_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Autre_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      experiences: {
        payload: Prisma.$experiencesPayload<ExtArgs>
        fields: Prisma.experiencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.experiencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.experiencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          findFirst: {
            args: Prisma.experiencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.experiencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          findMany: {
            args: Prisma.experiencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>[]
          }
          create: {
            args: Prisma.experiencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          createMany: {
            args: Prisma.experiencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.experiencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          update: {
            args: Prisma.experiencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          deleteMany: {
            args: Prisma.experiencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.experiencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.experiencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          aggregate: {
            args: Prisma.ExperiencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperiences>
          }
          groupBy: {
            args: Prisma.experiencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperiencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.experiencesCountArgs<ExtArgs>
            result: $Utils.Optional<ExperiencesCountAggregateOutputType> | number
          }
        }
      }
      faq: {
        payload: Prisma.$faqPayload<ExtArgs>
        fields: Prisma.faqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.faqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.faqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          findFirst: {
            args: Prisma.faqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.faqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          findMany: {
            args: Prisma.faqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>[]
          }
          create: {
            args: Prisma.faqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          createMany: {
            args: Prisma.faqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.faqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          update: {
            args: Prisma.faqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          deleteMany: {
            args: Prisma.faqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.faqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.faqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          aggregate: {
            args: Prisma.FaqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaq>
          }
          groupBy: {
            args: Prisma.faqGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqGroupByOutputType>[]
          }
          count: {
            args: Prisma.faqCountArgs<ExtArgs>
            result: $Utils.Optional<FaqCountAggregateOutputType> | number
          }
        }
      }
      photos: {
        payload: Prisma.$photosPayload<ExtArgs>
        fields: Prisma.photosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          findFirst: {
            args: Prisma.photosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          findMany: {
            args: Prisma.photosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>[]
          }
          create: {
            args: Prisma.photosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          createMany: {
            args: Prisma.photosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          update: {
            args: Prisma.photosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          deleteMany: {
            args: Prisma.photosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          aggregate: {
            args: Prisma.PhotosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos>
          }
          groupBy: {
            args: Prisma.photosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.photosCountArgs<ExtArgs>
            result: $Utils.Optional<PhotosCountAggregateOutputType> | number
          }
        }
      }
      photos_albums: {
        payload: Prisma.$photos_albumsPayload<ExtArgs>
        fields: Prisma.photos_albumsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_albumsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_albumsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          findFirst: {
            args: Prisma.photos_albumsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_albumsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          findMany: {
            args: Prisma.photos_albumsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>[]
          }
          create: {
            args: Prisma.photos_albumsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          createMany: {
            args: Prisma.photos_albumsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_albumsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          update: {
            args: Prisma.photos_albumsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          deleteMany: {
            args: Prisma.photos_albumsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_albumsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_albumsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          aggregate: {
            args: Prisma.Photos_albumsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_albums>
          }
          groupBy: {
            args: Prisma.photos_albumsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_albumsGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_albumsCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_albumsCountAggregateOutputType> | number
          }
        }
      }
      photos_albums_link: {
        payload: Prisma.$photos_albums_linkPayload<ExtArgs>
        fields: Prisma.photos_albums_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_albums_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_albums_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_albums_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_albums_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          findMany: {
            args: Prisma.photos_albums_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>[]
          }
          create: {
            args: Prisma.photos_albums_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          createMany: {
            args: Prisma.photos_albums_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_albums_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          update: {
            args: Prisma.photos_albums_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_albums_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_albums_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_albums_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_albums_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_albums_link>
          }
          groupBy: {
            args: Prisma.photos_albums_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_albums_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_linkCountAggregateOutputType> | number
          }
        }
      }
      photos_experiences: {
        payload: Prisma.$photos_experiencesPayload<ExtArgs>
        fields: Prisma.photos_experiencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_experiencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_experiencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>
          }
          findFirst: {
            args: Prisma.photos_experiencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_experiencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>
          }
          findMany: {
            args: Prisma.photos_experiencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>[]
          }
          create: {
            args: Prisma.photos_experiencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>
          }
          createMany: {
            args: Prisma.photos_experiencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_experiencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>
          }
          update: {
            args: Prisma.photos_experiencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>
          }
          deleteMany: {
            args: Prisma.photos_experiencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_experiencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_experiencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_experiencesPayload>
          }
          aggregate: {
            args: Prisma.Photos_experiencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_experiences>
          }
          groupBy: {
            args: Prisma.photos_experiencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_experiencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_experiencesCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_experiencesCountAggregateOutputType> | number
          }
        }
      }
      photos_tags: {
        payload: Prisma.$photos_tagsPayload<ExtArgs>
        fields: Prisma.photos_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          findFirst: {
            args: Prisma.photos_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          findMany: {
            args: Prisma.photos_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>[]
          }
          create: {
            args: Prisma.photos_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          createMany: {
            args: Prisma.photos_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          update: {
            args: Prisma.photos_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          deleteMany: {
            args: Prisma.photos_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          aggregate: {
            args: Prisma.Photos_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags>
          }
          groupBy: {
            args: Prisma.photos_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tagsCountAggregateOutputType> | number
          }
        }
      }
      photos_tags_link: {
        payload: Prisma.$photos_tags_linkPayload<ExtArgs>
        fields: Prisma.photos_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          findMany: {
            args: Prisma.photos_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>[]
          }
          create: {
            args: Prisma.photos_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          createMany: {
            args: Prisma.photos_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          update: {
            args: Prisma.photos_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags_link>
          }
          groupBy: {
            args: Prisma.photos_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      temoignages: {
        payload: Prisma.$temoignagesPayload<ExtArgs>
        fields: Prisma.temoignagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.temoignagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.temoignagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>
          }
          findFirst: {
            args: Prisma.temoignagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.temoignagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>
          }
          findMany: {
            args: Prisma.temoignagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>[]
          }
          create: {
            args: Prisma.temoignagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>
          }
          createMany: {
            args: Prisma.temoignagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.temoignagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>
          }
          update: {
            args: Prisma.temoignagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>
          }
          deleteMany: {
            args: Prisma.temoignagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.temoignagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.temoignagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temoignagesPayload>
          }
          aggregate: {
            args: Prisma.TemoignagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemoignages>
          }
          groupBy: {
            args: Prisma.temoignagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemoignagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.temoignagesCountArgs<ExtArgs>
            result: $Utils.Optional<TemoignagesCountAggregateOutputType> | number
          }
        }
      }
      utilisateurs: {
        payload: Prisma.$utilisateursPayload<ExtArgs>
        fields: Prisma.utilisateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.utilisateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.utilisateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          findFirst: {
            args: Prisma.utilisateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.utilisateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          findMany: {
            args: Prisma.utilisateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>[]
          }
          create: {
            args: Prisma.utilisateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          createMany: {
            args: Prisma.utilisateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.utilisateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          update: {
            args: Prisma.utilisateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          deleteMany: {
            args: Prisma.utilisateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.utilisateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.utilisateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          aggregate: {
            args: Prisma.UtilisateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilisateurs>
          }
          groupBy: {
            args: Prisma.utilisateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilisateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.utilisateursCountArgs<ExtArgs>
            result: $Utils.Optional<UtilisateursCountAggregateOutputType> | number
          }
        }
      }
      videos: {
        payload: Prisma.$videosPayload<ExtArgs>
        fields: Prisma.videosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findFirst: {
            args: Prisma.videosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findMany: {
            args: Prisma.videosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>[]
          }
          create: {
            args: Prisma.videosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          createMany: {
            args: Prisma.videosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          update: {
            args: Prisma.videosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          deleteMany: {
            args: Prisma.videosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          aggregate: {
            args: Prisma.VideosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos>
          }
          groupBy: {
            args: Prisma.videosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideosGroupByOutputType>[]
          }
          count: {
            args: Prisma.videosCountArgs<ExtArgs>
            result: $Utils.Optional<VideosCountAggregateOutputType> | number
          }
        }
      }
      videos_tags: {
        payload: Prisma.$videos_tagsPayload<ExtArgs>
        fields: Prisma.videos_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videos_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videos_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          findFirst: {
            args: Prisma.videos_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videos_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          findMany: {
            args: Prisma.videos_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>[]
          }
          create: {
            args: Prisma.videos_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          createMany: {
            args: Prisma.videos_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videos_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          update: {
            args: Prisma.videos_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          deleteMany: {
            args: Prisma.videos_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videos_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videos_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          aggregate: {
            args: Prisma.Videos_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos_tags>
          }
          groupBy: {
            args: Prisma.videos_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Videos_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.videos_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Videos_tagsCountAggregateOutputType> | number
          }
        }
      }
      videos_tags_link: {
        payload: Prisma.$videos_tags_linkPayload<ExtArgs>
        fields: Prisma.videos_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videos_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videos_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.videos_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videos_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          findMany: {
            args: Prisma.videos_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>[]
          }
          create: {
            args: Prisma.videos_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          createMany: {
            args: Prisma.videos_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videos_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          update: {
            args: Prisma.videos_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.videos_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videos_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videos_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Videos_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos_tags_link>
          }
          groupBy: {
            args: Prisma.videos_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Videos_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.videos_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Videos_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      photos_tags_recherche: {
        payload: Prisma.$photos_tags_recherchePayload<ExtArgs>
        fields: Prisma.photos_tags_rechercheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tags_rechercheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tags_rechercheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          findFirst: {
            args: Prisma.photos_tags_rechercheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tags_rechercheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          findMany: {
            args: Prisma.photos_tags_rechercheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>[]
          }
          create: {
            args: Prisma.photos_tags_rechercheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          createMany: {
            args: Prisma.photos_tags_rechercheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tags_rechercheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          update: {
            args: Prisma.photos_tags_rechercheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          deleteMany: {
            args: Prisma.photos_tags_rechercheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tags_rechercheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tags_rechercheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          aggregate: {
            args: Prisma.Photos_tags_rechercheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags_recherche>
          }
          groupBy: {
            args: Prisma.photos_tags_rechercheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_rechercheGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tags_rechercheCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_rechercheCountAggregateOutputType> | number
          }
        }
      }
      photos_tags_recherche_link: {
        payload: Prisma.$photos_tags_recherche_linkPayload<ExtArgs>
        fields: Prisma.photos_tags_recherche_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tags_recherche_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tags_recherche_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_tags_recherche_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tags_recherche_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          findMany: {
            args: Prisma.photos_tags_recherche_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>[]
          }
          create: {
            args: Prisma.photos_tags_recherche_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          createMany: {
            args: Prisma.photos_tags_recherche_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tags_recherche_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          update: {
            args: Prisma.photos_tags_recherche_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_tags_recherche_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tags_recherche_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tags_recherche_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_tags_recherche_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags_recherche_link>
          }
          groupBy: {
            args: Prisma.photos_tags_recherche_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_recherche_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tags_recherche_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_recherche_linkCountAggregateOutputType> | number
          }
        }
      }
      photos_albums_tags_link: {
        payload: Prisma.$photos_albums_tags_linkPayload<ExtArgs>
        fields: Prisma.photos_albums_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_albums_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_albums_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_albums_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_albums_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          findMany: {
            args: Prisma.photos_albums_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>[]
          }
          create: {
            args: Prisma.photos_albums_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          createMany: {
            args: Prisma.photos_albums_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_albums_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          update: {
            args: Prisma.photos_albums_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_albums_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_albums_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_albums_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_albums_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_albums_tags_link>
          }
          groupBy: {
            args: Prisma.photos_albums_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_albums_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      account: {
        payload: Prisma.$accountPayload<ExtArgs>
        fields: Prisma.accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findFirst: {
            args: Prisma.accountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findMany: {
            args: Prisma.accountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>[]
          }
          create: {
            args: Prisma.accountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          createMany: {
            args: Prisma.accountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          update: {
            args: Prisma.accountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          deleteMany: {
            args: Prisma.accountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.accountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      verification: {
        payload: Prisma.$verificationPayload<ExtArgs>
        fields: Prisma.verificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.verificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.verificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          findFirst: {
            args: Prisma.verificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.verificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          findMany: {
            args: Prisma.verificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>[]
          }
          create: {
            args: Prisma.verificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          createMany: {
            args: Prisma.verificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.verificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          update: {
            args: Prisma.verificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          deleteMany: {
            args: Prisma.verificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.verificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.verificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.verificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.verificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    autre?: autreOmit
    autre_tags?: autre_tagsOmit
    autre_tags_link?: autre_tags_linkOmit
    experiences?: experiencesOmit
    faq?: faqOmit
    photos?: photosOmit
    photos_albums?: photos_albumsOmit
    photos_albums_link?: photos_albums_linkOmit
    photos_experiences?: photos_experiencesOmit
    photos_tags?: photos_tagsOmit
    photos_tags_link?: photos_tags_linkOmit
    temoignages?: temoignagesOmit
    utilisateurs?: utilisateursOmit
    videos?: videosOmit
    videos_tags?: videos_tagsOmit
    videos_tags_link?: videos_tags_linkOmit
    photos_tags_recherche?: photos_tags_rechercheOmit
    photos_tags_recherche_link?: photos_tags_recherche_linkOmit
    photos_albums_tags_link?: photos_albums_tags_linkOmit
    account?: accountOmit
    session?: sessionOmit
    user?: userOmit
    verification?: verificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AutreCountOutputType
   */

  export type AutreCountOutputType = {
    autre_tags_link: number
  }

  export type AutreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autre_tags_link?: boolean | AutreCountOutputTypeCountAutre_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * AutreCountOutputType without action
   */
  export type AutreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutreCountOutputType
     */
    select?: AutreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutreCountOutputType without action
   */
  export type AutreCountOutputTypeCountAutre_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autre_tags_linkWhereInput
  }


  /**
   * Count Type Autre_tagsCountOutputType
   */

  export type Autre_tagsCountOutputType = {
    autre_tags_link: number
  }

  export type Autre_tagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autre_tags_link?: boolean | Autre_tagsCountOutputTypeCountAutre_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Autre_tagsCountOutputType without action
   */
  export type Autre_tagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autre_tagsCountOutputType
     */
    select?: Autre_tagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Autre_tagsCountOutputType without action
   */
  export type Autre_tagsCountOutputTypeCountAutre_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autre_tags_linkWhereInput
  }


  /**
   * Count Type PhotosCountOutputType
   */

  export type PhotosCountOutputType = {
    photos_albums_link: number
    photos_tags_link: number
    photos_tags_recherche_link: number
  }

  export type PhotosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | PhotosCountOutputTypeCountPhotos_albums_linkArgs
    photos_tags_link?: boolean | PhotosCountOutputTypeCountPhotos_tags_linkArgs
    photos_tags_recherche_link?: boolean | PhotosCountOutputTypeCountPhotos_tags_recherche_linkArgs
  }

  // Custom InputTypes
  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosCountOutputType
     */
    select?: PhotosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeCountPhotos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_linkWhereInput
  }

  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeCountPhotos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_linkWhereInput
  }

  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeCountPhotos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_recherche_linkWhereInput
  }


  /**
   * Count Type Photos_albumsCountOutputType
   */

  export type Photos_albumsCountOutputType = {
    photos_albums_link: number
    photos_albums_tags_link: number
  }

  export type Photos_albumsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | Photos_albumsCountOutputTypeCountPhotos_albums_linkArgs
    photos_albums_tags_link?: boolean | Photos_albumsCountOutputTypeCountPhotos_albums_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Photos_albumsCountOutputType without action
   */
  export type Photos_albumsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photos_albumsCountOutputType
     */
    select?: Photos_albumsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Photos_albumsCountOutputType without action
   */
  export type Photos_albumsCountOutputTypeCountPhotos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_linkWhereInput
  }

  /**
   * Photos_albumsCountOutputType without action
   */
  export type Photos_albumsCountOutputTypeCountPhotos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_tags_linkWhereInput
  }


  /**
   * Count Type Photos_tagsCountOutputType
   */

  export type Photos_tagsCountOutputType = {
    photos_albums_tags_link: number
    photos_tags_link: number
  }

  export type Photos_tagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_tags_link?: boolean | Photos_tagsCountOutputTypeCountPhotos_albums_tags_linkArgs
    photos_tags_link?: boolean | Photos_tagsCountOutputTypeCountPhotos_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Photos_tagsCountOutputType without action
   */
  export type Photos_tagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photos_tagsCountOutputType
     */
    select?: Photos_tagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Photos_tagsCountOutputType without action
   */
  export type Photos_tagsCountOutputTypeCountPhotos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_tags_linkWhereInput
  }

  /**
   * Photos_tagsCountOutputType without action
   */
  export type Photos_tagsCountOutputTypeCountPhotos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_linkWhereInput
  }


  /**
   * Count Type VideosCountOutputType
   */

  export type VideosCountOutputType = {
    videos_tags_link: number
  }

  export type VideosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | VideosCountOutputTypeCountVideos_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideosCountOutputType
     */
    select?: VideosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeCountVideos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tags_linkWhereInput
  }


  /**
   * Count Type Videos_tagsCountOutputType
   */

  export type Videos_tagsCountOutputType = {
    videos_tags_link: number
  }

  export type Videos_tagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | Videos_tagsCountOutputTypeCountVideos_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Videos_tagsCountOutputType without action
   */
  export type Videos_tagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos_tagsCountOutputType
     */
    select?: Videos_tagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Videos_tagsCountOutputType without action
   */
  export type Videos_tagsCountOutputTypeCountVideos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tags_linkWhereInput
  }


  /**
   * Count Type Photos_tags_rechercheCountOutputType
   */

  export type Photos_tags_rechercheCountOutputType = {
    photos_tags_recherche_link: number
  }

  export type Photos_tags_rechercheCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_tags_recherche_link?: boolean | Photos_tags_rechercheCountOutputTypeCountPhotos_tags_recherche_linkArgs
  }

  // Custom InputTypes
  /**
   * Photos_tags_rechercheCountOutputType without action
   */
  export type Photos_tags_rechercheCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photos_tags_rechercheCountOutputType
     */
    select?: Photos_tags_rechercheCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Photos_tags_rechercheCountOutputType without action
   */
  export type Photos_tags_rechercheCountOutputTypeCountPhotos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_recherche_linkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model autre
   */

  export type AggregateAutre = {
    _count: AutreCountAggregateOutputType | null
    _avg: AutreAvgAggregateOutputType | null
    _sum: AutreSumAggregateOutputType | null
    _min: AutreMinAggregateOutputType | null
    _max: AutreMaxAggregateOutputType | null
  }

  export type AutreAvgAggregateOutputType = {
    id_autre: number | null
  }

  export type AutreSumAggregateOutputType = {
    id_autre: number | null
  }

  export type AutreMinAggregateOutputType = {
    id_autre: number | null
    titre: string | null
    description: string | null
    miniature: string | null
    lien_github: string | null
    lien_figma: string | null
    lien_site: string | null
    categorie: string | null
    tags: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type AutreMaxAggregateOutputType = {
    id_autre: number | null
    titre: string | null
    description: string | null
    miniature: string | null
    lien_github: string | null
    lien_figma: string | null
    lien_site: string | null
    categorie: string | null
    tags: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type AutreCountAggregateOutputType = {
    id_autre: number
    titre: number
    description: number
    miniature: number
    lien_github: number
    lien_figma: number
    lien_site: number
    categorie: number
    tags: number
    date: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type AutreAvgAggregateInputType = {
    id_autre?: true
  }

  export type AutreSumAggregateInputType = {
    id_autre?: true
  }

  export type AutreMinAggregateInputType = {
    id_autre?: true
    titre?: true
    description?: true
    miniature?: true
    lien_github?: true
    lien_figma?: true
    lien_site?: true
    categorie?: true
    tags?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type AutreMaxAggregateInputType = {
    id_autre?: true
    titre?: true
    description?: true
    miniature?: true
    lien_github?: true
    lien_figma?: true
    lien_site?: true
    categorie?: true
    tags?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type AutreCountAggregateInputType = {
    id_autre?: true
    titre?: true
    description?: true
    miniature?: true
    lien_github?: true
    lien_figma?: true
    lien_site?: true
    categorie?: true
    tags?: true
    date?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type AutreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autre to aggregate.
     */
    where?: autreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autres to fetch.
     */
    orderBy?: autreOrderByWithRelationInput | autreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autres
    **/
    _count?: true | AutreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutreMaxAggregateInputType
  }

  export type GetAutreAggregateType<T extends AutreAggregateArgs> = {
        [P in keyof T & keyof AggregateAutre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutre[P]>
      : GetScalarType<T[P], AggregateAutre[P]>
  }




  export type autreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autreWhereInput
    orderBy?: autreOrderByWithAggregationInput | autreOrderByWithAggregationInput[]
    by: AutreScalarFieldEnum[] | AutreScalarFieldEnum
    having?: autreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutreCountAggregateInputType | true
    _avg?: AutreAvgAggregateInputType
    _sum?: AutreSumAggregateInputType
    _min?: AutreMinAggregateInputType
    _max?: AutreMaxAggregateInputType
  }

  export type AutreGroupByOutputType = {
    id_autre: number
    titre: string
    description: string
    miniature: string
    lien_github: string
    lien_figma: string
    lien_site: string
    categorie: string
    tags: string
    date: Date
    afficher: boolean
    derniere_modification: Date
    _count: AutreCountAggregateOutputType | null
    _avg: AutreAvgAggregateOutputType | null
    _sum: AutreSumAggregateOutputType | null
    _min: AutreMinAggregateOutputType | null
    _max: AutreMaxAggregateOutputType | null
  }

  type GetAutreGroupByPayload<T extends autreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutreGroupByOutputType[P]>
            : GetScalarType<T[P], AutreGroupByOutputType[P]>
        }
      >
    >


  export type autreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_autre?: boolean
    titre?: boolean
    description?: boolean
    miniature?: boolean
    lien_github?: boolean
    lien_figma?: boolean
    lien_site?: boolean
    categorie?: boolean
    tags?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    autre_tags_link?: boolean | autre$autre_tags_linkArgs<ExtArgs>
    _count?: boolean | AutreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autre"]>



  export type autreSelectScalar = {
    id_autre?: boolean
    titre?: boolean
    description?: boolean
    miniature?: boolean
    lien_github?: boolean
    lien_figma?: boolean
    lien_site?: boolean
    categorie?: boolean
    tags?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type autreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_autre" | "titre" | "description" | "miniature" | "lien_github" | "lien_figma" | "lien_site" | "categorie" | "tags" | "date" | "afficher" | "derniere_modification", ExtArgs["result"]["autre"]>
  export type autreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autre_tags_link?: boolean | autre$autre_tags_linkArgs<ExtArgs>
    _count?: boolean | AutreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $autrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "autre"
    objects: {
      autre_tags_link: Prisma.$autre_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_autre: number
      titre: string
      description: string
      miniature: string
      lien_github: string
      lien_figma: string
      lien_site: string
      categorie: string
      tags: string
      date: Date
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["autre"]>
    composites: {}
  }

  type autreGetPayload<S extends boolean | null | undefined | autreDefaultArgs> = $Result.GetResult<Prisma.$autrePayload, S>

  type autreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<autreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutreCountAggregateInputType | true
    }

  export interface autreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autre'], meta: { name: 'autre' } }
    /**
     * Find zero or one Autre that matches the filter.
     * @param {autreFindUniqueArgs} args - Arguments to find a Autre
     * @example
     * // Get one Autre
     * const autre = await prisma.autre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends autreFindUniqueArgs>(args: SelectSubset<T, autreFindUniqueArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Autre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {autreFindUniqueOrThrowArgs} args - Arguments to find a Autre
     * @example
     * // Get one Autre
     * const autre = await prisma.autre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends autreFindUniqueOrThrowArgs>(args: SelectSubset<T, autreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Autre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autreFindFirstArgs} args - Arguments to find a Autre
     * @example
     * // Get one Autre
     * const autre = await prisma.autre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends autreFindFirstArgs>(args?: SelectSubset<T, autreFindFirstArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Autre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autreFindFirstOrThrowArgs} args - Arguments to find a Autre
     * @example
     * // Get one Autre
     * const autre = await prisma.autre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends autreFindFirstOrThrowArgs>(args?: SelectSubset<T, autreFindFirstOrThrowArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Autres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autres
     * const autres = await prisma.autre.findMany()
     * 
     * // Get first 10 Autres
     * const autres = await prisma.autre.findMany({ take: 10 })
     * 
     * // Only select the `id_autre`
     * const autreWithId_autreOnly = await prisma.autre.findMany({ select: { id_autre: true } })
     * 
     */
    findMany<T extends autreFindManyArgs>(args?: SelectSubset<T, autreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Autre.
     * @param {autreCreateArgs} args - Arguments to create a Autre.
     * @example
     * // Create one Autre
     * const Autre = await prisma.autre.create({
     *   data: {
     *     // ... data to create a Autre
     *   }
     * })
     * 
     */
    create<T extends autreCreateArgs>(args: SelectSubset<T, autreCreateArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Autres.
     * @param {autreCreateManyArgs} args - Arguments to create many Autres.
     * @example
     * // Create many Autres
     * const autre = await prisma.autre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends autreCreateManyArgs>(args?: SelectSubset<T, autreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autre.
     * @param {autreDeleteArgs} args - Arguments to delete one Autre.
     * @example
     * // Delete one Autre
     * const Autre = await prisma.autre.delete({
     *   where: {
     *     // ... filter to delete one Autre
     *   }
     * })
     * 
     */
    delete<T extends autreDeleteArgs>(args: SelectSubset<T, autreDeleteArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Autre.
     * @param {autreUpdateArgs} args - Arguments to update one Autre.
     * @example
     * // Update one Autre
     * const autre = await prisma.autre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends autreUpdateArgs>(args: SelectSubset<T, autreUpdateArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Autres.
     * @param {autreDeleteManyArgs} args - Arguments to filter Autres to delete.
     * @example
     * // Delete a few Autres
     * const { count } = await prisma.autre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends autreDeleteManyArgs>(args?: SelectSubset<T, autreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autres
     * const autre = await prisma.autre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends autreUpdateManyArgs>(args: SelectSubset<T, autreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autre.
     * @param {autreUpsertArgs} args - Arguments to update or create a Autre.
     * @example
     * // Update or create a Autre
     * const autre = await prisma.autre.upsert({
     *   create: {
     *     // ... data to create a Autre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autre we want to update
     *   }
     * })
     */
    upsert<T extends autreUpsertArgs>(args: SelectSubset<T, autreUpsertArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Autres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autreCountArgs} args - Arguments to filter Autres to count.
     * @example
     * // Count the number of Autres
     * const count = await prisma.autre.count({
     *   where: {
     *     // ... the filter for the Autres we want to count
     *   }
     * })
    **/
    count<T extends autreCountArgs>(
      args?: Subset<T, autreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutreAggregateArgs>(args: Subset<T, AutreAggregateArgs>): Prisma.PrismaPromise<GetAutreAggregateType<T>>

    /**
     * Group by Autre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autreGroupByArgs['orderBy'] }
        : { orderBy?: autreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the autre model
   */
  readonly fields: autreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for autre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__autreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autre_tags_link<T extends autre$autre_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, autre$autre_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the autre model
   */
  interface autreFieldRefs {
    readonly id_autre: FieldRef<"autre", 'Int'>
    readonly titre: FieldRef<"autre", 'String'>
    readonly description: FieldRef<"autre", 'String'>
    readonly miniature: FieldRef<"autre", 'String'>
    readonly lien_github: FieldRef<"autre", 'String'>
    readonly lien_figma: FieldRef<"autre", 'String'>
    readonly lien_site: FieldRef<"autre", 'String'>
    readonly categorie: FieldRef<"autre", 'String'>
    readonly tags: FieldRef<"autre", 'String'>
    readonly date: FieldRef<"autre", 'DateTime'>
    readonly afficher: FieldRef<"autre", 'Boolean'>
    readonly derniere_modification: FieldRef<"autre", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * autre findUnique
   */
  export type autreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * Filter, which autre to fetch.
     */
    where: autreWhereUniqueInput
  }

  /**
   * autre findUniqueOrThrow
   */
  export type autreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * Filter, which autre to fetch.
     */
    where: autreWhereUniqueInput
  }

  /**
   * autre findFirst
   */
  export type autreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * Filter, which autre to fetch.
     */
    where?: autreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autres to fetch.
     */
    orderBy?: autreOrderByWithRelationInput | autreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autres.
     */
    cursor?: autreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autres.
     */
    distinct?: AutreScalarFieldEnum | AutreScalarFieldEnum[]
  }

  /**
   * autre findFirstOrThrow
   */
  export type autreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * Filter, which autre to fetch.
     */
    where?: autreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autres to fetch.
     */
    orderBy?: autreOrderByWithRelationInput | autreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autres.
     */
    cursor?: autreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autres.
     */
    distinct?: AutreScalarFieldEnum | AutreScalarFieldEnum[]
  }

  /**
   * autre findMany
   */
  export type autreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * Filter, which autres to fetch.
     */
    where?: autreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autres to fetch.
     */
    orderBy?: autreOrderByWithRelationInput | autreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autres.
     */
    cursor?: autreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autres.
     */
    skip?: number
    distinct?: AutreScalarFieldEnum | AutreScalarFieldEnum[]
  }

  /**
   * autre create
   */
  export type autreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * The data needed to create a autre.
     */
    data: XOR<autreCreateInput, autreUncheckedCreateInput>
  }

  /**
   * autre createMany
   */
  export type autreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autres.
     */
    data: autreCreateManyInput | autreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * autre update
   */
  export type autreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * The data needed to update a autre.
     */
    data: XOR<autreUpdateInput, autreUncheckedUpdateInput>
    /**
     * Choose, which autre to update.
     */
    where: autreWhereUniqueInput
  }

  /**
   * autre updateMany
   */
  export type autreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autres.
     */
    data: XOR<autreUpdateManyMutationInput, autreUncheckedUpdateManyInput>
    /**
     * Filter which autres to update
     */
    where?: autreWhereInput
    /**
     * Limit how many autres to update.
     */
    limit?: number
  }

  /**
   * autre upsert
   */
  export type autreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * The filter to search for the autre to update in case it exists.
     */
    where: autreWhereUniqueInput
    /**
     * In case the autre found by the `where` argument doesn't exist, create a new autre with this data.
     */
    create: XOR<autreCreateInput, autreUncheckedCreateInput>
    /**
     * In case the autre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autreUpdateInput, autreUncheckedUpdateInput>
  }

  /**
   * autre delete
   */
  export type autreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
    /**
     * Filter which autre to delete.
     */
    where: autreWhereUniqueInput
  }

  /**
   * autre deleteMany
   */
  export type autreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autres to delete
     */
    where?: autreWhereInput
    /**
     * Limit how many autres to delete.
     */
    limit?: number
  }

  /**
   * autre.autre_tags_link
   */
  export type autre$autre_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    where?: autre_tags_linkWhereInput
    orderBy?: autre_tags_linkOrderByWithRelationInput | autre_tags_linkOrderByWithRelationInput[]
    cursor?: autre_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Autre_tags_linkScalarFieldEnum | Autre_tags_linkScalarFieldEnum[]
  }

  /**
   * autre without action
   */
  export type autreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre
     */
    select?: autreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre
     */
    omit?: autreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autreInclude<ExtArgs> | null
  }


  /**
   * Model autre_tags
   */

  export type AggregateAutre_tags = {
    _count: Autre_tagsCountAggregateOutputType | null
    _avg: Autre_tagsAvgAggregateOutputType | null
    _sum: Autre_tagsSumAggregateOutputType | null
    _min: Autre_tagsMinAggregateOutputType | null
    _max: Autre_tagsMaxAggregateOutputType | null
  }

  export type Autre_tagsAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Autre_tagsSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Autre_tagsMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Autre_tagsMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Autre_tagsCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Autre_tagsAvgAggregateInputType = {
    id_tags?: true
  }

  export type Autre_tagsSumAggregateInputType = {
    id_tags?: true
  }

  export type Autre_tagsMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Autre_tagsMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Autre_tagsCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Autre_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autre_tags to aggregate.
     */
    where?: autre_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags to fetch.
     */
    orderBy?: autre_tagsOrderByWithRelationInput | autre_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autre_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autre_tags
    **/
    _count?: true | Autre_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autre_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autre_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autre_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autre_tagsMaxAggregateInputType
  }

  export type GetAutre_tagsAggregateType<T extends Autre_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateAutre_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutre_tags[P]>
      : GetScalarType<T[P], AggregateAutre_tags[P]>
  }




  export type autre_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autre_tagsWhereInput
    orderBy?: autre_tagsOrderByWithAggregationInput | autre_tagsOrderByWithAggregationInput[]
    by: Autre_tagsScalarFieldEnum[] | Autre_tagsScalarFieldEnum
    having?: autre_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autre_tagsCountAggregateInputType | true
    _avg?: Autre_tagsAvgAggregateInputType
    _sum?: Autre_tagsSumAggregateInputType
    _min?: Autre_tagsMinAggregateInputType
    _max?: Autre_tagsMaxAggregateInputType
  }

  export type Autre_tagsGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Autre_tagsCountAggregateOutputType | null
    _avg: Autre_tagsAvgAggregateOutputType | null
    _sum: Autre_tagsSumAggregateOutputType | null
    _min: Autre_tagsMinAggregateOutputType | null
    _max: Autre_tagsMaxAggregateOutputType | null
  }

  type GetAutre_tagsGroupByPayload<T extends autre_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autre_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autre_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autre_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Autre_tagsGroupByOutputType[P]>
        }
      >
    >


  export type autre_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    autre_tags_link?: boolean | autre_tags$autre_tags_linkArgs<ExtArgs>
    _count?: boolean | Autre_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autre_tags"]>



  export type autre_tagsSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type autre_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["autre_tags"]>
  export type autre_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autre_tags_link?: boolean | autre_tags$autre_tags_linkArgs<ExtArgs>
    _count?: boolean | Autre_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $autre_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "autre_tags"
    objects: {
      autre_tags_link: Prisma.$autre_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["autre_tags"]>
    composites: {}
  }

  type autre_tagsGetPayload<S extends boolean | null | undefined | autre_tagsDefaultArgs> = $Result.GetResult<Prisma.$autre_tagsPayload, S>

  type autre_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<autre_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Autre_tagsCountAggregateInputType | true
    }

  export interface autre_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autre_tags'], meta: { name: 'autre_tags' } }
    /**
     * Find zero or one Autre_tags that matches the filter.
     * @param {autre_tagsFindUniqueArgs} args - Arguments to find a Autre_tags
     * @example
     * // Get one Autre_tags
     * const autre_tags = await prisma.autre_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends autre_tagsFindUniqueArgs>(args: SelectSubset<T, autre_tagsFindUniqueArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Autre_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {autre_tagsFindUniqueOrThrowArgs} args - Arguments to find a Autre_tags
     * @example
     * // Get one Autre_tags
     * const autre_tags = await prisma.autre_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends autre_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, autre_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Autre_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tagsFindFirstArgs} args - Arguments to find a Autre_tags
     * @example
     * // Get one Autre_tags
     * const autre_tags = await prisma.autre_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends autre_tagsFindFirstArgs>(args?: SelectSubset<T, autre_tagsFindFirstArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Autre_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tagsFindFirstOrThrowArgs} args - Arguments to find a Autre_tags
     * @example
     * // Get one Autre_tags
     * const autre_tags = await prisma.autre_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends autre_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, autre_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Autre_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autre_tags
     * const autre_tags = await prisma.autre_tags.findMany()
     * 
     * // Get first 10 Autre_tags
     * const autre_tags = await prisma.autre_tags.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const autre_tagsWithId_tagsOnly = await prisma.autre_tags.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends autre_tagsFindManyArgs>(args?: SelectSubset<T, autre_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Autre_tags.
     * @param {autre_tagsCreateArgs} args - Arguments to create a Autre_tags.
     * @example
     * // Create one Autre_tags
     * const Autre_tags = await prisma.autre_tags.create({
     *   data: {
     *     // ... data to create a Autre_tags
     *   }
     * })
     * 
     */
    create<T extends autre_tagsCreateArgs>(args: SelectSubset<T, autre_tagsCreateArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Autre_tags.
     * @param {autre_tagsCreateManyArgs} args - Arguments to create many Autre_tags.
     * @example
     * // Create many Autre_tags
     * const autre_tags = await prisma.autre_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends autre_tagsCreateManyArgs>(args?: SelectSubset<T, autre_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autre_tags.
     * @param {autre_tagsDeleteArgs} args - Arguments to delete one Autre_tags.
     * @example
     * // Delete one Autre_tags
     * const Autre_tags = await prisma.autre_tags.delete({
     *   where: {
     *     // ... filter to delete one Autre_tags
     *   }
     * })
     * 
     */
    delete<T extends autre_tagsDeleteArgs>(args: SelectSubset<T, autre_tagsDeleteArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Autre_tags.
     * @param {autre_tagsUpdateArgs} args - Arguments to update one Autre_tags.
     * @example
     * // Update one Autre_tags
     * const autre_tags = await prisma.autre_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends autre_tagsUpdateArgs>(args: SelectSubset<T, autre_tagsUpdateArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Autre_tags.
     * @param {autre_tagsDeleteManyArgs} args - Arguments to filter Autre_tags to delete.
     * @example
     * // Delete a few Autre_tags
     * const { count } = await prisma.autre_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends autre_tagsDeleteManyArgs>(args?: SelectSubset<T, autre_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autre_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autre_tags
     * const autre_tags = await prisma.autre_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends autre_tagsUpdateManyArgs>(args: SelectSubset<T, autre_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autre_tags.
     * @param {autre_tagsUpsertArgs} args - Arguments to update or create a Autre_tags.
     * @example
     * // Update or create a Autre_tags
     * const autre_tags = await prisma.autre_tags.upsert({
     *   create: {
     *     // ... data to create a Autre_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autre_tags we want to update
     *   }
     * })
     */
    upsert<T extends autre_tagsUpsertArgs>(args: SelectSubset<T, autre_tagsUpsertArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Autre_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tagsCountArgs} args - Arguments to filter Autre_tags to count.
     * @example
     * // Count the number of Autre_tags
     * const count = await prisma.autre_tags.count({
     *   where: {
     *     // ... the filter for the Autre_tags we want to count
     *   }
     * })
    **/
    count<T extends autre_tagsCountArgs>(
      args?: Subset<T, autre_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autre_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autre_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autre_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autre_tagsAggregateArgs>(args: Subset<T, Autre_tagsAggregateArgs>): Prisma.PrismaPromise<GetAutre_tagsAggregateType<T>>

    /**
     * Group by Autre_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autre_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autre_tagsGroupByArgs['orderBy'] }
        : { orderBy?: autre_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autre_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutre_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the autre_tags model
   */
  readonly fields: autre_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for autre_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__autre_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autre_tags_link<T extends autre_tags$autre_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, autre_tags$autre_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the autre_tags model
   */
  interface autre_tagsFieldRefs {
    readonly id_tags: FieldRef<"autre_tags", 'Int'>
    readonly titre: FieldRef<"autre_tags", 'String'>
    readonly important: FieldRef<"autre_tags", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * autre_tags findUnique
   */
  export type autre_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags to fetch.
     */
    where: autre_tagsWhereUniqueInput
  }

  /**
   * autre_tags findUniqueOrThrow
   */
  export type autre_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags to fetch.
     */
    where: autre_tagsWhereUniqueInput
  }

  /**
   * autre_tags findFirst
   */
  export type autre_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags to fetch.
     */
    where?: autre_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags to fetch.
     */
    orderBy?: autre_tagsOrderByWithRelationInput | autre_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autre_tags.
     */
    cursor?: autre_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autre_tags.
     */
    distinct?: Autre_tagsScalarFieldEnum | Autre_tagsScalarFieldEnum[]
  }

  /**
   * autre_tags findFirstOrThrow
   */
  export type autre_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags to fetch.
     */
    where?: autre_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags to fetch.
     */
    orderBy?: autre_tagsOrderByWithRelationInput | autre_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autre_tags.
     */
    cursor?: autre_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autre_tags.
     */
    distinct?: Autre_tagsScalarFieldEnum | Autre_tagsScalarFieldEnum[]
  }

  /**
   * autre_tags findMany
   */
  export type autre_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags to fetch.
     */
    where?: autre_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags to fetch.
     */
    orderBy?: autre_tagsOrderByWithRelationInput | autre_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autre_tags.
     */
    cursor?: autre_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags.
     */
    skip?: number
    distinct?: Autre_tagsScalarFieldEnum | Autre_tagsScalarFieldEnum[]
  }

  /**
   * autre_tags create
   */
  export type autre_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a autre_tags.
     */
    data: XOR<autre_tagsCreateInput, autre_tagsUncheckedCreateInput>
  }

  /**
   * autre_tags createMany
   */
  export type autre_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autre_tags.
     */
    data: autre_tagsCreateManyInput | autre_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * autre_tags update
   */
  export type autre_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a autre_tags.
     */
    data: XOR<autre_tagsUpdateInput, autre_tagsUncheckedUpdateInput>
    /**
     * Choose, which autre_tags to update.
     */
    where: autre_tagsWhereUniqueInput
  }

  /**
   * autre_tags updateMany
   */
  export type autre_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autre_tags.
     */
    data: XOR<autre_tagsUpdateManyMutationInput, autre_tagsUncheckedUpdateManyInput>
    /**
     * Filter which autre_tags to update
     */
    where?: autre_tagsWhereInput
    /**
     * Limit how many autre_tags to update.
     */
    limit?: number
  }

  /**
   * autre_tags upsert
   */
  export type autre_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the autre_tags to update in case it exists.
     */
    where: autre_tagsWhereUniqueInput
    /**
     * In case the autre_tags found by the `where` argument doesn't exist, create a new autre_tags with this data.
     */
    create: XOR<autre_tagsCreateInput, autre_tagsUncheckedCreateInput>
    /**
     * In case the autre_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autre_tagsUpdateInput, autre_tagsUncheckedUpdateInput>
  }

  /**
   * autre_tags delete
   */
  export type autre_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
    /**
     * Filter which autre_tags to delete.
     */
    where: autre_tagsWhereUniqueInput
  }

  /**
   * autre_tags deleteMany
   */
  export type autre_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autre_tags to delete
     */
    where?: autre_tagsWhereInput
    /**
     * Limit how many autre_tags to delete.
     */
    limit?: number
  }

  /**
   * autre_tags.autre_tags_link
   */
  export type autre_tags$autre_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    where?: autre_tags_linkWhereInput
    orderBy?: autre_tags_linkOrderByWithRelationInput | autre_tags_linkOrderByWithRelationInput[]
    cursor?: autre_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Autre_tags_linkScalarFieldEnum | Autre_tags_linkScalarFieldEnum[]
  }

  /**
   * autre_tags without action
   */
  export type autre_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags
     */
    select?: autre_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags
     */
    omit?: autre_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tagsInclude<ExtArgs> | null
  }


  /**
   * Model autre_tags_link
   */

  export type AggregateAutre_tags_link = {
    _count: Autre_tags_linkCountAggregateOutputType | null
    _avg: Autre_tags_linkAvgAggregateOutputType | null
    _sum: Autre_tags_linkSumAggregateOutputType | null
    _min: Autre_tags_linkMinAggregateOutputType | null
    _max: Autre_tags_linkMaxAggregateOutputType | null
  }

  export type Autre_tags_linkAvgAggregateOutputType = {
    id_autre: number | null
    id_tags: number | null
  }

  export type Autre_tags_linkSumAggregateOutputType = {
    id_autre: number | null
    id_tags: number | null
  }

  export type Autre_tags_linkMinAggregateOutputType = {
    id_autre: number | null
    id_tags: number | null
  }

  export type Autre_tags_linkMaxAggregateOutputType = {
    id_autre: number | null
    id_tags: number | null
  }

  export type Autre_tags_linkCountAggregateOutputType = {
    id_autre: number
    id_tags: number
    _all: number
  }


  export type Autre_tags_linkAvgAggregateInputType = {
    id_autre?: true
    id_tags?: true
  }

  export type Autre_tags_linkSumAggregateInputType = {
    id_autre?: true
    id_tags?: true
  }

  export type Autre_tags_linkMinAggregateInputType = {
    id_autre?: true
    id_tags?: true
  }

  export type Autre_tags_linkMaxAggregateInputType = {
    id_autre?: true
    id_tags?: true
  }

  export type Autre_tags_linkCountAggregateInputType = {
    id_autre?: true
    id_tags?: true
    _all?: true
  }

  export type Autre_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autre_tags_link to aggregate.
     */
    where?: autre_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags_links to fetch.
     */
    orderBy?: autre_tags_linkOrderByWithRelationInput | autre_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autre_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autre_tags_links
    **/
    _count?: true | Autre_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autre_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autre_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autre_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autre_tags_linkMaxAggregateInputType
  }

  export type GetAutre_tags_linkAggregateType<T extends Autre_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateAutre_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutre_tags_link[P]>
      : GetScalarType<T[P], AggregateAutre_tags_link[P]>
  }




  export type autre_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: autre_tags_linkWhereInput
    orderBy?: autre_tags_linkOrderByWithAggregationInput | autre_tags_linkOrderByWithAggregationInput[]
    by: Autre_tags_linkScalarFieldEnum[] | Autre_tags_linkScalarFieldEnum
    having?: autre_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autre_tags_linkCountAggregateInputType | true
    _avg?: Autre_tags_linkAvgAggregateInputType
    _sum?: Autre_tags_linkSumAggregateInputType
    _min?: Autre_tags_linkMinAggregateInputType
    _max?: Autre_tags_linkMaxAggregateInputType
  }

  export type Autre_tags_linkGroupByOutputType = {
    id_autre: number
    id_tags: number
    _count: Autre_tags_linkCountAggregateOutputType | null
    _avg: Autre_tags_linkAvgAggregateOutputType | null
    _sum: Autre_tags_linkSumAggregateOutputType | null
    _min: Autre_tags_linkMinAggregateOutputType | null
    _max: Autre_tags_linkMaxAggregateOutputType | null
  }

  type GetAutre_tags_linkGroupByPayload<T extends autre_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autre_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autre_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autre_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Autre_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type autre_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_autre?: boolean
    id_tags?: boolean
    autre?: boolean | autreDefaultArgs<ExtArgs>
    autre_tags?: boolean | autre_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autre_tags_link"]>



  export type autre_tags_linkSelectScalar = {
    id_autre?: boolean
    id_tags?: boolean
  }

  export type autre_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_autre" | "id_tags", ExtArgs["result"]["autre_tags_link"]>
  export type autre_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autre?: boolean | autreDefaultArgs<ExtArgs>
    autre_tags?: boolean | autre_tagsDefaultArgs<ExtArgs>
  }

  export type $autre_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "autre_tags_link"
    objects: {
      autre: Prisma.$autrePayload<ExtArgs>
      autre_tags: Prisma.$autre_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_autre: number
      id_tags: number
    }, ExtArgs["result"]["autre_tags_link"]>
    composites: {}
  }

  type autre_tags_linkGetPayload<S extends boolean | null | undefined | autre_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$autre_tags_linkPayload, S>

  type autre_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<autre_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Autre_tags_linkCountAggregateInputType | true
    }

  export interface autre_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autre_tags_link'], meta: { name: 'autre_tags_link' } }
    /**
     * Find zero or one Autre_tags_link that matches the filter.
     * @param {autre_tags_linkFindUniqueArgs} args - Arguments to find a Autre_tags_link
     * @example
     * // Get one Autre_tags_link
     * const autre_tags_link = await prisma.autre_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends autre_tags_linkFindUniqueArgs>(args: SelectSubset<T, autre_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Autre_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {autre_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Autre_tags_link
     * @example
     * // Get one Autre_tags_link
     * const autre_tags_link = await prisma.autre_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends autre_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, autre_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Autre_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tags_linkFindFirstArgs} args - Arguments to find a Autre_tags_link
     * @example
     * // Get one Autre_tags_link
     * const autre_tags_link = await prisma.autre_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends autre_tags_linkFindFirstArgs>(args?: SelectSubset<T, autre_tags_linkFindFirstArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Autre_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Autre_tags_link
     * @example
     * // Get one Autre_tags_link
     * const autre_tags_link = await prisma.autre_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends autre_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, autre_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Autre_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autre_tags_links
     * const autre_tags_links = await prisma.autre_tags_link.findMany()
     * 
     * // Get first 10 Autre_tags_links
     * const autre_tags_links = await prisma.autre_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_autre`
     * const autre_tags_linkWithId_autreOnly = await prisma.autre_tags_link.findMany({ select: { id_autre: true } })
     * 
     */
    findMany<T extends autre_tags_linkFindManyArgs>(args?: SelectSubset<T, autre_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Autre_tags_link.
     * @param {autre_tags_linkCreateArgs} args - Arguments to create a Autre_tags_link.
     * @example
     * // Create one Autre_tags_link
     * const Autre_tags_link = await prisma.autre_tags_link.create({
     *   data: {
     *     // ... data to create a Autre_tags_link
     *   }
     * })
     * 
     */
    create<T extends autre_tags_linkCreateArgs>(args: SelectSubset<T, autre_tags_linkCreateArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Autre_tags_links.
     * @param {autre_tags_linkCreateManyArgs} args - Arguments to create many Autre_tags_links.
     * @example
     * // Create many Autre_tags_links
     * const autre_tags_link = await prisma.autre_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends autre_tags_linkCreateManyArgs>(args?: SelectSubset<T, autre_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autre_tags_link.
     * @param {autre_tags_linkDeleteArgs} args - Arguments to delete one Autre_tags_link.
     * @example
     * // Delete one Autre_tags_link
     * const Autre_tags_link = await prisma.autre_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Autre_tags_link
     *   }
     * })
     * 
     */
    delete<T extends autre_tags_linkDeleteArgs>(args: SelectSubset<T, autre_tags_linkDeleteArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Autre_tags_link.
     * @param {autre_tags_linkUpdateArgs} args - Arguments to update one Autre_tags_link.
     * @example
     * // Update one Autre_tags_link
     * const autre_tags_link = await prisma.autre_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends autre_tags_linkUpdateArgs>(args: SelectSubset<T, autre_tags_linkUpdateArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Autre_tags_links.
     * @param {autre_tags_linkDeleteManyArgs} args - Arguments to filter Autre_tags_links to delete.
     * @example
     * // Delete a few Autre_tags_links
     * const { count } = await prisma.autre_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends autre_tags_linkDeleteManyArgs>(args?: SelectSubset<T, autre_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autre_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autre_tags_links
     * const autre_tags_link = await prisma.autre_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends autre_tags_linkUpdateManyArgs>(args: SelectSubset<T, autre_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autre_tags_link.
     * @param {autre_tags_linkUpsertArgs} args - Arguments to update or create a Autre_tags_link.
     * @example
     * // Update or create a Autre_tags_link
     * const autre_tags_link = await prisma.autre_tags_link.upsert({
     *   create: {
     *     // ... data to create a Autre_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autre_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends autre_tags_linkUpsertArgs>(args: SelectSubset<T, autre_tags_linkUpsertArgs<ExtArgs>>): Prisma__autre_tags_linkClient<$Result.GetResult<Prisma.$autre_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Autre_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tags_linkCountArgs} args - Arguments to filter Autre_tags_links to count.
     * @example
     * // Count the number of Autre_tags_links
     * const count = await prisma.autre_tags_link.count({
     *   where: {
     *     // ... the filter for the Autre_tags_links we want to count
     *   }
     * })
    **/
    count<T extends autre_tags_linkCountArgs>(
      args?: Subset<T, autre_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autre_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autre_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autre_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autre_tags_linkAggregateArgs>(args: Subset<T, Autre_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetAutre_tags_linkAggregateType<T>>

    /**
     * Group by Autre_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autre_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autre_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autre_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: autre_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autre_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutre_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the autre_tags_link model
   */
  readonly fields: autre_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for autre_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__autre_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autre<T extends autreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, autreDefaultArgs<ExtArgs>>): Prisma__autreClient<$Result.GetResult<Prisma.$autrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    autre_tags<T extends autre_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, autre_tagsDefaultArgs<ExtArgs>>): Prisma__autre_tagsClient<$Result.GetResult<Prisma.$autre_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the autre_tags_link model
   */
  interface autre_tags_linkFieldRefs {
    readonly id_autre: FieldRef<"autre_tags_link", 'Int'>
    readonly id_tags: FieldRef<"autre_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * autre_tags_link findUnique
   */
  export type autre_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags_link to fetch.
     */
    where: autre_tags_linkWhereUniqueInput
  }

  /**
   * autre_tags_link findUniqueOrThrow
   */
  export type autre_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags_link to fetch.
     */
    where: autre_tags_linkWhereUniqueInput
  }

  /**
   * autre_tags_link findFirst
   */
  export type autre_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags_link to fetch.
     */
    where?: autre_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags_links to fetch.
     */
    orderBy?: autre_tags_linkOrderByWithRelationInput | autre_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autre_tags_links.
     */
    cursor?: autre_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autre_tags_links.
     */
    distinct?: Autre_tags_linkScalarFieldEnum | Autre_tags_linkScalarFieldEnum[]
  }

  /**
   * autre_tags_link findFirstOrThrow
   */
  export type autre_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags_link to fetch.
     */
    where?: autre_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags_links to fetch.
     */
    orderBy?: autre_tags_linkOrderByWithRelationInput | autre_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autre_tags_links.
     */
    cursor?: autre_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autre_tags_links.
     */
    distinct?: Autre_tags_linkScalarFieldEnum | Autre_tags_linkScalarFieldEnum[]
  }

  /**
   * autre_tags_link findMany
   */
  export type autre_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which autre_tags_links to fetch.
     */
    where?: autre_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autre_tags_links to fetch.
     */
    orderBy?: autre_tags_linkOrderByWithRelationInput | autre_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autre_tags_links.
     */
    cursor?: autre_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autre_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autre_tags_links.
     */
    skip?: number
    distinct?: Autre_tags_linkScalarFieldEnum | Autre_tags_linkScalarFieldEnum[]
  }

  /**
   * autre_tags_link create
   */
  export type autre_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a autre_tags_link.
     */
    data: XOR<autre_tags_linkCreateInput, autre_tags_linkUncheckedCreateInput>
  }

  /**
   * autre_tags_link createMany
   */
  export type autre_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autre_tags_links.
     */
    data: autre_tags_linkCreateManyInput | autre_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * autre_tags_link update
   */
  export type autre_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a autre_tags_link.
     */
    data: XOR<autre_tags_linkUpdateInput, autre_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which autre_tags_link to update.
     */
    where: autre_tags_linkWhereUniqueInput
  }

  /**
   * autre_tags_link updateMany
   */
  export type autre_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autre_tags_links.
     */
    data: XOR<autre_tags_linkUpdateManyMutationInput, autre_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which autre_tags_links to update
     */
    where?: autre_tags_linkWhereInput
    /**
     * Limit how many autre_tags_links to update.
     */
    limit?: number
  }

  /**
   * autre_tags_link upsert
   */
  export type autre_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the autre_tags_link to update in case it exists.
     */
    where: autre_tags_linkWhereUniqueInput
    /**
     * In case the autre_tags_link found by the `where` argument doesn't exist, create a new autre_tags_link with this data.
     */
    create: XOR<autre_tags_linkCreateInput, autre_tags_linkUncheckedCreateInput>
    /**
     * In case the autre_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autre_tags_linkUpdateInput, autre_tags_linkUncheckedUpdateInput>
  }

  /**
   * autre_tags_link delete
   */
  export type autre_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which autre_tags_link to delete.
     */
    where: autre_tags_linkWhereUniqueInput
  }

  /**
   * autre_tags_link deleteMany
   */
  export type autre_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which autre_tags_links to delete
     */
    where?: autre_tags_linkWhereInput
    /**
     * Limit how many autre_tags_links to delete.
     */
    limit?: number
  }

  /**
   * autre_tags_link without action
   */
  export type autre_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autre_tags_link
     */
    select?: autre_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the autre_tags_link
     */
    omit?: autre_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: autre_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model experiences
   */

  export type AggregateExperiences = {
    _count: ExperiencesCountAggregateOutputType | null
    _avg: ExperiencesAvgAggregateOutputType | null
    _sum: ExperiencesSumAggregateOutputType | null
    _min: ExperiencesMinAggregateOutputType | null
    _max: ExperiencesMaxAggregateOutputType | null
  }

  export type ExperiencesAvgAggregateOutputType = {
    id_exp: number | null
  }

  export type ExperiencesSumAggregateOutputType = {
    id_exp: number | null
  }

  export type ExperiencesMinAggregateOutputType = {
    id_exp: number | null
    date: Date | null
    titre: string | null
    description: string | null
    url_img: string | null
    position_img: string | null
    afficher: boolean | null
  }

  export type ExperiencesMaxAggregateOutputType = {
    id_exp: number | null
    date: Date | null
    titre: string | null
    description: string | null
    url_img: string | null
    position_img: string | null
    afficher: boolean | null
  }

  export type ExperiencesCountAggregateOutputType = {
    id_exp: number
    date: number
    titre: number
    description: number
    url_img: number
    position_img: number
    afficher: number
    _all: number
  }


  export type ExperiencesAvgAggregateInputType = {
    id_exp?: true
  }

  export type ExperiencesSumAggregateInputType = {
    id_exp?: true
  }

  export type ExperiencesMinAggregateInputType = {
    id_exp?: true
    date?: true
    titre?: true
    description?: true
    url_img?: true
    position_img?: true
    afficher?: true
  }

  export type ExperiencesMaxAggregateInputType = {
    id_exp?: true
    date?: true
    titre?: true
    description?: true
    url_img?: true
    position_img?: true
    afficher?: true
  }

  export type ExperiencesCountAggregateInputType = {
    id_exp?: true
    date?: true
    titre?: true
    description?: true
    url_img?: true
    position_img?: true
    afficher?: true
    _all?: true
  }

  export type ExperiencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which experiences to aggregate.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned experiences
    **/
    _count?: true | ExperiencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperiencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperiencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperiencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperiencesMaxAggregateInputType
  }

  export type GetExperiencesAggregateType<T extends ExperiencesAggregateArgs> = {
        [P in keyof T & keyof AggregateExperiences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperiences[P]>
      : GetScalarType<T[P], AggregateExperiences[P]>
  }




  export type experiencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: experiencesWhereInput
    orderBy?: experiencesOrderByWithAggregationInput | experiencesOrderByWithAggregationInput[]
    by: ExperiencesScalarFieldEnum[] | ExperiencesScalarFieldEnum
    having?: experiencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperiencesCountAggregateInputType | true
    _avg?: ExperiencesAvgAggregateInputType
    _sum?: ExperiencesSumAggregateInputType
    _min?: ExperiencesMinAggregateInputType
    _max?: ExperiencesMaxAggregateInputType
  }

  export type ExperiencesGroupByOutputType = {
    id_exp: number
    date: Date
    titre: string
    description: string
    url_img: string
    position_img: string
    afficher: boolean
    _count: ExperiencesCountAggregateOutputType | null
    _avg: ExperiencesAvgAggregateOutputType | null
    _sum: ExperiencesSumAggregateOutputType | null
    _min: ExperiencesMinAggregateOutputType | null
    _max: ExperiencesMaxAggregateOutputType | null
  }

  type GetExperiencesGroupByPayload<T extends experiencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperiencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperiencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperiencesGroupByOutputType[P]>
            : GetScalarType<T[P], ExperiencesGroupByOutputType[P]>
        }
      >
    >


  export type experiencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_exp?: boolean
    date?: boolean
    titre?: boolean
    description?: boolean
    url_img?: boolean
    position_img?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["experiences"]>



  export type experiencesSelectScalar = {
    id_exp?: boolean
    date?: boolean
    titre?: boolean
    description?: boolean
    url_img?: boolean
    position_img?: boolean
    afficher?: boolean
  }

  export type experiencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_exp" | "date" | "titre" | "description" | "url_img" | "position_img" | "afficher", ExtArgs["result"]["experiences"]>

  export type $experiencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "experiences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_exp: number
      date: Date
      titre: string
      description: string
      url_img: string
      position_img: string
      afficher: boolean
    }, ExtArgs["result"]["experiences"]>
    composites: {}
  }

  type experiencesGetPayload<S extends boolean | null | undefined | experiencesDefaultArgs> = $Result.GetResult<Prisma.$experiencesPayload, S>

  type experiencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<experiencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperiencesCountAggregateInputType | true
    }

  export interface experiencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['experiences'], meta: { name: 'experiences' } }
    /**
     * Find zero or one Experiences that matches the filter.
     * @param {experiencesFindUniqueArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends experiencesFindUniqueArgs>(args: SelectSubset<T, experiencesFindUniqueArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Experiences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {experiencesFindUniqueOrThrowArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends experiencesFindUniqueOrThrowArgs>(args: SelectSubset<T, experiencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesFindFirstArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends experiencesFindFirstArgs>(args?: SelectSubset<T, experiencesFindFirstArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experiences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesFindFirstOrThrowArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends experiencesFindFirstOrThrowArgs>(args?: SelectSubset<T, experiencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiences
     * const experiences = await prisma.experiences.findMany()
     * 
     * // Get first 10 Experiences
     * const experiences = await prisma.experiences.findMany({ take: 10 })
     * 
     * // Only select the `id_exp`
     * const experiencesWithId_expOnly = await prisma.experiences.findMany({ select: { id_exp: true } })
     * 
     */
    findMany<T extends experiencesFindManyArgs>(args?: SelectSubset<T, experiencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Experiences.
     * @param {experiencesCreateArgs} args - Arguments to create a Experiences.
     * @example
     * // Create one Experiences
     * const Experiences = await prisma.experiences.create({
     *   data: {
     *     // ... data to create a Experiences
     *   }
     * })
     * 
     */
    create<T extends experiencesCreateArgs>(args: SelectSubset<T, experiencesCreateArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Experiences.
     * @param {experiencesCreateManyArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experiences = await prisma.experiences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends experiencesCreateManyArgs>(args?: SelectSubset<T, experiencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Experiences.
     * @param {experiencesDeleteArgs} args - Arguments to delete one Experiences.
     * @example
     * // Delete one Experiences
     * const Experiences = await prisma.experiences.delete({
     *   where: {
     *     // ... filter to delete one Experiences
     *   }
     * })
     * 
     */
    delete<T extends experiencesDeleteArgs>(args: SelectSubset<T, experiencesDeleteArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Experiences.
     * @param {experiencesUpdateArgs} args - Arguments to update one Experiences.
     * @example
     * // Update one Experiences
     * const experiences = await prisma.experiences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends experiencesUpdateArgs>(args: SelectSubset<T, experiencesUpdateArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Experiences.
     * @param {experiencesDeleteManyArgs} args - Arguments to filter Experiences to delete.
     * @example
     * // Delete a few Experiences
     * const { count } = await prisma.experiences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends experiencesDeleteManyArgs>(args?: SelectSubset<T, experiencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiences
     * const experiences = await prisma.experiences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends experiencesUpdateManyArgs>(args: SelectSubset<T, experiencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Experiences.
     * @param {experiencesUpsertArgs} args - Arguments to update or create a Experiences.
     * @example
     * // Update or create a Experiences
     * const experiences = await prisma.experiences.upsert({
     *   create: {
     *     // ... data to create a Experiences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experiences we want to update
     *   }
     * })
     */
    upsert<T extends experiencesUpsertArgs>(args: SelectSubset<T, experiencesUpsertArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesCountArgs} args - Arguments to filter Experiences to count.
     * @example
     * // Count the number of Experiences
     * const count = await prisma.experiences.count({
     *   where: {
     *     // ... the filter for the Experiences we want to count
     *   }
     * })
    **/
    count<T extends experiencesCountArgs>(
      args?: Subset<T, experiencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperiencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperiencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperiencesAggregateArgs>(args: Subset<T, ExperiencesAggregateArgs>): Prisma.PrismaPromise<GetExperiencesAggregateType<T>>

    /**
     * Group by Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends experiencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: experiencesGroupByArgs['orderBy'] }
        : { orderBy?: experiencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, experiencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperiencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the experiences model
   */
  readonly fields: experiencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for experiences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__experiencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the experiences model
   */
  interface experiencesFieldRefs {
    readonly id_exp: FieldRef<"experiences", 'Int'>
    readonly date: FieldRef<"experiences", 'DateTime'>
    readonly titre: FieldRef<"experiences", 'String'>
    readonly description: FieldRef<"experiences", 'String'>
    readonly url_img: FieldRef<"experiences", 'String'>
    readonly position_img: FieldRef<"experiences", 'String'>
    readonly afficher: FieldRef<"experiences", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * experiences findUnique
   */
  export type experiencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences findUniqueOrThrow
   */
  export type experiencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences findFirst
   */
  export type experiencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for experiences.
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of experiences.
     */
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * experiences findFirstOrThrow
   */
  export type experiencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for experiences.
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of experiences.
     */
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * experiences findMany
   */
  export type experiencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing experiences.
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * experiences create
   */
  export type experiencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * The data needed to create a experiences.
     */
    data: XOR<experiencesCreateInput, experiencesUncheckedCreateInput>
  }

  /**
   * experiences createMany
   */
  export type experiencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many experiences.
     */
    data: experiencesCreateManyInput | experiencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * experiences update
   */
  export type experiencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * The data needed to update a experiences.
     */
    data: XOR<experiencesUpdateInput, experiencesUncheckedUpdateInput>
    /**
     * Choose, which experiences to update.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences updateMany
   */
  export type experiencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update experiences.
     */
    data: XOR<experiencesUpdateManyMutationInput, experiencesUncheckedUpdateManyInput>
    /**
     * Filter which experiences to update
     */
    where?: experiencesWhereInput
    /**
     * Limit how many experiences to update.
     */
    limit?: number
  }

  /**
   * experiences upsert
   */
  export type experiencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * The filter to search for the experiences to update in case it exists.
     */
    where: experiencesWhereUniqueInput
    /**
     * In case the experiences found by the `where` argument doesn't exist, create a new experiences with this data.
     */
    create: XOR<experiencesCreateInput, experiencesUncheckedCreateInput>
    /**
     * In case the experiences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<experiencesUpdateInput, experiencesUncheckedUpdateInput>
  }

  /**
   * experiences delete
   */
  export type experiencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Filter which experiences to delete.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences deleteMany
   */
  export type experiencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which experiences to delete
     */
    where?: experiencesWhereInput
    /**
     * Limit how many experiences to delete.
     */
    limit?: number
  }

  /**
   * experiences without action
   */
  export type experiencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
  }


  /**
   * Model faq
   */

  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqAvgAggregateOutputType = {
    id_faq: number | null
  }

  export type FaqSumAggregateOutputType = {
    id_faq: number | null
  }

  export type FaqMinAggregateOutputType = {
    id_faq: number | null
    titre: string | null
    contenu: string | null
    afficher: boolean | null
  }

  export type FaqMaxAggregateOutputType = {
    id_faq: number | null
    titre: string | null
    contenu: string | null
    afficher: boolean | null
  }

  export type FaqCountAggregateOutputType = {
    id_faq: number
    titre: number
    contenu: number
    afficher: number
    _all: number
  }


  export type FaqAvgAggregateInputType = {
    id_faq?: true
  }

  export type FaqSumAggregateInputType = {
    id_faq?: true
  }

  export type FaqMinAggregateInputType = {
    id_faq?: true
    titre?: true
    contenu?: true
    afficher?: true
  }

  export type FaqMaxAggregateInputType = {
    id_faq?: true
    titre?: true
    contenu?: true
    afficher?: true
  }

  export type FaqCountAggregateInputType = {
    id_faq?: true
    titre?: true
    contenu?: true
    afficher?: true
    _all?: true
  }

  export type FaqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faq to aggregate.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type faqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqWhereInput
    orderBy?: faqOrderByWithAggregationInput | faqOrderByWithAggregationInput[]
    by: FaqScalarFieldEnum[] | FaqScalarFieldEnum
    having?: faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _avg?: FaqAvgAggregateInputType
    _sum?: FaqSumAggregateInputType
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }

  export type FaqGroupByOutputType = {
    id_faq: number
    titre: string
    contenu: string
    afficher: boolean
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends faqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type faqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_faq?: boolean
    titre?: boolean
    contenu?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["faq"]>



  export type faqSelectScalar = {
    id_faq?: boolean
    titre?: boolean
    contenu?: boolean
    afficher?: boolean
  }

  export type faqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_faq" | "titre" | "contenu" | "afficher", ExtArgs["result"]["faq"]>

  export type $faqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faq"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_faq: number
      titre: string
      contenu: string
      afficher: boolean
    }, ExtArgs["result"]["faq"]>
    composites: {}
  }

  type faqGetPayload<S extends boolean | null | undefined | faqDefaultArgs> = $Result.GetResult<Prisma.$faqPayload, S>

  type faqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<faqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqCountAggregateInputType | true
    }

  export interface faqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faq'], meta: { name: 'faq' } }
    /**
     * Find zero or one Faq that matches the filter.
     * @param {faqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faqFindUniqueArgs>(args: SelectSubset<T, faqFindUniqueArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faqFindUniqueOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faqFindUniqueOrThrowArgs>(args: SelectSubset<T, faqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faqFindFirstArgs>(args?: SelectSubset<T, faqFindFirstArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindFirstOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faqFindFirstOrThrowArgs>(args?: SelectSubset<T, faqFindFirstOrThrowArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id_faq`
     * const faqWithId_faqOnly = await prisma.faq.findMany({ select: { id_faq: true } })
     * 
     */
    findMany<T extends faqFindManyArgs>(args?: SelectSubset<T, faqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faq.
     * @param {faqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
     */
    create<T extends faqCreateArgs>(args: SelectSubset<T, faqCreateArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {faqCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faq = await prisma.faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends faqCreateManyArgs>(args?: SelectSubset<T, faqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {faqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
     */
    delete<T extends faqDeleteArgs>(args: SelectSubset<T, faqDeleteArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faq.
     * @param {faqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends faqUpdateArgs>(args: SelectSubset<T, faqUpdateArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {faqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends faqDeleteManyArgs>(args?: SelectSubset<T, faqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends faqUpdateManyArgs>(args: SelectSubset<T, faqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {faqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
     */
    upsert<T extends faqUpsertArgs>(args: SelectSubset<T, faqUpsertArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends faqCountArgs>(
      args?: Subset<T, faqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): Prisma.PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faqGroupByArgs['orderBy'] }
        : { orderBy?: faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faq model
   */
  readonly fields: faqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the faq model
   */
  interface faqFieldRefs {
    readonly id_faq: FieldRef<"faq", 'Int'>
    readonly titre: FieldRef<"faq", 'String'>
    readonly contenu: FieldRef<"faq", 'String'>
    readonly afficher: FieldRef<"faq", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * faq findUnique
   */
  export type faqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq findUniqueOrThrow
   */
  export type faqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq findFirst
   */
  export type faqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * faq findFirstOrThrow
   */
  export type faqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * faq findMany
   */
  export type faqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faqs.
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * faq create
   */
  export type faqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * The data needed to create a faq.
     */
    data: XOR<faqCreateInput, faqUncheckedCreateInput>
  }

  /**
   * faq createMany
   */
  export type faqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faqs.
     */
    data: faqCreateManyInput | faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * faq update
   */
  export type faqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * The data needed to update a faq.
     */
    data: XOR<faqUpdateInput, faqUncheckedUpdateInput>
    /**
     * Choose, which faq to update.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq updateMany
   */
  export type faqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faqs.
     */
    data: XOR<faqUpdateManyMutationInput, faqUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     */
    where?: faqWhereInput
    /**
     * Limit how many faqs to update.
     */
    limit?: number
  }

  /**
   * faq upsert
   */
  export type faqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * The filter to search for the faq to update in case it exists.
     */
    where: faqWhereUniqueInput
    /**
     * In case the faq found by the `where` argument doesn't exist, create a new faq with this data.
     */
    create: XOR<faqCreateInput, faqUncheckedCreateInput>
    /**
     * In case the faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faqUpdateInput, faqUncheckedUpdateInput>
  }

  /**
   * faq delete
   */
  export type faqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Filter which faq to delete.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq deleteMany
   */
  export type faqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to delete
     */
    where?: faqWhereInput
    /**
     * Limit how many faqs to delete.
     */
    limit?: number
  }

  /**
   * faq without action
   */
  export type faqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
  }


  /**
   * Model photos
   */

  export type AggregatePhotos = {
    _count: PhotosCountAggregateOutputType | null
    _avg: PhotosAvgAggregateOutputType | null
    _sum: PhotosSumAggregateOutputType | null
    _min: PhotosMinAggregateOutputType | null
    _max: PhotosMaxAggregateOutputType | null
  }

  export type PhotosAvgAggregateOutputType = {
    id_pho: number | null
    largeur: number | null
    hauteur: number | null
  }

  export type PhotosSumAggregateOutputType = {
    id_pho: number | null
    largeur: number | null
    hauteur: number | null
  }

  export type PhotosMinAggregateOutputType = {
    id_pho: number | null
    lien_high: string | null
    lien_low: string | null
    largeur: number | null
    hauteur: number | null
    alt: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type PhotosMaxAggregateOutputType = {
    id_pho: number | null
    lien_high: string | null
    lien_low: string | null
    largeur: number | null
    hauteur: number | null
    alt: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type PhotosCountAggregateOutputType = {
    id_pho: number
    lien_high: number
    lien_low: number
    largeur: number
    hauteur: number
    alt: number
    date: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type PhotosAvgAggregateInputType = {
    id_pho?: true
    largeur?: true
    hauteur?: true
  }

  export type PhotosSumAggregateInputType = {
    id_pho?: true
    largeur?: true
    hauteur?: true
  }

  export type PhotosMinAggregateInputType = {
    id_pho?: true
    lien_high?: true
    lien_low?: true
    largeur?: true
    hauteur?: true
    alt?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type PhotosMaxAggregateInputType = {
    id_pho?: true
    lien_high?: true
    lien_low?: true
    largeur?: true
    hauteur?: true
    alt?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type PhotosCountAggregateInputType = {
    id_pho?: true
    lien_high?: true
    lien_low?: true
    largeur?: true
    hauteur?: true
    alt?: true
    date?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type PhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos to aggregate.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos
    **/
    _count?: true | PhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotosMaxAggregateInputType
  }

  export type GetPhotosAggregateType<T extends PhotosAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos[P]>
      : GetScalarType<T[P], AggregatePhotos[P]>
  }




  export type photosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photosWhereInput
    orderBy?: photosOrderByWithAggregationInput | photosOrderByWithAggregationInput[]
    by: PhotosScalarFieldEnum[] | PhotosScalarFieldEnum
    having?: photosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotosCountAggregateInputType | true
    _avg?: PhotosAvgAggregateInputType
    _sum?: PhotosSumAggregateInputType
    _min?: PhotosMinAggregateInputType
    _max?: PhotosMaxAggregateInputType
  }

  export type PhotosGroupByOutputType = {
    id_pho: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date
    afficher: boolean
    derniere_modification: Date
    _count: PhotosCountAggregateOutputType | null
    _avg: PhotosAvgAggregateOutputType | null
    _sum: PhotosSumAggregateOutputType | null
    _min: PhotosMinAggregateOutputType | null
    _max: PhotosMaxAggregateOutputType | null
  }

  type GetPhotosGroupByPayload<T extends photosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotosGroupByOutputType[P]>
            : GetScalarType<T[P], PhotosGroupByOutputType[P]>
        }
      >
    >


  export type photosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    lien_high?: boolean
    lien_low?: boolean
    largeur?: boolean
    hauteur?: boolean
    alt?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    photos_albums_link?: boolean | photos$photos_albums_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos$photos_tags_linkArgs<ExtArgs>
    photos_tags_recherche_link?: boolean | photos$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | PhotosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos"]>



  export type photosSelectScalar = {
    id_pho?: boolean
    lien_high?: boolean
    lien_low?: boolean
    largeur?: boolean
    hauteur?: boolean
    alt?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type photosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "lien_high" | "lien_low" | "largeur" | "hauteur" | "alt" | "date" | "afficher" | "derniere_modification", ExtArgs["result"]["photos"]>
  export type photosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | photos$photos_albums_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos$photos_tags_linkArgs<ExtArgs>
    photos_tags_recherche_link?: boolean | photos$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | PhotosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos"
    objects: {
      photos_albums_link: Prisma.$photos_albums_linkPayload<ExtArgs>[]
      photos_tags_link: Prisma.$photos_tags_linkPayload<ExtArgs>[]
      photos_tags_recherche_link: Prisma.$photos_tags_recherche_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      lien_high: string
      lien_low: string
      largeur: number
      hauteur: number
      alt: string
      date: Date
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["photos"]>
    composites: {}
  }

  type photosGetPayload<S extends boolean | null | undefined | photosDefaultArgs> = $Result.GetResult<Prisma.$photosPayload, S>

  type photosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhotosCountAggregateInputType | true
    }

  export interface photosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos'], meta: { name: 'photos' } }
    /**
     * Find zero or one Photos that matches the filter.
     * @param {photosFindUniqueArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photosFindUniqueArgs>(args: SelectSubset<T, photosFindUniqueArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photosFindUniqueOrThrowArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photosFindUniqueOrThrowArgs>(args: SelectSubset<T, photosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosFindFirstArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photosFindFirstArgs>(args?: SelectSubset<T, photosFindFirstArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosFindFirstOrThrowArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photosFindFirstOrThrowArgs>(args?: SelectSubset<T, photosFindFirstOrThrowArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photos.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photos.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photosWithId_phoOnly = await prisma.photos.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photosFindManyArgs>(args?: SelectSubset<T, photosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos.
     * @param {photosCreateArgs} args - Arguments to create a Photos.
     * @example
     * // Create one Photos
     * const Photos = await prisma.photos.create({
     *   data: {
     *     // ... data to create a Photos
     *   }
     * })
     * 
     */
    create<T extends photosCreateArgs>(args: SelectSubset<T, photosCreateArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos.
     * @param {photosCreateManyArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photos = await prisma.photos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photosCreateManyArgs>(args?: SelectSubset<T, photosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos.
     * @param {photosDeleteArgs} args - Arguments to delete one Photos.
     * @example
     * // Delete one Photos
     * const Photos = await prisma.photos.delete({
     *   where: {
     *     // ... filter to delete one Photos
     *   }
     * })
     * 
     */
    delete<T extends photosDeleteArgs>(args: SelectSubset<T, photosDeleteArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos.
     * @param {photosUpdateArgs} args - Arguments to update one Photos.
     * @example
     * // Update one Photos
     * const photos = await prisma.photos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photosUpdateArgs>(args: SelectSubset<T, photosUpdateArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos.
     * @param {photosDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photosDeleteManyArgs>(args?: SelectSubset<T, photosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photos = await prisma.photos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photosUpdateManyArgs>(args: SelectSubset<T, photosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos.
     * @param {photosUpsertArgs} args - Arguments to update or create a Photos.
     * @example
     * // Update or create a Photos
     * const photos = await prisma.photos.upsert({
     *   create: {
     *     // ... data to create a Photos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos we want to update
     *   }
     * })
     */
    upsert<T extends photosUpsertArgs>(args: SelectSubset<T, photosUpsertArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photos.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends photosCountArgs>(
      args?: Subset<T, photosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotosAggregateArgs>(args: Subset<T, PhotosAggregateArgs>): Prisma.PrismaPromise<GetPhotosAggregateType<T>>

    /**
     * Group by Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photosGroupByArgs['orderBy'] }
        : { orderBy?: photosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos model
   */
  readonly fields: photosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums_link<T extends photos$photos_albums_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos$photos_albums_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_tags_link<T extends photos$photos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos$photos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_tags_recherche_link<T extends photos$photos_tags_recherche_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos$photos_tags_recherche_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos model
   */
  interface photosFieldRefs {
    readonly id_pho: FieldRef<"photos", 'Int'>
    readonly lien_high: FieldRef<"photos", 'String'>
    readonly lien_low: FieldRef<"photos", 'String'>
    readonly largeur: FieldRef<"photos", 'Int'>
    readonly hauteur: FieldRef<"photos", 'Int'>
    readonly alt: FieldRef<"photos", 'String'>
    readonly date: FieldRef<"photos", 'DateTime'>
    readonly afficher: FieldRef<"photos", 'Boolean'>
    readonly derniere_modification: FieldRef<"photos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * photos findUnique
   */
  export type photosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos findUniqueOrThrow
   */
  export type photosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos findFirst
   */
  export type photosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos.
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos.
     */
    distinct?: PhotosScalarFieldEnum | PhotosScalarFieldEnum[]
  }

  /**
   * photos findFirstOrThrow
   */
  export type photosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos.
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos.
     */
    distinct?: PhotosScalarFieldEnum | PhotosScalarFieldEnum[]
  }

  /**
   * photos findMany
   */
  export type photosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos.
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    distinct?: PhotosScalarFieldEnum | PhotosScalarFieldEnum[]
  }

  /**
   * photos create
   */
  export type photosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * The data needed to create a photos.
     */
    data: XOR<photosCreateInput, photosUncheckedCreateInput>
  }

  /**
   * photos createMany
   */
  export type photosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos.
     */
    data: photosCreateManyInput | photosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos update
   */
  export type photosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * The data needed to update a photos.
     */
    data: XOR<photosUpdateInput, photosUncheckedUpdateInput>
    /**
     * Choose, which photos to update.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos updateMany
   */
  export type photosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos.
     */
    data: XOR<photosUpdateManyMutationInput, photosUncheckedUpdateManyInput>
    /**
     * Filter which photos to update
     */
    where?: photosWhereInput
    /**
     * Limit how many photos to update.
     */
    limit?: number
  }

  /**
   * photos upsert
   */
  export type photosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * The filter to search for the photos to update in case it exists.
     */
    where: photosWhereUniqueInput
    /**
     * In case the photos found by the `where` argument doesn't exist, create a new photos with this data.
     */
    create: XOR<photosCreateInput, photosUncheckedCreateInput>
    /**
     * In case the photos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photosUpdateInput, photosUncheckedUpdateInput>
  }

  /**
   * photos delete
   */
  export type photosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter which photos to delete.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos deleteMany
   */
  export type photosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos to delete
     */
    where?: photosWhereInput
    /**
     * Limit how many photos to delete.
     */
    limit?: number
  }

  /**
   * photos.photos_albums_link
   */
  export type photos$photos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    where?: photos_albums_linkWhereInput
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    cursor?: photos_albums_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos.photos_tags_link
   */
  export type photos$photos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    where?: photos_tags_linkWhereInput
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    cursor?: photos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos.photos_tags_recherche_link
   */
  export type photos$photos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    where?: photos_tags_recherche_linkWhereInput
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos without action
   */
  export type photosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
  }


  /**
   * Model photos_albums
   */

  export type AggregatePhotos_albums = {
    _count: Photos_albumsCountAggregateOutputType | null
    _avg: Photos_albumsAvgAggregateOutputType | null
    _sum: Photos_albumsSumAggregateOutputType | null
    _min: Photos_albumsMinAggregateOutputType | null
    _max: Photos_albumsMaxAggregateOutputType | null
  }

  export type Photos_albumsAvgAggregateOutputType = {
    id_alb: number | null
  }

  export type Photos_albumsSumAggregateOutputType = {
    id_alb: number | null
  }

  export type Photos_albumsMinAggregateOutputType = {
    id_alb: number | null
    titre: string | null
    description: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type Photos_albumsMaxAggregateOutputType = {
    id_alb: number | null
    titre: string | null
    description: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type Photos_albumsCountAggregateOutputType = {
    id_alb: number
    titre: number
    description: number
    date: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type Photos_albumsAvgAggregateInputType = {
    id_alb?: true
  }

  export type Photos_albumsSumAggregateInputType = {
    id_alb?: true
  }

  export type Photos_albumsMinAggregateInputType = {
    id_alb?: true
    titre?: true
    description?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type Photos_albumsMaxAggregateInputType = {
    id_alb?: true
    titre?: true
    description?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type Photos_albumsCountAggregateInputType = {
    id_alb?: true
    titre?: true
    description?: true
    date?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type Photos_albumsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums to aggregate.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_albums
    **/
    _count?: true | Photos_albumsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_albumsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_albumsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_albumsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_albumsMaxAggregateInputType
  }

  export type GetPhotos_albumsAggregateType<T extends Photos_albumsAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_albums]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_albums[P]>
      : GetScalarType<T[P], AggregatePhotos_albums[P]>
  }




  export type photos_albumsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albumsWhereInput
    orderBy?: photos_albumsOrderByWithAggregationInput | photos_albumsOrderByWithAggregationInput[]
    by: Photos_albumsScalarFieldEnum[] | Photos_albumsScalarFieldEnum
    having?: photos_albumsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_albumsCountAggregateInputType | true
    _avg?: Photos_albumsAvgAggregateInputType
    _sum?: Photos_albumsSumAggregateInputType
    _min?: Photos_albumsMinAggregateInputType
    _max?: Photos_albumsMaxAggregateInputType
  }

  export type Photos_albumsGroupByOutputType = {
    id_alb: number
    titre: string
    description: string
    date: Date
    afficher: boolean
    derniere_modification: Date
    _count: Photos_albumsCountAggregateOutputType | null
    _avg: Photos_albumsAvgAggregateOutputType | null
    _sum: Photos_albumsSumAggregateOutputType | null
    _min: Photos_albumsMinAggregateOutputType | null
    _max: Photos_albumsMaxAggregateOutputType | null
  }

  type GetPhotos_albumsGroupByPayload<T extends photos_albumsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_albumsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_albumsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_albumsGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_albumsGroupByOutputType[P]>
        }
      >
    >


  export type photos_albumsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alb?: boolean
    titre?: boolean
    description?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    photos_albums_link?: boolean | photos_albums$photos_albums_linkArgs<ExtArgs>
    photos_albums_tags_link?: boolean | photos_albums$photos_albums_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_albumsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_albums"]>



  export type photos_albumsSelectScalar = {
    id_alb?: boolean
    titre?: boolean
    description?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type photos_albumsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_alb" | "titre" | "description" | "date" | "afficher" | "derniere_modification", ExtArgs["result"]["photos_albums"]>
  export type photos_albumsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | photos_albums$photos_albums_linkArgs<ExtArgs>
    photos_albums_tags_link?: boolean | photos_albums$photos_albums_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_albumsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photos_albumsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_albums"
    objects: {
      photos_albums_link: Prisma.$photos_albums_linkPayload<ExtArgs>[]
      photos_albums_tags_link: Prisma.$photos_albums_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_alb: number
      titre: string
      description: string
      date: Date
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["photos_albums"]>
    composites: {}
  }

  type photos_albumsGetPayload<S extends boolean | null | undefined | photos_albumsDefaultArgs> = $Result.GetResult<Prisma.$photos_albumsPayload, S>

  type photos_albumsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_albumsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_albumsCountAggregateInputType | true
    }

  export interface photos_albumsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_albums'], meta: { name: 'photos_albums' } }
    /**
     * Find zero or one Photos_albums that matches the filter.
     * @param {photos_albumsFindUniqueArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_albumsFindUniqueArgs>(args: SelectSubset<T, photos_albumsFindUniqueArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_albums that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_albumsFindUniqueOrThrowArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_albumsFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_albumsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsFindFirstArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_albumsFindFirstArgs>(args?: SelectSubset<T, photos_albumsFindFirstArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsFindFirstOrThrowArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_albumsFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_albumsFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_albums
     * const photos_albums = await prisma.photos_albums.findMany()
     * 
     * // Get first 10 Photos_albums
     * const photos_albums = await prisma.photos_albums.findMany({ take: 10 })
     * 
     * // Only select the `id_alb`
     * const photos_albumsWithId_albOnly = await prisma.photos_albums.findMany({ select: { id_alb: true } })
     * 
     */
    findMany<T extends photos_albumsFindManyArgs>(args?: SelectSubset<T, photos_albumsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_albums.
     * @param {photos_albumsCreateArgs} args - Arguments to create a Photos_albums.
     * @example
     * // Create one Photos_albums
     * const Photos_albums = await prisma.photos_albums.create({
     *   data: {
     *     // ... data to create a Photos_albums
     *   }
     * })
     * 
     */
    create<T extends photos_albumsCreateArgs>(args: SelectSubset<T, photos_albumsCreateArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_albums.
     * @param {photos_albumsCreateManyArgs} args - Arguments to create many Photos_albums.
     * @example
     * // Create many Photos_albums
     * const photos_albums = await prisma.photos_albums.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_albumsCreateManyArgs>(args?: SelectSubset<T, photos_albumsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_albums.
     * @param {photos_albumsDeleteArgs} args - Arguments to delete one Photos_albums.
     * @example
     * // Delete one Photos_albums
     * const Photos_albums = await prisma.photos_albums.delete({
     *   where: {
     *     // ... filter to delete one Photos_albums
     *   }
     * })
     * 
     */
    delete<T extends photos_albumsDeleteArgs>(args: SelectSubset<T, photos_albumsDeleteArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_albums.
     * @param {photos_albumsUpdateArgs} args - Arguments to update one Photos_albums.
     * @example
     * // Update one Photos_albums
     * const photos_albums = await prisma.photos_albums.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_albumsUpdateArgs>(args: SelectSubset<T, photos_albumsUpdateArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_albums.
     * @param {photos_albumsDeleteManyArgs} args - Arguments to filter Photos_albums to delete.
     * @example
     * // Delete a few Photos_albums
     * const { count } = await prisma.photos_albums.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_albumsDeleteManyArgs>(args?: SelectSubset<T, photos_albumsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_albums
     * const photos_albums = await prisma.photos_albums.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_albumsUpdateManyArgs>(args: SelectSubset<T, photos_albumsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_albums.
     * @param {photos_albumsUpsertArgs} args - Arguments to update or create a Photos_albums.
     * @example
     * // Update or create a Photos_albums
     * const photos_albums = await prisma.photos_albums.upsert({
     *   create: {
     *     // ... data to create a Photos_albums
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_albums we want to update
     *   }
     * })
     */
    upsert<T extends photos_albumsUpsertArgs>(args: SelectSubset<T, photos_albumsUpsertArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsCountArgs} args - Arguments to filter Photos_albums to count.
     * @example
     * // Count the number of Photos_albums
     * const count = await prisma.photos_albums.count({
     *   where: {
     *     // ... the filter for the Photos_albums we want to count
     *   }
     * })
    **/
    count<T extends photos_albumsCountArgs>(
      args?: Subset<T, photos_albumsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_albumsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_albumsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_albumsAggregateArgs>(args: Subset<T, Photos_albumsAggregateArgs>): Prisma.PrismaPromise<GetPhotos_albumsAggregateType<T>>

    /**
     * Group by Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_albumsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_albumsGroupByArgs['orderBy'] }
        : { orderBy?: photos_albumsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_albumsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_albumsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_albums model
   */
  readonly fields: photos_albumsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_albums.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_albumsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums_link<T extends photos_albums$photos_albums_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_albums$photos_albums_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_albums_tags_link<T extends photos_albums$photos_albums_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_albums$photos_albums_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_albums model
   */
  interface photos_albumsFieldRefs {
    readonly id_alb: FieldRef<"photos_albums", 'Int'>
    readonly titre: FieldRef<"photos_albums", 'String'>
    readonly description: FieldRef<"photos_albums", 'String'>
    readonly date: FieldRef<"photos_albums", 'DateTime'>
    readonly afficher: FieldRef<"photos_albums", 'Boolean'>
    readonly derniere_modification: FieldRef<"photos_albums", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * photos_albums findUnique
   */
  export type photos_albumsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums findUniqueOrThrow
   */
  export type photos_albumsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums findFirst
   */
  export type photos_albumsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums.
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums.
     */
    distinct?: Photos_albumsScalarFieldEnum | Photos_albumsScalarFieldEnum[]
  }

  /**
   * photos_albums findFirstOrThrow
   */
  export type photos_albumsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums.
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums.
     */
    distinct?: Photos_albumsScalarFieldEnum | Photos_albumsScalarFieldEnum[]
  }

  /**
   * photos_albums findMany
   */
  export type photos_albumsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_albums.
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    distinct?: Photos_albumsScalarFieldEnum | Photos_albumsScalarFieldEnum[]
  }

  /**
   * photos_albums create
   */
  export type photos_albumsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_albums.
     */
    data: XOR<photos_albumsCreateInput, photos_albumsUncheckedCreateInput>
  }

  /**
   * photos_albums createMany
   */
  export type photos_albumsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_albums.
     */
    data: photos_albumsCreateManyInput | photos_albumsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_albums update
   */
  export type photos_albumsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_albums.
     */
    data: XOR<photos_albumsUpdateInput, photos_albumsUncheckedUpdateInput>
    /**
     * Choose, which photos_albums to update.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums updateMany
   */
  export type photos_albumsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_albums.
     */
    data: XOR<photos_albumsUpdateManyMutationInput, photos_albumsUncheckedUpdateManyInput>
    /**
     * Filter which photos_albums to update
     */
    where?: photos_albumsWhereInput
    /**
     * Limit how many photos_albums to update.
     */
    limit?: number
  }

  /**
   * photos_albums upsert
   */
  export type photos_albumsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_albums to update in case it exists.
     */
    where: photos_albumsWhereUniqueInput
    /**
     * In case the photos_albums found by the `where` argument doesn't exist, create a new photos_albums with this data.
     */
    create: XOR<photos_albumsCreateInput, photos_albumsUncheckedCreateInput>
    /**
     * In case the photos_albums was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_albumsUpdateInput, photos_albumsUncheckedUpdateInput>
  }

  /**
   * photos_albums delete
   */
  export type photos_albumsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter which photos_albums to delete.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums deleteMany
   */
  export type photos_albumsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums to delete
     */
    where?: photos_albumsWhereInput
    /**
     * Limit how many photos_albums to delete.
     */
    limit?: number
  }

  /**
   * photos_albums.photos_albums_link
   */
  export type photos_albums$photos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    where?: photos_albums_linkWhereInput
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    cursor?: photos_albums_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums.photos_albums_tags_link
   */
  export type photos_albums$photos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    where?: photos_albums_tags_linkWhereInput
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    cursor?: photos_albums_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums without action
   */
  export type photos_albumsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
  }


  /**
   * Model photos_albums_link
   */

  export type AggregatePhotos_albums_link = {
    _count: Photos_albums_linkCountAggregateOutputType | null
    _avg: Photos_albums_linkAvgAggregateOutputType | null
    _sum: Photos_albums_linkSumAggregateOutputType | null
    _min: Photos_albums_linkMinAggregateOutputType | null
    _max: Photos_albums_linkMaxAggregateOutputType | null
  }

  export type Photos_albums_linkAvgAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkSumAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkMinAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkMaxAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkCountAggregateOutputType = {
    id_pho: number
    id_alb: number
    position: number
    _all: number
  }


  export type Photos_albums_linkAvgAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkSumAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkMinAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkMaxAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkCountAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
    _all?: true
  }

  export type Photos_albums_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_link to aggregate.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_albums_links
    **/
    _count?: true | Photos_albums_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_albums_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_albums_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_albums_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_albums_linkMaxAggregateInputType
  }

  export type GetPhotos_albums_linkAggregateType<T extends Photos_albums_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_albums_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_albums_link[P]>
      : GetScalarType<T[P], AggregatePhotos_albums_link[P]>
  }




  export type photos_albums_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_linkWhereInput
    orderBy?: photos_albums_linkOrderByWithAggregationInput | photos_albums_linkOrderByWithAggregationInput[]
    by: Photos_albums_linkScalarFieldEnum[] | Photos_albums_linkScalarFieldEnum
    having?: photos_albums_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_albums_linkCountAggregateInputType | true
    _avg?: Photos_albums_linkAvgAggregateInputType
    _sum?: Photos_albums_linkSumAggregateInputType
    _min?: Photos_albums_linkMinAggregateInputType
    _max?: Photos_albums_linkMaxAggregateInputType
  }

  export type Photos_albums_linkGroupByOutputType = {
    id_pho: number
    id_alb: number
    position: number
    _count: Photos_albums_linkCountAggregateOutputType | null
    _avg: Photos_albums_linkAvgAggregateOutputType | null
    _sum: Photos_albums_linkSumAggregateOutputType | null
    _min: Photos_albums_linkMinAggregateOutputType | null
    _max: Photos_albums_linkMaxAggregateOutputType | null
  }

  type GetPhotos_albums_linkGroupByPayload<T extends photos_albums_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_albums_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_albums_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_albums_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_albums_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_albums_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    id_alb?: boolean
    position?: boolean
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_albums_link"]>



  export type photos_albums_linkSelectScalar = {
    id_pho?: boolean
    id_alb?: boolean
    position?: boolean
  }

  export type photos_albums_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "id_alb" | "position", ExtArgs["result"]["photos_albums_link"]>
  export type photos_albums_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
  }

  export type $photos_albums_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_albums_link"
    objects: {
      photos: Prisma.$photosPayload<ExtArgs>
      photos_albums: Prisma.$photos_albumsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      id_alb: number
      position: number
    }, ExtArgs["result"]["photos_albums_link"]>
    composites: {}
  }

  type photos_albums_linkGetPayload<S extends boolean | null | undefined | photos_albums_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_albums_linkPayload, S>

  type photos_albums_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_albums_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_albums_linkCountAggregateInputType | true
    }

  export interface photos_albums_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_albums_link'], meta: { name: 'photos_albums_link' } }
    /**
     * Find zero or one Photos_albums_link that matches the filter.
     * @param {photos_albums_linkFindUniqueArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_albums_linkFindUniqueArgs>(args: SelectSubset<T, photos_albums_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_albums_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_albums_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_albums_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_albums_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkFindFirstArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_albums_linkFindFirstArgs>(args?: SelectSubset<T, photos_albums_linkFindFirstArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_albums_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_albums_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_albums_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_albums_links
     * const photos_albums_links = await prisma.photos_albums_link.findMany()
     * 
     * // Get first 10 Photos_albums_links
     * const photos_albums_links = await prisma.photos_albums_link.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photos_albums_linkWithId_phoOnly = await prisma.photos_albums_link.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photos_albums_linkFindManyArgs>(args?: SelectSubset<T, photos_albums_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_albums_link.
     * @param {photos_albums_linkCreateArgs} args - Arguments to create a Photos_albums_link.
     * @example
     * // Create one Photos_albums_link
     * const Photos_albums_link = await prisma.photos_albums_link.create({
     *   data: {
     *     // ... data to create a Photos_albums_link
     *   }
     * })
     * 
     */
    create<T extends photos_albums_linkCreateArgs>(args: SelectSubset<T, photos_albums_linkCreateArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_albums_links.
     * @param {photos_albums_linkCreateManyArgs} args - Arguments to create many Photos_albums_links.
     * @example
     * // Create many Photos_albums_links
     * const photos_albums_link = await prisma.photos_albums_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_albums_linkCreateManyArgs>(args?: SelectSubset<T, photos_albums_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_albums_link.
     * @param {photos_albums_linkDeleteArgs} args - Arguments to delete one Photos_albums_link.
     * @example
     * // Delete one Photos_albums_link
     * const Photos_albums_link = await prisma.photos_albums_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_albums_link
     *   }
     * })
     * 
     */
    delete<T extends photos_albums_linkDeleteArgs>(args: SelectSubset<T, photos_albums_linkDeleteArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_albums_link.
     * @param {photos_albums_linkUpdateArgs} args - Arguments to update one Photos_albums_link.
     * @example
     * // Update one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_albums_linkUpdateArgs>(args: SelectSubset<T, photos_albums_linkUpdateArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_albums_links.
     * @param {photos_albums_linkDeleteManyArgs} args - Arguments to filter Photos_albums_links to delete.
     * @example
     * // Delete a few Photos_albums_links
     * const { count } = await prisma.photos_albums_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_albums_linkDeleteManyArgs>(args?: SelectSubset<T, photos_albums_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_albums_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_albums_links
     * const photos_albums_link = await prisma.photos_albums_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_albums_linkUpdateManyArgs>(args: SelectSubset<T, photos_albums_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_albums_link.
     * @param {photos_albums_linkUpsertArgs} args - Arguments to update or create a Photos_albums_link.
     * @example
     * // Update or create a Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.upsert({
     *   create: {
     *     // ... data to create a Photos_albums_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_albums_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_albums_linkUpsertArgs>(args: SelectSubset<T, photos_albums_linkUpsertArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_albums_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkCountArgs} args - Arguments to filter Photos_albums_links to count.
     * @example
     * // Count the number of Photos_albums_links
     * const count = await prisma.photos_albums_link.count({
     *   where: {
     *     // ... the filter for the Photos_albums_links we want to count
     *   }
     * })
    **/
    count<T extends photos_albums_linkCountArgs>(
      args?: Subset<T, photos_albums_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_albums_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_albums_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_albums_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_albums_linkAggregateArgs>(args: Subset<T, Photos_albums_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_albums_linkAggregateType<T>>

    /**
     * Group by Photos_albums_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_albums_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_albums_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_albums_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_albums_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_albums_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_albums_link model
   */
  readonly fields: photos_albums_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_albums_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_albums_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends photosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photosDefaultArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_albums<T extends photos_albumsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_albumsDefaultArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_albums_link model
   */
  interface photos_albums_linkFieldRefs {
    readonly id_pho: FieldRef<"photos_albums_link", 'Int'>
    readonly id_alb: FieldRef<"photos_albums_link", 'Int'>
    readonly position: FieldRef<"photos_albums_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_albums_link findUnique
   */
  export type photos_albums_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link findUniqueOrThrow
   */
  export type photos_albums_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link findFirst
   */
  export type photos_albums_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_links.
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_links.
     */
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_link findFirstOrThrow
   */
  export type photos_albums_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_links.
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_links.
     */
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_link findMany
   */
  export type photos_albums_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_links to fetch.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_albums_links.
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_link create
   */
  export type photos_albums_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_albums_link.
     */
    data: XOR<photos_albums_linkCreateInput, photos_albums_linkUncheckedCreateInput>
  }

  /**
   * photos_albums_link createMany
   */
  export type photos_albums_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_albums_links.
     */
    data: photos_albums_linkCreateManyInput | photos_albums_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_albums_link update
   */
  export type photos_albums_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_albums_link.
     */
    data: XOR<photos_albums_linkUpdateInput, photos_albums_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_albums_link to update.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link updateMany
   */
  export type photos_albums_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_albums_links.
     */
    data: XOR<photos_albums_linkUpdateManyMutationInput, photos_albums_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_albums_links to update
     */
    where?: photos_albums_linkWhereInput
    /**
     * Limit how many photos_albums_links to update.
     */
    limit?: number
  }

  /**
   * photos_albums_link upsert
   */
  export type photos_albums_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_albums_link to update in case it exists.
     */
    where: photos_albums_linkWhereUniqueInput
    /**
     * In case the photos_albums_link found by the `where` argument doesn't exist, create a new photos_albums_link with this data.
     */
    create: XOR<photos_albums_linkCreateInput, photos_albums_linkUncheckedCreateInput>
    /**
     * In case the photos_albums_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_albums_linkUpdateInput, photos_albums_linkUncheckedUpdateInput>
  }

  /**
   * photos_albums_link delete
   */
  export type photos_albums_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_albums_link to delete.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link deleteMany
   */
  export type photos_albums_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_links to delete
     */
    where?: photos_albums_linkWhereInput
    /**
     * Limit how many photos_albums_links to delete.
     */
    limit?: number
  }

  /**
   * photos_albums_link without action
   */
  export type photos_albums_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
  }


  /**
   * Model photos_experiences
   */

  export type AggregatePhotos_experiences = {
    _count: Photos_experiencesCountAggregateOutputType | null
    _avg: Photos_experiencesAvgAggregateOutputType | null
    _sum: Photos_experiencesSumAggregateOutputType | null
    _min: Photos_experiencesMinAggregateOutputType | null
    _max: Photos_experiencesMaxAggregateOutputType | null
  }

  export type Photos_experiencesAvgAggregateOutputType = {
    id_photo: number | null
  }

  export type Photos_experiencesSumAggregateOutputType = {
    id_photo: number | null
  }

  export type Photos_experiencesMinAggregateOutputType = {
    id_photo: number | null
    titre: string | null
    url: string | null
    date: string | null
  }

  export type Photos_experiencesMaxAggregateOutputType = {
    id_photo: number | null
    titre: string | null
    url: string | null
    date: string | null
  }

  export type Photos_experiencesCountAggregateOutputType = {
    id_photo: number
    titre: number
    url: number
    date: number
    _all: number
  }


  export type Photos_experiencesAvgAggregateInputType = {
    id_photo?: true
  }

  export type Photos_experiencesSumAggregateInputType = {
    id_photo?: true
  }

  export type Photos_experiencesMinAggregateInputType = {
    id_photo?: true
    titre?: true
    url?: true
    date?: true
  }

  export type Photos_experiencesMaxAggregateInputType = {
    id_photo?: true
    titre?: true
    url?: true
    date?: true
  }

  export type Photos_experiencesCountAggregateInputType = {
    id_photo?: true
    titre?: true
    url?: true
    date?: true
    _all?: true
  }

  export type Photos_experiencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_experiences to aggregate.
     */
    where?: photos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_experiences to fetch.
     */
    orderBy?: photos_experiencesOrderByWithRelationInput | photos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_experiences
    **/
    _count?: true | Photos_experiencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_experiencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_experiencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_experiencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_experiencesMaxAggregateInputType
  }

  export type GetPhotos_experiencesAggregateType<T extends Photos_experiencesAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_experiences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_experiences[P]>
      : GetScalarType<T[P], AggregatePhotos_experiences[P]>
  }




  export type photos_experiencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_experiencesWhereInput
    orderBy?: photos_experiencesOrderByWithAggregationInput | photos_experiencesOrderByWithAggregationInput[]
    by: Photos_experiencesScalarFieldEnum[] | Photos_experiencesScalarFieldEnum
    having?: photos_experiencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_experiencesCountAggregateInputType | true
    _avg?: Photos_experiencesAvgAggregateInputType
    _sum?: Photos_experiencesSumAggregateInputType
    _min?: Photos_experiencesMinAggregateInputType
    _max?: Photos_experiencesMaxAggregateInputType
  }

  export type Photos_experiencesGroupByOutputType = {
    id_photo: number
    titre: string
    url: string
    date: string
    _count: Photos_experiencesCountAggregateOutputType | null
    _avg: Photos_experiencesAvgAggregateOutputType | null
    _sum: Photos_experiencesSumAggregateOutputType | null
    _min: Photos_experiencesMinAggregateOutputType | null
    _max: Photos_experiencesMaxAggregateOutputType | null
  }

  type GetPhotos_experiencesGroupByPayload<T extends photos_experiencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_experiencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_experiencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_experiencesGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_experiencesGroupByOutputType[P]>
        }
      >
    >


  export type photos_experiencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_photo?: boolean
    titre?: boolean
    url?: boolean
    date?: boolean
  }, ExtArgs["result"]["photos_experiences"]>



  export type photos_experiencesSelectScalar = {
    id_photo?: boolean
    titre?: boolean
    url?: boolean
    date?: boolean
  }

  export type photos_experiencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_photo" | "titre" | "url" | "date", ExtArgs["result"]["photos_experiences"]>

  export type $photos_experiencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_experiences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_photo: number
      titre: string
      url: string
      date: string
    }, ExtArgs["result"]["photos_experiences"]>
    composites: {}
  }

  type photos_experiencesGetPayload<S extends boolean | null | undefined | photos_experiencesDefaultArgs> = $Result.GetResult<Prisma.$photos_experiencesPayload, S>

  type photos_experiencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_experiencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_experiencesCountAggregateInputType | true
    }

  export interface photos_experiencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_experiences'], meta: { name: 'photos_experiences' } }
    /**
     * Find zero or one Photos_experiences that matches the filter.
     * @param {photos_experiencesFindUniqueArgs} args - Arguments to find a Photos_experiences
     * @example
     * // Get one Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_experiencesFindUniqueArgs>(args: SelectSubset<T, photos_experiencesFindUniqueArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_experiences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_experiencesFindUniqueOrThrowArgs} args - Arguments to find a Photos_experiences
     * @example
     * // Get one Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_experiencesFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_experiencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_experiencesFindFirstArgs} args - Arguments to find a Photos_experiences
     * @example
     * // Get one Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_experiencesFindFirstArgs>(args?: SelectSubset<T, photos_experiencesFindFirstArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_experiences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_experiencesFindFirstOrThrowArgs} args - Arguments to find a Photos_experiences
     * @example
     * // Get one Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_experiencesFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_experiencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_experiencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.findMany()
     * 
     * // Get first 10 Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.findMany({ take: 10 })
     * 
     * // Only select the `id_photo`
     * const photos_experiencesWithId_photoOnly = await prisma.photos_experiences.findMany({ select: { id_photo: true } })
     * 
     */
    findMany<T extends photos_experiencesFindManyArgs>(args?: SelectSubset<T, photos_experiencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_experiences.
     * @param {photos_experiencesCreateArgs} args - Arguments to create a Photos_experiences.
     * @example
     * // Create one Photos_experiences
     * const Photos_experiences = await prisma.photos_experiences.create({
     *   data: {
     *     // ... data to create a Photos_experiences
     *   }
     * })
     * 
     */
    create<T extends photos_experiencesCreateArgs>(args: SelectSubset<T, photos_experiencesCreateArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_experiences.
     * @param {photos_experiencesCreateManyArgs} args - Arguments to create many Photos_experiences.
     * @example
     * // Create many Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_experiencesCreateManyArgs>(args?: SelectSubset<T, photos_experiencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_experiences.
     * @param {photos_experiencesDeleteArgs} args - Arguments to delete one Photos_experiences.
     * @example
     * // Delete one Photos_experiences
     * const Photos_experiences = await prisma.photos_experiences.delete({
     *   where: {
     *     // ... filter to delete one Photos_experiences
     *   }
     * })
     * 
     */
    delete<T extends photos_experiencesDeleteArgs>(args: SelectSubset<T, photos_experiencesDeleteArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_experiences.
     * @param {photos_experiencesUpdateArgs} args - Arguments to update one Photos_experiences.
     * @example
     * // Update one Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_experiencesUpdateArgs>(args: SelectSubset<T, photos_experiencesUpdateArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_experiences.
     * @param {photos_experiencesDeleteManyArgs} args - Arguments to filter Photos_experiences to delete.
     * @example
     * // Delete a few Photos_experiences
     * const { count } = await prisma.photos_experiences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_experiencesDeleteManyArgs>(args?: SelectSubset<T, photos_experiencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_experiencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_experiencesUpdateManyArgs>(args: SelectSubset<T, photos_experiencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_experiences.
     * @param {photos_experiencesUpsertArgs} args - Arguments to update or create a Photos_experiences.
     * @example
     * // Update or create a Photos_experiences
     * const photos_experiences = await prisma.photos_experiences.upsert({
     *   create: {
     *     // ... data to create a Photos_experiences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_experiences we want to update
     *   }
     * })
     */
    upsert<T extends photos_experiencesUpsertArgs>(args: SelectSubset<T, photos_experiencesUpsertArgs<ExtArgs>>): Prisma__photos_experiencesClient<$Result.GetResult<Prisma.$photos_experiencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_experiencesCountArgs} args - Arguments to filter Photos_experiences to count.
     * @example
     * // Count the number of Photos_experiences
     * const count = await prisma.photos_experiences.count({
     *   where: {
     *     // ... the filter for the Photos_experiences we want to count
     *   }
     * })
    **/
    count<T extends photos_experiencesCountArgs>(
      args?: Subset<T, photos_experiencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_experiencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_experiencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_experiencesAggregateArgs>(args: Subset<T, Photos_experiencesAggregateArgs>): Prisma.PrismaPromise<GetPhotos_experiencesAggregateType<T>>

    /**
     * Group by Photos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_experiencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_experiencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_experiencesGroupByArgs['orderBy'] }
        : { orderBy?: photos_experiencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_experiencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_experiencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_experiences model
   */
  readonly fields: photos_experiencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_experiences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_experiencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_experiences model
   */
  interface photos_experiencesFieldRefs {
    readonly id_photo: FieldRef<"photos_experiences", 'Int'>
    readonly titre: FieldRef<"photos_experiences", 'String'>
    readonly url: FieldRef<"photos_experiences", 'String'>
    readonly date: FieldRef<"photos_experiences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * photos_experiences findUnique
   */
  export type photos_experiencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which photos_experiences to fetch.
     */
    where: photos_experiencesWhereUniqueInput
  }

  /**
   * photos_experiences findUniqueOrThrow
   */
  export type photos_experiencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which photos_experiences to fetch.
     */
    where: photos_experiencesWhereUniqueInput
  }

  /**
   * photos_experiences findFirst
   */
  export type photos_experiencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which photos_experiences to fetch.
     */
    where?: photos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_experiences to fetch.
     */
    orderBy?: photos_experiencesOrderByWithRelationInput | photos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_experiences.
     */
    cursor?: photos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_experiences.
     */
    distinct?: Photos_experiencesScalarFieldEnum | Photos_experiencesScalarFieldEnum[]
  }

  /**
   * photos_experiences findFirstOrThrow
   */
  export type photos_experiencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which photos_experiences to fetch.
     */
    where?: photos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_experiences to fetch.
     */
    orderBy?: photos_experiencesOrderByWithRelationInput | photos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_experiences.
     */
    cursor?: photos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_experiences.
     */
    distinct?: Photos_experiencesScalarFieldEnum | Photos_experiencesScalarFieldEnum[]
  }

  /**
   * photos_experiences findMany
   */
  export type photos_experiencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which photos_experiences to fetch.
     */
    where?: photos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_experiences to fetch.
     */
    orderBy?: photos_experiencesOrderByWithRelationInput | photos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_experiences.
     */
    cursor?: photos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_experiences.
     */
    skip?: number
    distinct?: Photos_experiencesScalarFieldEnum | Photos_experiencesScalarFieldEnum[]
  }

  /**
   * photos_experiences create
   */
  export type photos_experiencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * The data needed to create a photos_experiences.
     */
    data: XOR<photos_experiencesCreateInput, photos_experiencesUncheckedCreateInput>
  }

  /**
   * photos_experiences createMany
   */
  export type photos_experiencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_experiences.
     */
    data: photos_experiencesCreateManyInput | photos_experiencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_experiences update
   */
  export type photos_experiencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * The data needed to update a photos_experiences.
     */
    data: XOR<photos_experiencesUpdateInput, photos_experiencesUncheckedUpdateInput>
    /**
     * Choose, which photos_experiences to update.
     */
    where: photos_experiencesWhereUniqueInput
  }

  /**
   * photos_experiences updateMany
   */
  export type photos_experiencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_experiences.
     */
    data: XOR<photos_experiencesUpdateManyMutationInput, photos_experiencesUncheckedUpdateManyInput>
    /**
     * Filter which photos_experiences to update
     */
    where?: photos_experiencesWhereInput
    /**
     * Limit how many photos_experiences to update.
     */
    limit?: number
  }

  /**
   * photos_experiences upsert
   */
  export type photos_experiencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * The filter to search for the photos_experiences to update in case it exists.
     */
    where: photos_experiencesWhereUniqueInput
    /**
     * In case the photos_experiences found by the `where` argument doesn't exist, create a new photos_experiences with this data.
     */
    create: XOR<photos_experiencesCreateInput, photos_experiencesUncheckedCreateInput>
    /**
     * In case the photos_experiences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_experiencesUpdateInput, photos_experiencesUncheckedUpdateInput>
  }

  /**
   * photos_experiences delete
   */
  export type photos_experiencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
    /**
     * Filter which photos_experiences to delete.
     */
    where: photos_experiencesWhereUniqueInput
  }

  /**
   * photos_experiences deleteMany
   */
  export type photos_experiencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_experiences to delete
     */
    where?: photos_experiencesWhereInput
    /**
     * Limit how many photos_experiences to delete.
     */
    limit?: number
  }

  /**
   * photos_experiences without action
   */
  export type photos_experiencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_experiences
     */
    select?: photos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_experiences
     */
    omit?: photos_experiencesOmit<ExtArgs> | null
  }


  /**
   * Model photos_tags
   */

  export type AggregatePhotos_tags = {
    _count: Photos_tagsCountAggregateOutputType | null
    _avg: Photos_tagsAvgAggregateOutputType | null
    _sum: Photos_tagsSumAggregateOutputType | null
    _min: Photos_tagsMinAggregateOutputType | null
    _max: Photos_tagsMaxAggregateOutputType | null
  }

  export type Photos_tagsAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tagsSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tagsMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tagsMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tagsCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Photos_tagsAvgAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tagsSumAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tagsMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tagsMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tagsCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Photos_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags to aggregate.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags
    **/
    _count?: true | Photos_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tagsMaxAggregateInputType
  }

  export type GetPhotos_tagsAggregateType<T extends Photos_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags[P]>
      : GetScalarType<T[P], AggregatePhotos_tags[P]>
  }




  export type photos_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tagsWhereInput
    orderBy?: photos_tagsOrderByWithAggregationInput | photos_tagsOrderByWithAggregationInput[]
    by: Photos_tagsScalarFieldEnum[] | Photos_tagsScalarFieldEnum
    having?: photos_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tagsCountAggregateInputType | true
    _avg?: Photos_tagsAvgAggregateInputType
    _sum?: Photos_tagsSumAggregateInputType
    _min?: Photos_tagsMinAggregateInputType
    _max?: Photos_tagsMaxAggregateInputType
  }

  export type Photos_tagsGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Photos_tagsCountAggregateOutputType | null
    _avg: Photos_tagsAvgAggregateOutputType | null
    _sum: Photos_tagsSumAggregateOutputType | null
    _min: Photos_tagsMinAggregateOutputType | null
    _max: Photos_tagsMaxAggregateOutputType | null
  }

  type GetPhotos_tagsGroupByPayload<T extends photos_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tagsGroupByOutputType[P]>
        }
      >
    >


  export type photos_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    photos_albums_tags_link?: boolean | photos_tags$photos_albums_tags_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos_tags$photos_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags"]>



  export type photos_tagsSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type photos_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["photos_tags"]>
  export type photos_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_tags_link?: boolean | photos_tags$photos_albums_tags_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos_tags$photos_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photos_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags"
    objects: {
      photos_albums_tags_link: Prisma.$photos_albums_tags_linkPayload<ExtArgs>[]
      photos_tags_link: Prisma.$photos_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["photos_tags"]>
    composites: {}
  }

  type photos_tagsGetPayload<S extends boolean | null | undefined | photos_tagsDefaultArgs> = $Result.GetResult<Prisma.$photos_tagsPayload, S>

  type photos_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tagsCountAggregateInputType | true
    }

  export interface photos_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags'], meta: { name: 'photos_tags' } }
    /**
     * Find zero or one Photos_tags that matches the filter.
     * @param {photos_tagsFindUniqueArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tagsFindUniqueArgs>(args: SelectSubset<T, photos_tagsFindUniqueArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tagsFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsFindFirstArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tagsFindFirstArgs>(args?: SelectSubset<T, photos_tagsFindFirstArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsFindFirstOrThrowArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags
     * const photos_tags = await prisma.photos_tags.findMany()
     * 
     * // Get first 10 Photos_tags
     * const photos_tags = await prisma.photos_tags.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const photos_tagsWithId_tagsOnly = await prisma.photos_tags.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends photos_tagsFindManyArgs>(args?: SelectSubset<T, photos_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags.
     * @param {photos_tagsCreateArgs} args - Arguments to create a Photos_tags.
     * @example
     * // Create one Photos_tags
     * const Photos_tags = await prisma.photos_tags.create({
     *   data: {
     *     // ... data to create a Photos_tags
     *   }
     * })
     * 
     */
    create<T extends photos_tagsCreateArgs>(args: SelectSubset<T, photos_tagsCreateArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags.
     * @param {photos_tagsCreateManyArgs} args - Arguments to create many Photos_tags.
     * @example
     * // Create many Photos_tags
     * const photos_tags = await prisma.photos_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tagsCreateManyArgs>(args?: SelectSubset<T, photos_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags.
     * @param {photos_tagsDeleteArgs} args - Arguments to delete one Photos_tags.
     * @example
     * // Delete one Photos_tags
     * const Photos_tags = await prisma.photos_tags.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags
     *   }
     * })
     * 
     */
    delete<T extends photos_tagsDeleteArgs>(args: SelectSubset<T, photos_tagsDeleteArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags.
     * @param {photos_tagsUpdateArgs} args - Arguments to update one Photos_tags.
     * @example
     * // Update one Photos_tags
     * const photos_tags = await prisma.photos_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tagsUpdateArgs>(args: SelectSubset<T, photos_tagsUpdateArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags.
     * @param {photos_tagsDeleteManyArgs} args - Arguments to filter Photos_tags to delete.
     * @example
     * // Delete a few Photos_tags
     * const { count } = await prisma.photos_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tagsDeleteManyArgs>(args?: SelectSubset<T, photos_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags
     * const photos_tags = await prisma.photos_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tagsUpdateManyArgs>(args: SelectSubset<T, photos_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags.
     * @param {photos_tagsUpsertArgs} args - Arguments to update or create a Photos_tags.
     * @example
     * // Update or create a Photos_tags
     * const photos_tags = await prisma.photos_tags.upsert({
     *   create: {
     *     // ... data to create a Photos_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags we want to update
     *   }
     * })
     */
    upsert<T extends photos_tagsUpsertArgs>(args: SelectSubset<T, photos_tagsUpsertArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsCountArgs} args - Arguments to filter Photos_tags to count.
     * @example
     * // Count the number of Photos_tags
     * const count = await prisma.photos_tags.count({
     *   where: {
     *     // ... the filter for the Photos_tags we want to count
     *   }
     * })
    **/
    count<T extends photos_tagsCountArgs>(
      args?: Subset<T, photos_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tagsAggregateArgs>(args: Subset<T, Photos_tagsAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tagsAggregateType<T>>

    /**
     * Group by Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tagsGroupByArgs['orderBy'] }
        : { orderBy?: photos_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags model
   */
  readonly fields: photos_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums_tags_link<T extends photos_tags$photos_albums_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags$photos_albums_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_tags_link<T extends photos_tags$photos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags$photos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags model
   */
  interface photos_tagsFieldRefs {
    readonly id_tags: FieldRef<"photos_tags", 'Int'>
    readonly titre: FieldRef<"photos_tags", 'String'>
    readonly important: FieldRef<"photos_tags", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags findUnique
   */
  export type photos_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags findUniqueOrThrow
   */
  export type photos_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags findFirst
   */
  export type photos_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags.
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags.
     */
    distinct?: Photos_tagsScalarFieldEnum | Photos_tagsScalarFieldEnum[]
  }

  /**
   * photos_tags findFirstOrThrow
   */
  export type photos_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags.
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags.
     */
    distinct?: Photos_tagsScalarFieldEnum | Photos_tagsScalarFieldEnum[]
  }

  /**
   * photos_tags findMany
   */
  export type photos_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags.
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    distinct?: Photos_tagsScalarFieldEnum | Photos_tagsScalarFieldEnum[]
  }

  /**
   * photos_tags create
   */
  export type photos_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags.
     */
    data: XOR<photos_tagsCreateInput, photos_tagsUncheckedCreateInput>
  }

  /**
   * photos_tags createMany
   */
  export type photos_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags.
     */
    data: photos_tagsCreateManyInput | photos_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags update
   */
  export type photos_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags.
     */
    data: XOR<photos_tagsUpdateInput, photos_tagsUncheckedUpdateInput>
    /**
     * Choose, which photos_tags to update.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags updateMany
   */
  export type photos_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags.
     */
    data: XOR<photos_tagsUpdateManyMutationInput, photos_tagsUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags to update
     */
    where?: photos_tagsWhereInput
    /**
     * Limit how many photos_tags to update.
     */
    limit?: number
  }

  /**
   * photos_tags upsert
   */
  export type photos_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags to update in case it exists.
     */
    where: photos_tagsWhereUniqueInput
    /**
     * In case the photos_tags found by the `where` argument doesn't exist, create a new photos_tags with this data.
     */
    create: XOR<photos_tagsCreateInput, photos_tagsUncheckedCreateInput>
    /**
     * In case the photos_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tagsUpdateInput, photos_tagsUncheckedUpdateInput>
  }

  /**
   * photos_tags delete
   */
  export type photos_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter which photos_tags to delete.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags deleteMany
   */
  export type photos_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags to delete
     */
    where?: photos_tagsWhereInput
    /**
     * Limit how many photos_tags to delete.
     */
    limit?: number
  }

  /**
   * photos_tags.photos_albums_tags_link
   */
  export type photos_tags$photos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    where?: photos_albums_tags_linkWhereInput
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    cursor?: photos_albums_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags.photos_tags_link
   */
  export type photos_tags$photos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    where?: photos_tags_linkWhereInput
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    cursor?: photos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags without action
   */
  export type photos_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags_link
   */

  export type AggregatePhotos_tags_link = {
    _count: Photos_tags_linkCountAggregateOutputType | null
    _avg: Photos_tags_linkAvgAggregateOutputType | null
    _sum: Photos_tags_linkSumAggregateOutputType | null
    _min: Photos_tags_linkMinAggregateOutputType | null
    _max: Photos_tags_linkMaxAggregateOutputType | null
  }

  export type Photos_tags_linkAvgAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkSumAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkMinAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkMaxAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkCountAggregateOutputType = {
    id_pho: number
    id_tags: number
    _all: number
  }


  export type Photos_tags_linkAvgAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkSumAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkMinAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkMaxAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkCountAggregateInputType = {
    id_pho?: true
    id_tags?: true
    _all?: true
  }

  export type Photos_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_link to aggregate.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags_links
    **/
    _count?: true | Photos_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tags_linkMaxAggregateInputType
  }

  export type GetPhotos_tags_linkAggregateType<T extends Photos_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags_link[P]>
      : GetScalarType<T[P], AggregatePhotos_tags_link[P]>
  }




  export type photos_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_linkWhereInput
    orderBy?: photos_tags_linkOrderByWithAggregationInput | photos_tags_linkOrderByWithAggregationInput[]
    by: Photos_tags_linkScalarFieldEnum[] | Photos_tags_linkScalarFieldEnum
    having?: photos_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tags_linkCountAggregateInputType | true
    _avg?: Photos_tags_linkAvgAggregateInputType
    _sum?: Photos_tags_linkSumAggregateInputType
    _min?: Photos_tags_linkMinAggregateInputType
    _max?: Photos_tags_linkMaxAggregateInputType
  }

  export type Photos_tags_linkGroupByOutputType = {
    id_pho: number
    id_tags: number
    _count: Photos_tags_linkCountAggregateOutputType | null
    _avg: Photos_tags_linkAvgAggregateOutputType | null
    _sum: Photos_tags_linkSumAggregateOutputType | null
    _min: Photos_tags_linkMinAggregateOutputType | null
    _max: Photos_tags_linkMaxAggregateOutputType | null
  }

  type GetPhotos_tags_linkGroupByPayload<T extends photos_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    id_tags?: boolean
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags_link"]>



  export type photos_tags_linkSelectScalar = {
    id_pho?: boolean
    id_tags?: boolean
  }

  export type photos_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "id_tags", ExtArgs["result"]["photos_tags_link"]>
  export type photos_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }

  export type $photos_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags_link"
    objects: {
      photos: Prisma.$photosPayload<ExtArgs>
      photos_tags: Prisma.$photos_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      id_tags: number
    }, ExtArgs["result"]["photos_tags_link"]>
    composites: {}
  }

  type photos_tags_linkGetPayload<S extends boolean | null | undefined | photos_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_tags_linkPayload, S>

  type photos_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tags_linkCountAggregateInputType | true
    }

  export interface photos_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags_link'], meta: { name: 'photos_tags_link' } }
    /**
     * Find zero or one Photos_tags_link that matches the filter.
     * @param {photos_tags_linkFindUniqueArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tags_linkFindUniqueArgs>(args: SelectSubset<T, photos_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkFindFirstArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tags_linkFindFirstArgs>(args?: SelectSubset<T, photos_tags_linkFindFirstArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags_links
     * const photos_tags_links = await prisma.photos_tags_link.findMany()
     * 
     * // Get first 10 Photos_tags_links
     * const photos_tags_links = await prisma.photos_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photos_tags_linkWithId_phoOnly = await prisma.photos_tags_link.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photos_tags_linkFindManyArgs>(args?: SelectSubset<T, photos_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags_link.
     * @param {photos_tags_linkCreateArgs} args - Arguments to create a Photos_tags_link.
     * @example
     * // Create one Photos_tags_link
     * const Photos_tags_link = await prisma.photos_tags_link.create({
     *   data: {
     *     // ... data to create a Photos_tags_link
     *   }
     * })
     * 
     */
    create<T extends photos_tags_linkCreateArgs>(args: SelectSubset<T, photos_tags_linkCreateArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags_links.
     * @param {photos_tags_linkCreateManyArgs} args - Arguments to create many Photos_tags_links.
     * @example
     * // Create many Photos_tags_links
     * const photos_tags_link = await prisma.photos_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tags_linkCreateManyArgs>(args?: SelectSubset<T, photos_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags_link.
     * @param {photos_tags_linkDeleteArgs} args - Arguments to delete one Photos_tags_link.
     * @example
     * // Delete one Photos_tags_link
     * const Photos_tags_link = await prisma.photos_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags_link
     *   }
     * })
     * 
     */
    delete<T extends photos_tags_linkDeleteArgs>(args: SelectSubset<T, photos_tags_linkDeleteArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags_link.
     * @param {photos_tags_linkUpdateArgs} args - Arguments to update one Photos_tags_link.
     * @example
     * // Update one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tags_linkUpdateArgs>(args: SelectSubset<T, photos_tags_linkUpdateArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags_links.
     * @param {photos_tags_linkDeleteManyArgs} args - Arguments to filter Photos_tags_links to delete.
     * @example
     * // Delete a few Photos_tags_links
     * const { count } = await prisma.photos_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tags_linkDeleteManyArgs>(args?: SelectSubset<T, photos_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags_links
     * const photos_tags_link = await prisma.photos_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tags_linkUpdateManyArgs>(args: SelectSubset<T, photos_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags_link.
     * @param {photos_tags_linkUpsertArgs} args - Arguments to update or create a Photos_tags_link.
     * @example
     * // Update or create a Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.upsert({
     *   create: {
     *     // ... data to create a Photos_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_tags_linkUpsertArgs>(args: SelectSubset<T, photos_tags_linkUpsertArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkCountArgs} args - Arguments to filter Photos_tags_links to count.
     * @example
     * // Count the number of Photos_tags_links
     * const count = await prisma.photos_tags_link.count({
     *   where: {
     *     // ... the filter for the Photos_tags_links we want to count
     *   }
     * })
    **/
    count<T extends photos_tags_linkCountArgs>(
      args?: Subset<T, photos_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tags_linkAggregateArgs>(args: Subset<T, Photos_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tags_linkAggregateType<T>>

    /**
     * Group by Photos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags_link model
   */
  readonly fields: photos_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends photosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photosDefaultArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_tags<T extends photos_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_tagsDefaultArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags_link model
   */
  interface photos_tags_linkFieldRefs {
    readonly id_pho: FieldRef<"photos_tags_link", 'Int'>
    readonly id_tags: FieldRef<"photos_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags_link findUnique
   */
  export type photos_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link findUniqueOrThrow
   */
  export type photos_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link findFirst
   */
  export type photos_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_links.
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_links.
     */
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_link findFirstOrThrow
   */
  export type photos_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_links.
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_links.
     */
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_link findMany
   */
  export type photos_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_links to fetch.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags_links.
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_link create
   */
  export type photos_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags_link.
     */
    data: XOR<photos_tags_linkCreateInput, photos_tags_linkUncheckedCreateInput>
  }

  /**
   * photos_tags_link createMany
   */
  export type photos_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags_links.
     */
    data: photos_tags_linkCreateManyInput | photos_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags_link update
   */
  export type photos_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags_link.
     */
    data: XOR<photos_tags_linkUpdateInput, photos_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_tags_link to update.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link updateMany
   */
  export type photos_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags_links.
     */
    data: XOR<photos_tags_linkUpdateManyMutationInput, photos_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags_links to update
     */
    where?: photos_tags_linkWhereInput
    /**
     * Limit how many photos_tags_links to update.
     */
    limit?: number
  }

  /**
   * photos_tags_link upsert
   */
  export type photos_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags_link to update in case it exists.
     */
    where: photos_tags_linkWhereUniqueInput
    /**
     * In case the photos_tags_link found by the `where` argument doesn't exist, create a new photos_tags_link with this data.
     */
    create: XOR<photos_tags_linkCreateInput, photos_tags_linkUncheckedCreateInput>
    /**
     * In case the photos_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tags_linkUpdateInput, photos_tags_linkUncheckedUpdateInput>
  }

  /**
   * photos_tags_link delete
   */
  export type photos_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_tags_link to delete.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link deleteMany
   */
  export type photos_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_links to delete
     */
    where?: photos_tags_linkWhereInput
    /**
     * Limit how many photos_tags_links to delete.
     */
    limit?: number
  }

  /**
   * photos_tags_link without action
   */
  export type photos_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model temoignages
   */

  export type AggregateTemoignages = {
    _count: TemoignagesCountAggregateOutputType | null
    _avg: TemoignagesAvgAggregateOutputType | null
    _sum: TemoignagesSumAggregateOutputType | null
    _min: TemoignagesMinAggregateOutputType | null
    _max: TemoignagesMaxAggregateOutputType | null
  }

  export type TemoignagesAvgAggregateOutputType = {
    id_tem: number | null
  }

  export type TemoignagesSumAggregateOutputType = {
    id_tem: number | null
  }

  export type TemoignagesMinAggregateOutputType = {
    id_tem: number | null
    contenu: string | null
    client: string | null
    plateforme: string | null
    date: string | null
    afficher: boolean | null
  }

  export type TemoignagesMaxAggregateOutputType = {
    id_tem: number | null
    contenu: string | null
    client: string | null
    plateforme: string | null
    date: string | null
    afficher: boolean | null
  }

  export type TemoignagesCountAggregateOutputType = {
    id_tem: number
    contenu: number
    client: number
    plateforme: number
    date: number
    afficher: number
    _all: number
  }


  export type TemoignagesAvgAggregateInputType = {
    id_tem?: true
  }

  export type TemoignagesSumAggregateInputType = {
    id_tem?: true
  }

  export type TemoignagesMinAggregateInputType = {
    id_tem?: true
    contenu?: true
    client?: true
    plateforme?: true
    date?: true
    afficher?: true
  }

  export type TemoignagesMaxAggregateInputType = {
    id_tem?: true
    contenu?: true
    client?: true
    plateforme?: true
    date?: true
    afficher?: true
  }

  export type TemoignagesCountAggregateInputType = {
    id_tem?: true
    contenu?: true
    client?: true
    plateforme?: true
    date?: true
    afficher?: true
    _all?: true
  }

  export type TemoignagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which temoignages to aggregate.
     */
    where?: temoignagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temoignages to fetch.
     */
    orderBy?: temoignagesOrderByWithRelationInput | temoignagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: temoignagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temoignages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned temoignages
    **/
    _count?: true | TemoignagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemoignagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemoignagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemoignagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemoignagesMaxAggregateInputType
  }

  export type GetTemoignagesAggregateType<T extends TemoignagesAggregateArgs> = {
        [P in keyof T & keyof AggregateTemoignages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemoignages[P]>
      : GetScalarType<T[P], AggregateTemoignages[P]>
  }




  export type temoignagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: temoignagesWhereInput
    orderBy?: temoignagesOrderByWithAggregationInput | temoignagesOrderByWithAggregationInput[]
    by: TemoignagesScalarFieldEnum[] | TemoignagesScalarFieldEnum
    having?: temoignagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemoignagesCountAggregateInputType | true
    _avg?: TemoignagesAvgAggregateInputType
    _sum?: TemoignagesSumAggregateInputType
    _min?: TemoignagesMinAggregateInputType
    _max?: TemoignagesMaxAggregateInputType
  }

  export type TemoignagesGroupByOutputType = {
    id_tem: number
    contenu: string
    client: string
    plateforme: string
    date: string | null
    afficher: boolean
    _count: TemoignagesCountAggregateOutputType | null
    _avg: TemoignagesAvgAggregateOutputType | null
    _sum: TemoignagesSumAggregateOutputType | null
    _min: TemoignagesMinAggregateOutputType | null
    _max: TemoignagesMaxAggregateOutputType | null
  }

  type GetTemoignagesGroupByPayload<T extends temoignagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemoignagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemoignagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemoignagesGroupByOutputType[P]>
            : GetScalarType<T[P], TemoignagesGroupByOutputType[P]>
        }
      >
    >


  export type temoignagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tem?: boolean
    contenu?: boolean
    client?: boolean
    plateforme?: boolean
    date?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["temoignages"]>



  export type temoignagesSelectScalar = {
    id_tem?: boolean
    contenu?: boolean
    client?: boolean
    plateforme?: boolean
    date?: boolean
    afficher?: boolean
  }

  export type temoignagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tem" | "contenu" | "client" | "plateforme" | "date" | "afficher", ExtArgs["result"]["temoignages"]>

  export type $temoignagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "temoignages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_tem: number
      contenu: string
      client: string
      plateforme: string
      date: string | null
      afficher: boolean
    }, ExtArgs["result"]["temoignages"]>
    composites: {}
  }

  type temoignagesGetPayload<S extends boolean | null | undefined | temoignagesDefaultArgs> = $Result.GetResult<Prisma.$temoignagesPayload, S>

  type temoignagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<temoignagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemoignagesCountAggregateInputType | true
    }

  export interface temoignagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['temoignages'], meta: { name: 'temoignages' } }
    /**
     * Find zero or one Temoignages that matches the filter.
     * @param {temoignagesFindUniqueArgs} args - Arguments to find a Temoignages
     * @example
     * // Get one Temoignages
     * const temoignages = await prisma.temoignages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends temoignagesFindUniqueArgs>(args: SelectSubset<T, temoignagesFindUniqueArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Temoignages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {temoignagesFindUniqueOrThrowArgs} args - Arguments to find a Temoignages
     * @example
     * // Get one Temoignages
     * const temoignages = await prisma.temoignages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends temoignagesFindUniqueOrThrowArgs>(args: SelectSubset<T, temoignagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Temoignages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temoignagesFindFirstArgs} args - Arguments to find a Temoignages
     * @example
     * // Get one Temoignages
     * const temoignages = await prisma.temoignages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends temoignagesFindFirstArgs>(args?: SelectSubset<T, temoignagesFindFirstArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Temoignages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temoignagesFindFirstOrThrowArgs} args - Arguments to find a Temoignages
     * @example
     * // Get one Temoignages
     * const temoignages = await prisma.temoignages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends temoignagesFindFirstOrThrowArgs>(args?: SelectSubset<T, temoignagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Temoignages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temoignagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temoignages
     * const temoignages = await prisma.temoignages.findMany()
     * 
     * // Get first 10 Temoignages
     * const temoignages = await prisma.temoignages.findMany({ take: 10 })
     * 
     * // Only select the `id_tem`
     * const temoignagesWithId_temOnly = await prisma.temoignages.findMany({ select: { id_tem: true } })
     * 
     */
    findMany<T extends temoignagesFindManyArgs>(args?: SelectSubset<T, temoignagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Temoignages.
     * @param {temoignagesCreateArgs} args - Arguments to create a Temoignages.
     * @example
     * // Create one Temoignages
     * const Temoignages = await prisma.temoignages.create({
     *   data: {
     *     // ... data to create a Temoignages
     *   }
     * })
     * 
     */
    create<T extends temoignagesCreateArgs>(args: SelectSubset<T, temoignagesCreateArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Temoignages.
     * @param {temoignagesCreateManyArgs} args - Arguments to create many Temoignages.
     * @example
     * // Create many Temoignages
     * const temoignages = await prisma.temoignages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends temoignagesCreateManyArgs>(args?: SelectSubset<T, temoignagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Temoignages.
     * @param {temoignagesDeleteArgs} args - Arguments to delete one Temoignages.
     * @example
     * // Delete one Temoignages
     * const Temoignages = await prisma.temoignages.delete({
     *   where: {
     *     // ... filter to delete one Temoignages
     *   }
     * })
     * 
     */
    delete<T extends temoignagesDeleteArgs>(args: SelectSubset<T, temoignagesDeleteArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Temoignages.
     * @param {temoignagesUpdateArgs} args - Arguments to update one Temoignages.
     * @example
     * // Update one Temoignages
     * const temoignages = await prisma.temoignages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends temoignagesUpdateArgs>(args: SelectSubset<T, temoignagesUpdateArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Temoignages.
     * @param {temoignagesDeleteManyArgs} args - Arguments to filter Temoignages to delete.
     * @example
     * // Delete a few Temoignages
     * const { count } = await prisma.temoignages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends temoignagesDeleteManyArgs>(args?: SelectSubset<T, temoignagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temoignages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temoignagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temoignages
     * const temoignages = await prisma.temoignages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends temoignagesUpdateManyArgs>(args: SelectSubset<T, temoignagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Temoignages.
     * @param {temoignagesUpsertArgs} args - Arguments to update or create a Temoignages.
     * @example
     * // Update or create a Temoignages
     * const temoignages = await prisma.temoignages.upsert({
     *   create: {
     *     // ... data to create a Temoignages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temoignages we want to update
     *   }
     * })
     */
    upsert<T extends temoignagesUpsertArgs>(args: SelectSubset<T, temoignagesUpsertArgs<ExtArgs>>): Prisma__temoignagesClient<$Result.GetResult<Prisma.$temoignagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Temoignages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temoignagesCountArgs} args - Arguments to filter Temoignages to count.
     * @example
     * // Count the number of Temoignages
     * const count = await prisma.temoignages.count({
     *   where: {
     *     // ... the filter for the Temoignages we want to count
     *   }
     * })
    **/
    count<T extends temoignagesCountArgs>(
      args?: Subset<T, temoignagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemoignagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temoignages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemoignagesAggregateArgs>(args: Subset<T, TemoignagesAggregateArgs>): Prisma.PrismaPromise<GetTemoignagesAggregateType<T>>

    /**
     * Group by Temoignages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temoignagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends temoignagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: temoignagesGroupByArgs['orderBy'] }
        : { orderBy?: temoignagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, temoignagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemoignagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the temoignages model
   */
  readonly fields: temoignagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for temoignages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__temoignagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the temoignages model
   */
  interface temoignagesFieldRefs {
    readonly id_tem: FieldRef<"temoignages", 'Int'>
    readonly contenu: FieldRef<"temoignages", 'String'>
    readonly client: FieldRef<"temoignages", 'String'>
    readonly plateforme: FieldRef<"temoignages", 'String'>
    readonly date: FieldRef<"temoignages", 'String'>
    readonly afficher: FieldRef<"temoignages", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * temoignages findUnique
   */
  export type temoignagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * Filter, which temoignages to fetch.
     */
    where: temoignagesWhereUniqueInput
  }

  /**
   * temoignages findUniqueOrThrow
   */
  export type temoignagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * Filter, which temoignages to fetch.
     */
    where: temoignagesWhereUniqueInput
  }

  /**
   * temoignages findFirst
   */
  export type temoignagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * Filter, which temoignages to fetch.
     */
    where?: temoignagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temoignages to fetch.
     */
    orderBy?: temoignagesOrderByWithRelationInput | temoignagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for temoignages.
     */
    cursor?: temoignagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temoignages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of temoignages.
     */
    distinct?: TemoignagesScalarFieldEnum | TemoignagesScalarFieldEnum[]
  }

  /**
   * temoignages findFirstOrThrow
   */
  export type temoignagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * Filter, which temoignages to fetch.
     */
    where?: temoignagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temoignages to fetch.
     */
    orderBy?: temoignagesOrderByWithRelationInput | temoignagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for temoignages.
     */
    cursor?: temoignagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temoignages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of temoignages.
     */
    distinct?: TemoignagesScalarFieldEnum | TemoignagesScalarFieldEnum[]
  }

  /**
   * temoignages findMany
   */
  export type temoignagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * Filter, which temoignages to fetch.
     */
    where?: temoignagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temoignages to fetch.
     */
    orderBy?: temoignagesOrderByWithRelationInput | temoignagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing temoignages.
     */
    cursor?: temoignagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temoignages.
     */
    skip?: number
    distinct?: TemoignagesScalarFieldEnum | TemoignagesScalarFieldEnum[]
  }

  /**
   * temoignages create
   */
  export type temoignagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * The data needed to create a temoignages.
     */
    data: XOR<temoignagesCreateInput, temoignagesUncheckedCreateInput>
  }

  /**
   * temoignages createMany
   */
  export type temoignagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many temoignages.
     */
    data: temoignagesCreateManyInput | temoignagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * temoignages update
   */
  export type temoignagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * The data needed to update a temoignages.
     */
    data: XOR<temoignagesUpdateInput, temoignagesUncheckedUpdateInput>
    /**
     * Choose, which temoignages to update.
     */
    where: temoignagesWhereUniqueInput
  }

  /**
   * temoignages updateMany
   */
  export type temoignagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update temoignages.
     */
    data: XOR<temoignagesUpdateManyMutationInput, temoignagesUncheckedUpdateManyInput>
    /**
     * Filter which temoignages to update
     */
    where?: temoignagesWhereInput
    /**
     * Limit how many temoignages to update.
     */
    limit?: number
  }

  /**
   * temoignages upsert
   */
  export type temoignagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * The filter to search for the temoignages to update in case it exists.
     */
    where: temoignagesWhereUniqueInput
    /**
     * In case the temoignages found by the `where` argument doesn't exist, create a new temoignages with this data.
     */
    create: XOR<temoignagesCreateInput, temoignagesUncheckedCreateInput>
    /**
     * In case the temoignages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<temoignagesUpdateInput, temoignagesUncheckedUpdateInput>
  }

  /**
   * temoignages delete
   */
  export type temoignagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
    /**
     * Filter which temoignages to delete.
     */
    where: temoignagesWhereUniqueInput
  }

  /**
   * temoignages deleteMany
   */
  export type temoignagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which temoignages to delete
     */
    where?: temoignagesWhereInput
    /**
     * Limit how many temoignages to delete.
     */
    limit?: number
  }

  /**
   * temoignages without action
   */
  export type temoignagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temoignages
     */
    select?: temoignagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temoignages
     */
    omit?: temoignagesOmit<ExtArgs> | null
  }


  /**
   * Model utilisateurs
   */

  export type AggregateUtilisateurs = {
    _count: UtilisateursCountAggregateOutputType | null
    _avg: UtilisateursAvgAggregateOutputType | null
    _sum: UtilisateursSumAggregateOutputType | null
    _min: UtilisateursMinAggregateOutputType | null
    _max: UtilisateursMaxAggregateOutputType | null
  }

  export type UtilisateursAvgAggregateOutputType = {
    id_user: number | null
  }

  export type UtilisateursSumAggregateOutputType = {
    id_user: number | null
  }

  export type UtilisateursMinAggregateOutputType = {
    id_user: number | null
    img: string | null
    email: string | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type UtilisateursMaxAggregateOutputType = {
    id_user: number | null
    img: string | null
    email: string | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type UtilisateursCountAggregateOutputType = {
    id_user: number
    img: number
    email: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type UtilisateursAvgAggregateInputType = {
    id_user?: true
  }

  export type UtilisateursSumAggregateInputType = {
    id_user?: true
  }

  export type UtilisateursMinAggregateInputType = {
    id_user?: true
    img?: true
    email?: true
    username?: true
    password?: true
    role?: true
  }

  export type UtilisateursMaxAggregateInputType = {
    id_user?: true
    img?: true
    email?: true
    username?: true
    password?: true
    role?: true
  }

  export type UtilisateursCountAggregateInputType = {
    id_user?: true
    img?: true
    email?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UtilisateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilisateurs to aggregate.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned utilisateurs
    **/
    _count?: true | UtilisateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilisateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilisateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateursMaxAggregateInputType
  }

  export type GetUtilisateursAggregateType<T extends UtilisateursAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateurs[P]>
      : GetScalarType<T[P], AggregateUtilisateurs[P]>
  }




  export type utilisateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: utilisateursWhereInput
    orderBy?: utilisateursOrderByWithAggregationInput | utilisateursOrderByWithAggregationInput[]
    by: UtilisateursScalarFieldEnum[] | UtilisateursScalarFieldEnum
    having?: utilisateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateursCountAggregateInputType | true
    _avg?: UtilisateursAvgAggregateInputType
    _sum?: UtilisateursSumAggregateInputType
    _min?: UtilisateursMinAggregateInputType
    _max?: UtilisateursMaxAggregateInputType
  }

  export type UtilisateursGroupByOutputType = {
    id_user: number
    img: string
    email: string | null
    username: string
    password: string
    role: string
    _count: UtilisateursCountAggregateOutputType | null
    _avg: UtilisateursAvgAggregateOutputType | null
    _sum: UtilisateursSumAggregateOutputType | null
    _min: UtilisateursMinAggregateOutputType | null
    _max: UtilisateursMaxAggregateOutputType | null
  }

  type GetUtilisateursGroupByPayload<T extends utilisateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateursGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateursGroupByOutputType[P]>
        }
      >
    >


  export type utilisateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
    img?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["utilisateurs"]>



  export type utilisateursSelectScalar = {
    id_user?: boolean
    img?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }

  export type utilisateursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_user" | "img" | "email" | "username" | "password" | "role", ExtArgs["result"]["utilisateurs"]>

  export type $utilisateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "utilisateurs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_user: number
      img: string
      email: string | null
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["utilisateurs"]>
    composites: {}
  }

  type utilisateursGetPayload<S extends boolean | null | undefined | utilisateursDefaultArgs> = $Result.GetResult<Prisma.$utilisateursPayload, S>

  type utilisateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<utilisateursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtilisateursCountAggregateInputType | true
    }

  export interface utilisateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['utilisateurs'], meta: { name: 'utilisateurs' } }
    /**
     * Find zero or one Utilisateurs that matches the filter.
     * @param {utilisateursFindUniqueArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends utilisateursFindUniqueArgs>(args: SelectSubset<T, utilisateursFindUniqueArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Utilisateurs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {utilisateursFindUniqueOrThrowArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends utilisateursFindUniqueOrThrowArgs>(args: SelectSubset<T, utilisateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindFirstArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends utilisateursFindFirstArgs>(args?: SelectSubset<T, utilisateursFindFirstArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindFirstOrThrowArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends utilisateursFindFirstOrThrowArgs>(args?: SelectSubset<T, utilisateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const utilisateursWithId_userOnly = await prisma.utilisateurs.findMany({ select: { id_user: true } })
     * 
     */
    findMany<T extends utilisateursFindManyArgs>(args?: SelectSubset<T, utilisateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Utilisateurs.
     * @param {utilisateursCreateArgs} args - Arguments to create a Utilisateurs.
     * @example
     * // Create one Utilisateurs
     * const Utilisateurs = await prisma.utilisateurs.create({
     *   data: {
     *     // ... data to create a Utilisateurs
     *   }
     * })
     * 
     */
    create<T extends utilisateursCreateArgs>(args: SelectSubset<T, utilisateursCreateArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Utilisateurs.
     * @param {utilisateursCreateManyArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends utilisateursCreateManyArgs>(args?: SelectSubset<T, utilisateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utilisateurs.
     * @param {utilisateursDeleteArgs} args - Arguments to delete one Utilisateurs.
     * @example
     * // Delete one Utilisateurs
     * const Utilisateurs = await prisma.utilisateurs.delete({
     *   where: {
     *     // ... filter to delete one Utilisateurs
     *   }
     * })
     * 
     */
    delete<T extends utilisateursDeleteArgs>(args: SelectSubset<T, utilisateursDeleteArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Utilisateurs.
     * @param {utilisateursUpdateArgs} args - Arguments to update one Utilisateurs.
     * @example
     * // Update one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends utilisateursUpdateArgs>(args: SelectSubset<T, utilisateursUpdateArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Utilisateurs.
     * @param {utilisateursDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends utilisateursDeleteManyArgs>(args?: SelectSubset<T, utilisateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends utilisateursUpdateManyArgs>(args: SelectSubset<T, utilisateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utilisateurs.
     * @param {utilisateursUpsertArgs} args - Arguments to update or create a Utilisateurs.
     * @example
     * // Update or create a Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.upsert({
     *   create: {
     *     // ... data to create a Utilisateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateurs we want to update
     *   }
     * })
     */
    upsert<T extends utilisateursUpsertArgs>(args: SelectSubset<T, utilisateursUpsertArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateurs.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends utilisateursCountArgs>(
      args?: Subset<T, utilisateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateursAggregateArgs>(args: Subset<T, UtilisateursAggregateArgs>): Prisma.PrismaPromise<GetUtilisateursAggregateType<T>>

    /**
     * Group by Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends utilisateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: utilisateursGroupByArgs['orderBy'] }
        : { orderBy?: utilisateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, utilisateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the utilisateurs model
   */
  readonly fields: utilisateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for utilisateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__utilisateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the utilisateurs model
   */
  interface utilisateursFieldRefs {
    readonly id_user: FieldRef<"utilisateurs", 'Int'>
    readonly img: FieldRef<"utilisateurs", 'String'>
    readonly email: FieldRef<"utilisateurs", 'String'>
    readonly username: FieldRef<"utilisateurs", 'String'>
    readonly password: FieldRef<"utilisateurs", 'String'>
    readonly role: FieldRef<"utilisateurs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * utilisateurs findUnique
   */
  export type utilisateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs findUniqueOrThrow
   */
  export type utilisateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs findFirst
   */
  export type utilisateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilisateurs.
     */
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs findFirstOrThrow
   */
  export type utilisateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilisateurs.
     */
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs findMany
   */
  export type utilisateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs create
   */
  export type utilisateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * The data needed to create a utilisateurs.
     */
    data: XOR<utilisateursCreateInput, utilisateursUncheckedCreateInput>
  }

  /**
   * utilisateurs createMany
   */
  export type utilisateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many utilisateurs.
     */
    data: utilisateursCreateManyInput | utilisateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * utilisateurs update
   */
  export type utilisateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * The data needed to update a utilisateurs.
     */
    data: XOR<utilisateursUpdateInput, utilisateursUncheckedUpdateInput>
    /**
     * Choose, which utilisateurs to update.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs updateMany
   */
  export type utilisateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update utilisateurs.
     */
    data: XOR<utilisateursUpdateManyMutationInput, utilisateursUncheckedUpdateManyInput>
    /**
     * Filter which utilisateurs to update
     */
    where?: utilisateursWhereInput
    /**
     * Limit how many utilisateurs to update.
     */
    limit?: number
  }

  /**
   * utilisateurs upsert
   */
  export type utilisateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * The filter to search for the utilisateurs to update in case it exists.
     */
    where: utilisateursWhereUniqueInput
    /**
     * In case the utilisateurs found by the `where` argument doesn't exist, create a new utilisateurs with this data.
     */
    create: XOR<utilisateursCreateInput, utilisateursUncheckedCreateInput>
    /**
     * In case the utilisateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<utilisateursUpdateInput, utilisateursUncheckedUpdateInput>
  }

  /**
   * utilisateurs delete
   */
  export type utilisateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter which utilisateurs to delete.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs deleteMany
   */
  export type utilisateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilisateurs to delete
     */
    where?: utilisateursWhereInput
    /**
     * Limit how many utilisateurs to delete.
     */
    limit?: number
  }

  /**
   * utilisateurs without action
   */
  export type utilisateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
  }


  /**
   * Model videos
   */

  export type AggregateVideos = {
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  export type VideosAvgAggregateOutputType = {
    id_vid: number | null
  }

  export type VideosSumAggregateOutputType = {
    id_vid: number | null
  }

  export type VideosMinAggregateOutputType = {
    id_vid: number | null
    titre: string | null
    description: string | null
    tags: string | null
    lien: string | null
    date: Date | null
    media_webm: string | null
    media_mp4: string | null
    duree: string | null
    afficher_competences: string | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type VideosMaxAggregateOutputType = {
    id_vid: number | null
    titre: string | null
    description: string | null
    tags: string | null
    lien: string | null
    date: Date | null
    media_webm: string | null
    media_mp4: string | null
    duree: string | null
    afficher_competences: string | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type VideosCountAggregateOutputType = {
    id_vid: number
    titre: number
    description: number
    tags: number
    lien: number
    date: number
    media_webm: number
    media_mp4: number
    duree: number
    afficher_competences: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type VideosAvgAggregateInputType = {
    id_vid?: true
  }

  export type VideosSumAggregateInputType = {
    id_vid?: true
  }

  export type VideosMinAggregateInputType = {
    id_vid?: true
    titre?: true
    description?: true
    tags?: true
    lien?: true
    date?: true
    media_webm?: true
    media_mp4?: true
    duree?: true
    afficher_competences?: true
    afficher?: true
    derniere_modification?: true
  }

  export type VideosMaxAggregateInputType = {
    id_vid?: true
    titre?: true
    description?: true
    tags?: true
    lien?: true
    date?: true
    media_webm?: true
    media_mp4?: true
    duree?: true
    afficher_competences?: true
    afficher?: true
    derniere_modification?: true
  }

  export type VideosCountAggregateInputType = {
    id_vid?: true
    titre?: true
    description?: true
    tags?: true
    lien?: true
    date?: true
    media_webm?: true
    media_mp4?: true
    duree?: true
    afficher_competences?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type VideosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to aggregate.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos
    **/
    _count?: true | VideosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideosMaxAggregateInputType
  }

  export type GetVideosAggregateType<T extends VideosAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos[P]>
      : GetScalarType<T[P], AggregateVideos[P]>
  }




  export type videosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
    orderBy?: videosOrderByWithAggregationInput | videosOrderByWithAggregationInput[]
    by: VideosScalarFieldEnum[] | VideosScalarFieldEnum
    having?: videosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideosCountAggregateInputType | true
    _avg?: VideosAvgAggregateInputType
    _sum?: VideosSumAggregateInputType
    _min?: VideosMinAggregateInputType
    _max?: VideosMaxAggregateInputType
  }

  export type VideosGroupByOutputType = {
    id_vid: number
    titre: string
    description: string
    tags: string
    lien: string
    date: Date
    media_webm: string
    media_mp4: string
    duree: string
    afficher_competences: string
    afficher: boolean
    derniere_modification: Date
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  type GetVideosGroupByPayload<T extends videosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideosGroupByOutputType[P]>
            : GetScalarType<T[P], VideosGroupByOutputType[P]>
        }
      >
    >


  export type videosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_vid?: boolean
    titre?: boolean
    description?: boolean
    tags?: boolean
    lien?: boolean
    date?: boolean
    media_webm?: boolean
    media_mp4?: boolean
    duree?: boolean
    afficher_competences?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    videos_tags_link?: boolean | videos$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | VideosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos"]>



  export type videosSelectScalar = {
    id_vid?: boolean
    titre?: boolean
    description?: boolean
    tags?: boolean
    lien?: boolean
    date?: boolean
    media_webm?: boolean
    media_mp4?: boolean
    duree?: boolean
    afficher_competences?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type videosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_vid" | "titre" | "description" | "tags" | "lien" | "date" | "media_webm" | "media_mp4" | "duree" | "afficher_competences" | "afficher" | "derniere_modification", ExtArgs["result"]["videos"]>
  export type videosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | videos$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | VideosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $videosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos"
    objects: {
      videos_tags_link: Prisma.$videos_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_vid: number
      titre: string
      description: string
      tags: string
      lien: string
      date: Date
      media_webm: string
      media_mp4: string
      duree: string
      afficher_competences: string
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["videos"]>
    composites: {}
  }

  type videosGetPayload<S extends boolean | null | undefined | videosDefaultArgs> = $Result.GetResult<Prisma.$videosPayload, S>

  type videosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideosCountAggregateInputType | true
    }

  export interface videosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos'], meta: { name: 'videos' } }
    /**
     * Find zero or one Videos that matches the filter.
     * @param {videosFindUniqueArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videosFindUniqueArgs>(args: SelectSubset<T, videosFindUniqueArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videosFindUniqueOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videosFindUniqueOrThrowArgs>(args: SelectSubset<T, videosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videosFindFirstArgs>(args?: SelectSubset<T, videosFindFirstArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videosFindFirstOrThrowArgs>(args?: SelectSubset<T, videosFindFirstOrThrowArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.videos.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.videos.findMany({ take: 10 })
     * 
     * // Only select the `id_vid`
     * const videosWithId_vidOnly = await prisma.videos.findMany({ select: { id_vid: true } })
     * 
     */
    findMany<T extends videosFindManyArgs>(args?: SelectSubset<T, videosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos.
     * @param {videosCreateArgs} args - Arguments to create a Videos.
     * @example
     * // Create one Videos
     * const Videos = await prisma.videos.create({
     *   data: {
     *     // ... data to create a Videos
     *   }
     * })
     * 
     */
    create<T extends videosCreateArgs>(args: SelectSubset<T, videosCreateArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {videosCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const videos = await prisma.videos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videosCreateManyArgs>(args?: SelectSubset<T, videosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos.
     * @param {videosDeleteArgs} args - Arguments to delete one Videos.
     * @example
     * // Delete one Videos
     * const Videos = await prisma.videos.delete({
     *   where: {
     *     // ... filter to delete one Videos
     *   }
     * })
     * 
     */
    delete<T extends videosDeleteArgs>(args: SelectSubset<T, videosDeleteArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos.
     * @param {videosUpdateArgs} args - Arguments to update one Videos.
     * @example
     * // Update one Videos
     * const videos = await prisma.videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videosUpdateArgs>(args: SelectSubset<T, videosUpdateArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {videosDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videosDeleteManyArgs>(args?: SelectSubset<T, videosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const videos = await prisma.videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videosUpdateManyArgs>(args: SelectSubset<T, videosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos.
     * @param {videosUpsertArgs} args - Arguments to update or create a Videos.
     * @example
     * // Update or create a Videos
     * const videos = await prisma.videos.upsert({
     *   create: {
     *     // ... data to create a Videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos we want to update
     *   }
     * })
     */
    upsert<T extends videosUpsertArgs>(args: SelectSubset<T, videosUpsertArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.videos.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends videosCountArgs>(
      args?: Subset<T, videosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideosAggregateArgs>(args: Subset<T, VideosAggregateArgs>): Prisma.PrismaPromise<GetVideosAggregateType<T>>

    /**
     * Group by Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videosGroupByArgs['orderBy'] }
        : { orderBy?: videosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos model
   */
  readonly fields: videosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos_tags_link<T extends videos$videos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, videos$videos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos model
   */
  interface videosFieldRefs {
    readonly id_vid: FieldRef<"videos", 'Int'>
    readonly titre: FieldRef<"videos", 'String'>
    readonly description: FieldRef<"videos", 'String'>
    readonly tags: FieldRef<"videos", 'String'>
    readonly lien: FieldRef<"videos", 'String'>
    readonly date: FieldRef<"videos", 'DateTime'>
    readonly media_webm: FieldRef<"videos", 'String'>
    readonly media_mp4: FieldRef<"videos", 'String'>
    readonly duree: FieldRef<"videos", 'String'>
    readonly afficher_competences: FieldRef<"videos", 'String'>
    readonly afficher: FieldRef<"videos", 'Boolean'>
    readonly derniere_modification: FieldRef<"videos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * videos findUnique
   */
  export type videosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos findUniqueOrThrow
   */
  export type videosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos findFirst
   */
  export type videosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos findFirstOrThrow
   */
  export type videosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos findMany
   */
  export type videosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos create
   */
  export type videosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The data needed to create a videos.
     */
    data: XOR<videosCreateInput, videosUncheckedCreateInput>
  }

  /**
   * videos createMany
   */
  export type videosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos.
     */
    data: videosCreateManyInput | videosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos update
   */
  export type videosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The data needed to update a videos.
     */
    data: XOR<videosUpdateInput, videosUncheckedUpdateInput>
    /**
     * Choose, which videos to update.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos updateMany
   */
  export type videosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos.
     */
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyInput>
    /**
     * Filter which videos to update
     */
    where?: videosWhereInput
    /**
     * Limit how many videos to update.
     */
    limit?: number
  }

  /**
   * videos upsert
   */
  export type videosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The filter to search for the videos to update in case it exists.
     */
    where: videosWhereUniqueInput
    /**
     * In case the videos found by the `where` argument doesn't exist, create a new videos with this data.
     */
    create: XOR<videosCreateInput, videosUncheckedCreateInput>
    /**
     * In case the videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videosUpdateInput, videosUncheckedUpdateInput>
  }

  /**
   * videos delete
   */
  export type videosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter which videos to delete.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos deleteMany
   */
  export type videosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to delete
     */
    where?: videosWhereInput
    /**
     * Limit how many videos to delete.
     */
    limit?: number
  }

  /**
   * videos.videos_tags_link
   */
  export type videos$videos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    where?: videos_tags_linkWhereInput
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    cursor?: videos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos without action
   */
  export type videosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
  }


  /**
   * Model videos_tags
   */

  export type AggregateVideos_tags = {
    _count: Videos_tagsCountAggregateOutputType | null
    _avg: Videos_tagsAvgAggregateOutputType | null
    _sum: Videos_tagsSumAggregateOutputType | null
    _min: Videos_tagsMinAggregateOutputType | null
    _max: Videos_tagsMaxAggregateOutputType | null
  }

  export type Videos_tagsAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Videos_tagsSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Videos_tagsMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Videos_tagsMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Videos_tagsCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Videos_tagsAvgAggregateInputType = {
    id_tags?: true
  }

  export type Videos_tagsSumAggregateInputType = {
    id_tags?: true
  }

  export type Videos_tagsMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Videos_tagsMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Videos_tagsCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Videos_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags to aggregate.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos_tags
    **/
    _count?: true | Videos_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Videos_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Videos_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Videos_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Videos_tagsMaxAggregateInputType
  }

  export type GetVideos_tagsAggregateType<T extends Videos_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos_tags[P]>
      : GetScalarType<T[P], AggregateVideos_tags[P]>
  }




  export type videos_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tagsWhereInput
    orderBy?: videos_tagsOrderByWithAggregationInput | videos_tagsOrderByWithAggregationInput[]
    by: Videos_tagsScalarFieldEnum[] | Videos_tagsScalarFieldEnum
    having?: videos_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Videos_tagsCountAggregateInputType | true
    _avg?: Videos_tagsAvgAggregateInputType
    _sum?: Videos_tagsSumAggregateInputType
    _min?: Videos_tagsMinAggregateInputType
    _max?: Videos_tagsMaxAggregateInputType
  }

  export type Videos_tagsGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Videos_tagsCountAggregateOutputType | null
    _avg: Videos_tagsAvgAggregateOutputType | null
    _sum: Videos_tagsSumAggregateOutputType | null
    _min: Videos_tagsMinAggregateOutputType | null
    _max: Videos_tagsMaxAggregateOutputType | null
  }

  type GetVideos_tagsGroupByPayload<T extends videos_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Videos_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Videos_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Videos_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Videos_tagsGroupByOutputType[P]>
        }
      >
    >


  export type videos_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    videos_tags_link?: boolean | videos_tags$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | Videos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos_tags"]>



  export type videos_tagsSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type videos_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["videos_tags"]>
  export type videos_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | videos_tags$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | Videos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $videos_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos_tags"
    objects: {
      videos_tags_link: Prisma.$videos_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["videos_tags"]>
    composites: {}
  }

  type videos_tagsGetPayload<S extends boolean | null | undefined | videos_tagsDefaultArgs> = $Result.GetResult<Prisma.$videos_tagsPayload, S>

  type videos_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videos_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Videos_tagsCountAggregateInputType | true
    }

  export interface videos_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos_tags'], meta: { name: 'videos_tags' } }
    /**
     * Find zero or one Videos_tags that matches the filter.
     * @param {videos_tagsFindUniqueArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videos_tagsFindUniqueArgs>(args: SelectSubset<T, videos_tagsFindUniqueArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videos_tagsFindUniqueOrThrowArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videos_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, videos_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsFindFirstArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videos_tagsFindFirstArgs>(args?: SelectSubset<T, videos_tagsFindFirstArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsFindFirstOrThrowArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videos_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, videos_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos_tags
     * const videos_tags = await prisma.videos_tags.findMany()
     * 
     * // Get first 10 Videos_tags
     * const videos_tags = await prisma.videos_tags.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const videos_tagsWithId_tagsOnly = await prisma.videos_tags.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends videos_tagsFindManyArgs>(args?: SelectSubset<T, videos_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos_tags.
     * @param {videos_tagsCreateArgs} args - Arguments to create a Videos_tags.
     * @example
     * // Create one Videos_tags
     * const Videos_tags = await prisma.videos_tags.create({
     *   data: {
     *     // ... data to create a Videos_tags
     *   }
     * })
     * 
     */
    create<T extends videos_tagsCreateArgs>(args: SelectSubset<T, videos_tagsCreateArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos_tags.
     * @param {videos_tagsCreateManyArgs} args - Arguments to create many Videos_tags.
     * @example
     * // Create many Videos_tags
     * const videos_tags = await prisma.videos_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videos_tagsCreateManyArgs>(args?: SelectSubset<T, videos_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos_tags.
     * @param {videos_tagsDeleteArgs} args - Arguments to delete one Videos_tags.
     * @example
     * // Delete one Videos_tags
     * const Videos_tags = await prisma.videos_tags.delete({
     *   where: {
     *     // ... filter to delete one Videos_tags
     *   }
     * })
     * 
     */
    delete<T extends videos_tagsDeleteArgs>(args: SelectSubset<T, videos_tagsDeleteArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos_tags.
     * @param {videos_tagsUpdateArgs} args - Arguments to update one Videos_tags.
     * @example
     * // Update one Videos_tags
     * const videos_tags = await prisma.videos_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videos_tagsUpdateArgs>(args: SelectSubset<T, videos_tagsUpdateArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos_tags.
     * @param {videos_tagsDeleteManyArgs} args - Arguments to filter Videos_tags to delete.
     * @example
     * // Delete a few Videos_tags
     * const { count } = await prisma.videos_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videos_tagsDeleteManyArgs>(args?: SelectSubset<T, videos_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos_tags
     * const videos_tags = await prisma.videos_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videos_tagsUpdateManyArgs>(args: SelectSubset<T, videos_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos_tags.
     * @param {videos_tagsUpsertArgs} args - Arguments to update or create a Videos_tags.
     * @example
     * // Update or create a Videos_tags
     * const videos_tags = await prisma.videos_tags.upsert({
     *   create: {
     *     // ... data to create a Videos_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos_tags we want to update
     *   }
     * })
     */
    upsert<T extends videos_tagsUpsertArgs>(args: SelectSubset<T, videos_tagsUpsertArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsCountArgs} args - Arguments to filter Videos_tags to count.
     * @example
     * // Count the number of Videos_tags
     * const count = await prisma.videos_tags.count({
     *   where: {
     *     // ... the filter for the Videos_tags we want to count
     *   }
     * })
    **/
    count<T extends videos_tagsCountArgs>(
      args?: Subset<T, videos_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Videos_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Videos_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Videos_tagsAggregateArgs>(args: Subset<T, Videos_tagsAggregateArgs>): Prisma.PrismaPromise<GetVideos_tagsAggregateType<T>>

    /**
     * Group by Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videos_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videos_tagsGroupByArgs['orderBy'] }
        : { orderBy?: videos_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videos_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideos_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos_tags model
   */
  readonly fields: videos_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videos_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos_tags_link<T extends videos_tags$videos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, videos_tags$videos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos_tags model
   */
  interface videos_tagsFieldRefs {
    readonly id_tags: FieldRef<"videos_tags", 'Int'>
    readonly titre: FieldRef<"videos_tags", 'String'>
    readonly important: FieldRef<"videos_tags", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * videos_tags findUnique
   */
  export type videos_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags findUniqueOrThrow
   */
  export type videos_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags findFirst
   */
  export type videos_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags.
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags.
     */
    distinct?: Videos_tagsScalarFieldEnum | Videos_tagsScalarFieldEnum[]
  }

  /**
   * videos_tags findFirstOrThrow
   */
  export type videos_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags.
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags.
     */
    distinct?: Videos_tagsScalarFieldEnum | Videos_tagsScalarFieldEnum[]
  }

  /**
   * videos_tags findMany
   */
  export type videos_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos_tags.
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    distinct?: Videos_tagsScalarFieldEnum | Videos_tagsScalarFieldEnum[]
  }

  /**
   * videos_tags create
   */
  export type videos_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a videos_tags.
     */
    data: XOR<videos_tagsCreateInput, videos_tagsUncheckedCreateInput>
  }

  /**
   * videos_tags createMany
   */
  export type videos_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos_tags.
     */
    data: videos_tagsCreateManyInput | videos_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos_tags update
   */
  export type videos_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a videos_tags.
     */
    data: XOR<videos_tagsUpdateInput, videos_tagsUncheckedUpdateInput>
    /**
     * Choose, which videos_tags to update.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags updateMany
   */
  export type videos_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos_tags.
     */
    data: XOR<videos_tagsUpdateManyMutationInput, videos_tagsUncheckedUpdateManyInput>
    /**
     * Filter which videos_tags to update
     */
    where?: videos_tagsWhereInput
    /**
     * Limit how many videos_tags to update.
     */
    limit?: number
  }

  /**
   * videos_tags upsert
   */
  export type videos_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the videos_tags to update in case it exists.
     */
    where: videos_tagsWhereUniqueInput
    /**
     * In case the videos_tags found by the `where` argument doesn't exist, create a new videos_tags with this data.
     */
    create: XOR<videos_tagsCreateInput, videos_tagsUncheckedCreateInput>
    /**
     * In case the videos_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videos_tagsUpdateInput, videos_tagsUncheckedUpdateInput>
  }

  /**
   * videos_tags delete
   */
  export type videos_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter which videos_tags to delete.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags deleteMany
   */
  export type videos_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags to delete
     */
    where?: videos_tagsWhereInput
    /**
     * Limit how many videos_tags to delete.
     */
    limit?: number
  }

  /**
   * videos_tags.videos_tags_link
   */
  export type videos_tags$videos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    where?: videos_tags_linkWhereInput
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    cursor?: videos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags without action
   */
  export type videos_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
  }


  /**
   * Model videos_tags_link
   */

  export type AggregateVideos_tags_link = {
    _count: Videos_tags_linkCountAggregateOutputType | null
    _avg: Videos_tags_linkAvgAggregateOutputType | null
    _sum: Videos_tags_linkSumAggregateOutputType | null
    _min: Videos_tags_linkMinAggregateOutputType | null
    _max: Videos_tags_linkMaxAggregateOutputType | null
  }

  export type Videos_tags_linkAvgAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkSumAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkMinAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkMaxAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkCountAggregateOutputType = {
    id_vid: number
    id_tags: number
    _all: number
  }


  export type Videos_tags_linkAvgAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkSumAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkMinAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkMaxAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkCountAggregateInputType = {
    id_vid?: true
    id_tags?: true
    _all?: true
  }

  export type Videos_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags_link to aggregate.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos_tags_links
    **/
    _count?: true | Videos_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Videos_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Videos_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Videos_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Videos_tags_linkMaxAggregateInputType
  }

  export type GetVideos_tags_linkAggregateType<T extends Videos_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos_tags_link[P]>
      : GetScalarType<T[P], AggregateVideos_tags_link[P]>
  }




  export type videos_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tags_linkWhereInput
    orderBy?: videos_tags_linkOrderByWithAggregationInput | videos_tags_linkOrderByWithAggregationInput[]
    by: Videos_tags_linkScalarFieldEnum[] | Videos_tags_linkScalarFieldEnum
    having?: videos_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Videos_tags_linkCountAggregateInputType | true
    _avg?: Videos_tags_linkAvgAggregateInputType
    _sum?: Videos_tags_linkSumAggregateInputType
    _min?: Videos_tags_linkMinAggregateInputType
    _max?: Videos_tags_linkMaxAggregateInputType
  }

  export type Videos_tags_linkGroupByOutputType = {
    id_vid: number
    id_tags: number
    _count: Videos_tags_linkCountAggregateOutputType | null
    _avg: Videos_tags_linkAvgAggregateOutputType | null
    _sum: Videos_tags_linkSumAggregateOutputType | null
    _min: Videos_tags_linkMinAggregateOutputType | null
    _max: Videos_tags_linkMaxAggregateOutputType | null
  }

  type GetVideos_tags_linkGroupByPayload<T extends videos_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Videos_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Videos_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Videos_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Videos_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type videos_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_vid?: boolean
    id_tags?: boolean
    videos?: boolean | videosDefaultArgs<ExtArgs>
    videos_tags?: boolean | videos_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos_tags_link"]>



  export type videos_tags_linkSelectScalar = {
    id_vid?: boolean
    id_tags?: boolean
  }

  export type videos_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_vid" | "id_tags", ExtArgs["result"]["videos_tags_link"]>
  export type videos_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | videosDefaultArgs<ExtArgs>
    videos_tags?: boolean | videos_tagsDefaultArgs<ExtArgs>
  }

  export type $videos_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos_tags_link"
    objects: {
      videos: Prisma.$videosPayload<ExtArgs>
      videos_tags: Prisma.$videos_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_vid: number
      id_tags: number
    }, ExtArgs["result"]["videos_tags_link"]>
    composites: {}
  }

  type videos_tags_linkGetPayload<S extends boolean | null | undefined | videos_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$videos_tags_linkPayload, S>

  type videos_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videos_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Videos_tags_linkCountAggregateInputType | true
    }

  export interface videos_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos_tags_link'], meta: { name: 'videos_tags_link' } }
    /**
     * Find zero or one Videos_tags_link that matches the filter.
     * @param {videos_tags_linkFindUniqueArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videos_tags_linkFindUniqueArgs>(args: SelectSubset<T, videos_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videos_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videos_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, videos_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkFindFirstArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videos_tags_linkFindFirstArgs>(args?: SelectSubset<T, videos_tags_linkFindFirstArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videos_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, videos_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos_tags_links
     * const videos_tags_links = await prisma.videos_tags_link.findMany()
     * 
     * // Get first 10 Videos_tags_links
     * const videos_tags_links = await prisma.videos_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_vid`
     * const videos_tags_linkWithId_vidOnly = await prisma.videos_tags_link.findMany({ select: { id_vid: true } })
     * 
     */
    findMany<T extends videos_tags_linkFindManyArgs>(args?: SelectSubset<T, videos_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos_tags_link.
     * @param {videos_tags_linkCreateArgs} args - Arguments to create a Videos_tags_link.
     * @example
     * // Create one Videos_tags_link
     * const Videos_tags_link = await prisma.videos_tags_link.create({
     *   data: {
     *     // ... data to create a Videos_tags_link
     *   }
     * })
     * 
     */
    create<T extends videos_tags_linkCreateArgs>(args: SelectSubset<T, videos_tags_linkCreateArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos_tags_links.
     * @param {videos_tags_linkCreateManyArgs} args - Arguments to create many Videos_tags_links.
     * @example
     * // Create many Videos_tags_links
     * const videos_tags_link = await prisma.videos_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videos_tags_linkCreateManyArgs>(args?: SelectSubset<T, videos_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos_tags_link.
     * @param {videos_tags_linkDeleteArgs} args - Arguments to delete one Videos_tags_link.
     * @example
     * // Delete one Videos_tags_link
     * const Videos_tags_link = await prisma.videos_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Videos_tags_link
     *   }
     * })
     * 
     */
    delete<T extends videos_tags_linkDeleteArgs>(args: SelectSubset<T, videos_tags_linkDeleteArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos_tags_link.
     * @param {videos_tags_linkUpdateArgs} args - Arguments to update one Videos_tags_link.
     * @example
     * // Update one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videos_tags_linkUpdateArgs>(args: SelectSubset<T, videos_tags_linkUpdateArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos_tags_links.
     * @param {videos_tags_linkDeleteManyArgs} args - Arguments to filter Videos_tags_links to delete.
     * @example
     * // Delete a few Videos_tags_links
     * const { count } = await prisma.videos_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videos_tags_linkDeleteManyArgs>(args?: SelectSubset<T, videos_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos_tags_links
     * const videos_tags_link = await prisma.videos_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videos_tags_linkUpdateManyArgs>(args: SelectSubset<T, videos_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos_tags_link.
     * @param {videos_tags_linkUpsertArgs} args - Arguments to update or create a Videos_tags_link.
     * @example
     * // Update or create a Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.upsert({
     *   create: {
     *     // ... data to create a Videos_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends videos_tags_linkUpsertArgs>(args: SelectSubset<T, videos_tags_linkUpsertArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkCountArgs} args - Arguments to filter Videos_tags_links to count.
     * @example
     * // Count the number of Videos_tags_links
     * const count = await prisma.videos_tags_link.count({
     *   where: {
     *     // ... the filter for the Videos_tags_links we want to count
     *   }
     * })
    **/
    count<T extends videos_tags_linkCountArgs>(
      args?: Subset<T, videos_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Videos_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Videos_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Videos_tags_linkAggregateArgs>(args: Subset<T, Videos_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetVideos_tags_linkAggregateType<T>>

    /**
     * Group by Videos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videos_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videos_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: videos_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videos_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideos_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos_tags_link model
   */
  readonly fields: videos_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videos_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends videosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, videosDefaultArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videos_tags<T extends videos_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, videos_tagsDefaultArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos_tags_link model
   */
  interface videos_tags_linkFieldRefs {
    readonly id_vid: FieldRef<"videos_tags_link", 'Int'>
    readonly id_tags: FieldRef<"videos_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * videos_tags_link findUnique
   */
  export type videos_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link findUniqueOrThrow
   */
  export type videos_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link findFirst
   */
  export type videos_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags_links.
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags_links.
     */
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags_link findFirstOrThrow
   */
  export type videos_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags_links.
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags_links.
     */
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags_link findMany
   */
  export type videos_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_links to fetch.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos_tags_links.
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags_link create
   */
  export type videos_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a videos_tags_link.
     */
    data: XOR<videos_tags_linkCreateInput, videos_tags_linkUncheckedCreateInput>
  }

  /**
   * videos_tags_link createMany
   */
  export type videos_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos_tags_links.
     */
    data: videos_tags_linkCreateManyInput | videos_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos_tags_link update
   */
  export type videos_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a videos_tags_link.
     */
    data: XOR<videos_tags_linkUpdateInput, videos_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which videos_tags_link to update.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link updateMany
   */
  export type videos_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos_tags_links.
     */
    data: XOR<videos_tags_linkUpdateManyMutationInput, videos_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which videos_tags_links to update
     */
    where?: videos_tags_linkWhereInput
    /**
     * Limit how many videos_tags_links to update.
     */
    limit?: number
  }

  /**
   * videos_tags_link upsert
   */
  export type videos_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the videos_tags_link to update in case it exists.
     */
    where: videos_tags_linkWhereUniqueInput
    /**
     * In case the videos_tags_link found by the `where` argument doesn't exist, create a new videos_tags_link with this data.
     */
    create: XOR<videos_tags_linkCreateInput, videos_tags_linkUncheckedCreateInput>
    /**
     * In case the videos_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videos_tags_linkUpdateInput, videos_tags_linkUncheckedUpdateInput>
  }

  /**
   * videos_tags_link delete
   */
  export type videos_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which videos_tags_link to delete.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link deleteMany
   */
  export type videos_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags_links to delete
     */
    where?: videos_tags_linkWhereInput
    /**
     * Limit how many videos_tags_links to delete.
     */
    limit?: number
  }

  /**
   * videos_tags_link without action
   */
  export type videos_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags_recherche
   */

  export type AggregatePhotos_tags_recherche = {
    _count: Photos_tags_rechercheCountAggregateOutputType | null
    _avg: Photos_tags_rechercheAvgAggregateOutputType | null
    _sum: Photos_tags_rechercheSumAggregateOutputType | null
    _min: Photos_tags_rechercheMinAggregateOutputType | null
    _max: Photos_tags_rechercheMaxAggregateOutputType | null
  }

  export type Photos_tags_rechercheAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tags_rechercheSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tags_rechercheMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tags_rechercheMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tags_rechercheCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Photos_tags_rechercheAvgAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tags_rechercheSumAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tags_rechercheMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tags_rechercheMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tags_rechercheCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Photos_tags_rechercheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherche to aggregate.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags_recherches
    **/
    _count?: true | Photos_tags_rechercheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tags_rechercheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tags_rechercheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tags_rechercheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tags_rechercheMaxAggregateInputType
  }

  export type GetPhotos_tags_rechercheAggregateType<T extends Photos_tags_rechercheAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags_recherche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags_recherche[P]>
      : GetScalarType<T[P], AggregatePhotos_tags_recherche[P]>
  }




  export type photos_tags_rechercheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_rechercheWhereInput
    orderBy?: photos_tags_rechercheOrderByWithAggregationInput | photos_tags_rechercheOrderByWithAggregationInput[]
    by: Photos_tags_rechercheScalarFieldEnum[] | Photos_tags_rechercheScalarFieldEnum
    having?: photos_tags_rechercheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tags_rechercheCountAggregateInputType | true
    _avg?: Photos_tags_rechercheAvgAggregateInputType
    _sum?: Photos_tags_rechercheSumAggregateInputType
    _min?: Photos_tags_rechercheMinAggregateInputType
    _max?: Photos_tags_rechercheMaxAggregateInputType
  }

  export type Photos_tags_rechercheGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Photos_tags_rechercheCountAggregateOutputType | null
    _avg: Photos_tags_rechercheAvgAggregateOutputType | null
    _sum: Photos_tags_rechercheSumAggregateOutputType | null
    _min: Photos_tags_rechercheMinAggregateOutputType | null
    _max: Photos_tags_rechercheMaxAggregateOutputType | null
  }

  type GetPhotos_tags_rechercheGroupByPayload<T extends photos_tags_rechercheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tags_rechercheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tags_rechercheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tags_rechercheGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tags_rechercheGroupByOutputType[P]>
        }
      >
    >


  export type photos_tags_rechercheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    photos_tags_recherche_link?: boolean | photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | Photos_tags_rechercheCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags_recherche"]>



  export type photos_tags_rechercheSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type photos_tags_rechercheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["photos_tags_recherche"]>
  export type photos_tags_rechercheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_tags_recherche_link?: boolean | photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | Photos_tags_rechercheCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photos_tags_recherchePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags_recherche"
    objects: {
      photos_tags_recherche_link: Prisma.$photos_tags_recherche_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["photos_tags_recherche"]>
    composites: {}
  }

  type photos_tags_rechercheGetPayload<S extends boolean | null | undefined | photos_tags_rechercheDefaultArgs> = $Result.GetResult<Prisma.$photos_tags_recherchePayload, S>

  type photos_tags_rechercheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tags_rechercheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tags_rechercheCountAggregateInputType | true
    }

  export interface photos_tags_rechercheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags_recherche'], meta: { name: 'photos_tags_recherche' } }
    /**
     * Find zero or one Photos_tags_recherche that matches the filter.
     * @param {photos_tags_rechercheFindUniqueArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tags_rechercheFindUniqueArgs>(args: SelectSubset<T, photos_tags_rechercheFindUniqueArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags_recherche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tags_rechercheFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tags_rechercheFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tags_rechercheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheFindFirstArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tags_rechercheFindFirstArgs>(args?: SelectSubset<T, photos_tags_rechercheFindFirstArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheFindFirstOrThrowArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tags_rechercheFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tags_rechercheFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags_recherches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags_recherches
     * const photos_tags_recherches = await prisma.photos_tags_recherche.findMany()
     * 
     * // Get first 10 Photos_tags_recherches
     * const photos_tags_recherches = await prisma.photos_tags_recherche.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const photos_tags_rechercheWithId_tagsOnly = await prisma.photos_tags_recherche.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends photos_tags_rechercheFindManyArgs>(args?: SelectSubset<T, photos_tags_rechercheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags_recherche.
     * @param {photos_tags_rechercheCreateArgs} args - Arguments to create a Photos_tags_recherche.
     * @example
     * // Create one Photos_tags_recherche
     * const Photos_tags_recherche = await prisma.photos_tags_recherche.create({
     *   data: {
     *     // ... data to create a Photos_tags_recherche
     *   }
     * })
     * 
     */
    create<T extends photos_tags_rechercheCreateArgs>(args: SelectSubset<T, photos_tags_rechercheCreateArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags_recherches.
     * @param {photos_tags_rechercheCreateManyArgs} args - Arguments to create many Photos_tags_recherches.
     * @example
     * // Create many Photos_tags_recherches
     * const photos_tags_recherche = await prisma.photos_tags_recherche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tags_rechercheCreateManyArgs>(args?: SelectSubset<T, photos_tags_rechercheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags_recherche.
     * @param {photos_tags_rechercheDeleteArgs} args - Arguments to delete one Photos_tags_recherche.
     * @example
     * // Delete one Photos_tags_recherche
     * const Photos_tags_recherche = await prisma.photos_tags_recherche.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags_recherche
     *   }
     * })
     * 
     */
    delete<T extends photos_tags_rechercheDeleteArgs>(args: SelectSubset<T, photos_tags_rechercheDeleteArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags_recherche.
     * @param {photos_tags_rechercheUpdateArgs} args - Arguments to update one Photos_tags_recherche.
     * @example
     * // Update one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tags_rechercheUpdateArgs>(args: SelectSubset<T, photos_tags_rechercheUpdateArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags_recherches.
     * @param {photos_tags_rechercheDeleteManyArgs} args - Arguments to filter Photos_tags_recherches to delete.
     * @example
     * // Delete a few Photos_tags_recherches
     * const { count } = await prisma.photos_tags_recherche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tags_rechercheDeleteManyArgs>(args?: SelectSubset<T, photos_tags_rechercheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags_recherches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags_recherches
     * const photos_tags_recherche = await prisma.photos_tags_recherche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tags_rechercheUpdateManyArgs>(args: SelectSubset<T, photos_tags_rechercheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags_recherche.
     * @param {photos_tags_rechercheUpsertArgs} args - Arguments to update or create a Photos_tags_recherche.
     * @example
     * // Update or create a Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.upsert({
     *   create: {
     *     // ... data to create a Photos_tags_recherche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags_recherche we want to update
     *   }
     * })
     */
    upsert<T extends photos_tags_rechercheUpsertArgs>(args: SelectSubset<T, photos_tags_rechercheUpsertArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags_recherches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheCountArgs} args - Arguments to filter Photos_tags_recherches to count.
     * @example
     * // Count the number of Photos_tags_recherches
     * const count = await prisma.photos_tags_recherche.count({
     *   where: {
     *     // ... the filter for the Photos_tags_recherches we want to count
     *   }
     * })
    **/
    count<T extends photos_tags_rechercheCountArgs>(
      args?: Subset<T, photos_tags_rechercheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tags_rechercheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags_recherche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tags_rechercheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tags_rechercheAggregateArgs>(args: Subset<T, Photos_tags_rechercheAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tags_rechercheAggregateType<T>>

    /**
     * Group by Photos_tags_recherche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tags_rechercheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tags_rechercheGroupByArgs['orderBy'] }
        : { orderBy?: photos_tags_rechercheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tags_rechercheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tags_rechercheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags_recherche model
   */
  readonly fields: photos_tags_rechercheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags_recherche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tags_rechercheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_tags_recherche_link<T extends photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags_recherche model
   */
  interface photos_tags_rechercheFieldRefs {
    readonly id_tags: FieldRef<"photos_tags_recherche", 'Int'>
    readonly titre: FieldRef<"photos_tags_recherche", 'String'>
    readonly important: FieldRef<"photos_tags_recherche", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags_recherche findUnique
   */
  export type photos_tags_rechercheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche findUniqueOrThrow
   */
  export type photos_tags_rechercheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche findFirst
   */
  export type photos_tags_rechercheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherches.
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherches.
     */
    distinct?: Photos_tags_rechercheScalarFieldEnum | Photos_tags_rechercheScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche findFirstOrThrow
   */
  export type photos_tags_rechercheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherches.
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherches.
     */
    distinct?: Photos_tags_rechercheScalarFieldEnum | Photos_tags_rechercheScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche findMany
   */
  export type photos_tags_rechercheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherches to fetch.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags_recherches.
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    distinct?: Photos_tags_rechercheScalarFieldEnum | Photos_tags_rechercheScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche create
   */
  export type photos_tags_rechercheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags_recherche.
     */
    data: XOR<photos_tags_rechercheCreateInput, photos_tags_rechercheUncheckedCreateInput>
  }

  /**
   * photos_tags_recherche createMany
   */
  export type photos_tags_rechercheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags_recherches.
     */
    data: photos_tags_rechercheCreateManyInput | photos_tags_rechercheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags_recherche update
   */
  export type photos_tags_rechercheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags_recherche.
     */
    data: XOR<photos_tags_rechercheUpdateInput, photos_tags_rechercheUncheckedUpdateInput>
    /**
     * Choose, which photos_tags_recherche to update.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche updateMany
   */
  export type photos_tags_rechercheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags_recherches.
     */
    data: XOR<photos_tags_rechercheUpdateManyMutationInput, photos_tags_rechercheUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags_recherches to update
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * Limit how many photos_tags_recherches to update.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche upsert
   */
  export type photos_tags_rechercheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags_recherche to update in case it exists.
     */
    where: photos_tags_rechercheWhereUniqueInput
    /**
     * In case the photos_tags_recherche found by the `where` argument doesn't exist, create a new photos_tags_recherche with this data.
     */
    create: XOR<photos_tags_rechercheCreateInput, photos_tags_rechercheUncheckedCreateInput>
    /**
     * In case the photos_tags_recherche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tags_rechercheUpdateInput, photos_tags_rechercheUncheckedUpdateInput>
  }

  /**
   * photos_tags_recherche delete
   */
  export type photos_tags_rechercheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter which photos_tags_recherche to delete.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche deleteMany
   */
  export type photos_tags_rechercheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherches to delete
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * Limit how many photos_tags_recherches to delete.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche.photos_tags_recherche_link
   */
  export type photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    where?: photos_tags_recherche_linkWhereInput
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche without action
   */
  export type photos_tags_rechercheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags_recherche_link
   */

  export type AggregatePhotos_tags_recherche_link = {
    _count: Photos_tags_recherche_linkCountAggregateOutputType | null
    _avg: Photos_tags_recherche_linkAvgAggregateOutputType | null
    _sum: Photos_tags_recherche_linkSumAggregateOutputType | null
    _min: Photos_tags_recherche_linkMinAggregateOutputType | null
    _max: Photos_tags_recherche_linkMaxAggregateOutputType | null
  }

  export type Photos_tags_recherche_linkAvgAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkSumAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkMinAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkMaxAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkCountAggregateOutputType = {
    id_pho: number
    id_tags: number
    _all: number
  }


  export type Photos_tags_recherche_linkAvgAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkSumAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkMinAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkMaxAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkCountAggregateInputType = {
    id_pho?: true
    id_tags?: true
    _all?: true
  }

  export type Photos_tags_recherche_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherche_link to aggregate.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags_recherche_links
    **/
    _count?: true | Photos_tags_recherche_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tags_recherche_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tags_recherche_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tags_recherche_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tags_recherche_linkMaxAggregateInputType
  }

  export type GetPhotos_tags_recherche_linkAggregateType<T extends Photos_tags_recherche_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags_recherche_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags_recherche_link[P]>
      : GetScalarType<T[P], AggregatePhotos_tags_recherche_link[P]>
  }




  export type photos_tags_recherche_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_recherche_linkWhereInput
    orderBy?: photos_tags_recherche_linkOrderByWithAggregationInput | photos_tags_recherche_linkOrderByWithAggregationInput[]
    by: Photos_tags_recherche_linkScalarFieldEnum[] | Photos_tags_recherche_linkScalarFieldEnum
    having?: photos_tags_recherche_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tags_recherche_linkCountAggregateInputType | true
    _avg?: Photos_tags_recherche_linkAvgAggregateInputType
    _sum?: Photos_tags_recherche_linkSumAggregateInputType
    _min?: Photos_tags_recherche_linkMinAggregateInputType
    _max?: Photos_tags_recherche_linkMaxAggregateInputType
  }

  export type Photos_tags_recherche_linkGroupByOutputType = {
    id_pho: number
    id_tags: number
    _count: Photos_tags_recherche_linkCountAggregateOutputType | null
    _avg: Photos_tags_recherche_linkAvgAggregateOutputType | null
    _sum: Photos_tags_recherche_linkSumAggregateOutputType | null
    _min: Photos_tags_recherche_linkMinAggregateOutputType | null
    _max: Photos_tags_recherche_linkMaxAggregateOutputType | null
  }

  type GetPhotos_tags_recherche_linkGroupByPayload<T extends photos_tags_recherche_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tags_recherche_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tags_recherche_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tags_recherche_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tags_recherche_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_tags_recherche_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    id_tags?: boolean
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags_recherche?: boolean | photos_tags_rechercheDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags_recherche_link"]>



  export type photos_tags_recherche_linkSelectScalar = {
    id_pho?: boolean
    id_tags?: boolean
  }

  export type photos_tags_recherche_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "id_tags", ExtArgs["result"]["photos_tags_recherche_link"]>
  export type photos_tags_recherche_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags_recherche?: boolean | photos_tags_rechercheDefaultArgs<ExtArgs>
  }

  export type $photos_tags_recherche_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags_recherche_link"
    objects: {
      photos: Prisma.$photosPayload<ExtArgs>
      photos_tags_recherche: Prisma.$photos_tags_recherchePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      id_tags: number
    }, ExtArgs["result"]["photos_tags_recherche_link"]>
    composites: {}
  }

  type photos_tags_recherche_linkGetPayload<S extends boolean | null | undefined | photos_tags_recherche_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_tags_recherche_linkPayload, S>

  type photos_tags_recherche_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tags_recherche_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tags_recherche_linkCountAggregateInputType | true
    }

  export interface photos_tags_recherche_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags_recherche_link'], meta: { name: 'photos_tags_recherche_link' } }
    /**
     * Find zero or one Photos_tags_recherche_link that matches the filter.
     * @param {photos_tags_recherche_linkFindUniqueArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tags_recherche_linkFindUniqueArgs>(args: SelectSubset<T, photos_tags_recherche_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags_recherche_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tags_recherche_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tags_recherche_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tags_recherche_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkFindFirstArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tags_recherche_linkFindFirstArgs>(args?: SelectSubset<T, photos_tags_recherche_linkFindFirstArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tags_recherche_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tags_recherche_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags_recherche_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags_recherche_links
     * const photos_tags_recherche_links = await prisma.photos_tags_recherche_link.findMany()
     * 
     * // Get first 10 Photos_tags_recherche_links
     * const photos_tags_recherche_links = await prisma.photos_tags_recherche_link.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photos_tags_recherche_linkWithId_phoOnly = await prisma.photos_tags_recherche_link.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photos_tags_recherche_linkFindManyArgs>(args?: SelectSubset<T, photos_tags_recherche_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkCreateArgs} args - Arguments to create a Photos_tags_recherche_link.
     * @example
     * // Create one Photos_tags_recherche_link
     * const Photos_tags_recherche_link = await prisma.photos_tags_recherche_link.create({
     *   data: {
     *     // ... data to create a Photos_tags_recherche_link
     *   }
     * })
     * 
     */
    create<T extends photos_tags_recherche_linkCreateArgs>(args: SelectSubset<T, photos_tags_recherche_linkCreateArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags_recherche_links.
     * @param {photos_tags_recherche_linkCreateManyArgs} args - Arguments to create many Photos_tags_recherche_links.
     * @example
     * // Create many Photos_tags_recherche_links
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tags_recherche_linkCreateManyArgs>(args?: SelectSubset<T, photos_tags_recherche_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkDeleteArgs} args - Arguments to delete one Photos_tags_recherche_link.
     * @example
     * // Delete one Photos_tags_recherche_link
     * const Photos_tags_recherche_link = await prisma.photos_tags_recherche_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags_recherche_link
     *   }
     * })
     * 
     */
    delete<T extends photos_tags_recherche_linkDeleteArgs>(args: SelectSubset<T, photos_tags_recherche_linkDeleteArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkUpdateArgs} args - Arguments to update one Photos_tags_recherche_link.
     * @example
     * // Update one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tags_recherche_linkUpdateArgs>(args: SelectSubset<T, photos_tags_recherche_linkUpdateArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags_recherche_links.
     * @param {photos_tags_recherche_linkDeleteManyArgs} args - Arguments to filter Photos_tags_recherche_links to delete.
     * @example
     * // Delete a few Photos_tags_recherche_links
     * const { count } = await prisma.photos_tags_recherche_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tags_recherche_linkDeleteManyArgs>(args?: SelectSubset<T, photos_tags_recherche_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags_recherche_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags_recherche_links
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tags_recherche_linkUpdateManyArgs>(args: SelectSubset<T, photos_tags_recherche_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkUpsertArgs} args - Arguments to update or create a Photos_tags_recherche_link.
     * @example
     * // Update or create a Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.upsert({
     *   create: {
     *     // ... data to create a Photos_tags_recherche_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags_recherche_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_tags_recherche_linkUpsertArgs>(args: SelectSubset<T, photos_tags_recherche_linkUpsertArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags_recherche_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkCountArgs} args - Arguments to filter Photos_tags_recherche_links to count.
     * @example
     * // Count the number of Photos_tags_recherche_links
     * const count = await prisma.photos_tags_recherche_link.count({
     *   where: {
     *     // ... the filter for the Photos_tags_recherche_links we want to count
     *   }
     * })
    **/
    count<T extends photos_tags_recherche_linkCountArgs>(
      args?: Subset<T, photos_tags_recherche_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tags_recherche_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags_recherche_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tags_recherche_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tags_recherche_linkAggregateArgs>(args: Subset<T, Photos_tags_recherche_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tags_recherche_linkAggregateType<T>>

    /**
     * Group by Photos_tags_recherche_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tags_recherche_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tags_recherche_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_tags_recherche_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tags_recherche_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tags_recherche_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags_recherche_link model
   */
  readonly fields: photos_tags_recherche_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags_recherche_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tags_recherche_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends photosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photosDefaultArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_tags_recherche<T extends photos_tags_rechercheDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags_rechercheDefaultArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags_recherche_link model
   */
  interface photos_tags_recherche_linkFieldRefs {
    readonly id_pho: FieldRef<"photos_tags_recherche_link", 'Int'>
    readonly id_tags: FieldRef<"photos_tags_recherche_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags_recherche_link findUnique
   */
  export type photos_tags_recherche_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link findUniqueOrThrow
   */
  export type photos_tags_recherche_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link findFirst
   */
  export type photos_tags_recherche_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherche_links.
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherche_links.
     */
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche_link findFirstOrThrow
   */
  export type photos_tags_recherche_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherche_links.
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherche_links.
     */
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche_link findMany
   */
  export type photos_tags_recherche_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_links to fetch.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags_recherche_links.
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche_link create
   */
  export type photos_tags_recherche_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags_recherche_link.
     */
    data: XOR<photos_tags_recherche_linkCreateInput, photos_tags_recherche_linkUncheckedCreateInput>
  }

  /**
   * photos_tags_recherche_link createMany
   */
  export type photos_tags_recherche_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags_recherche_links.
     */
    data: photos_tags_recherche_linkCreateManyInput | photos_tags_recherche_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags_recherche_link update
   */
  export type photos_tags_recherche_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags_recherche_link.
     */
    data: XOR<photos_tags_recherche_linkUpdateInput, photos_tags_recherche_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_tags_recherche_link to update.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link updateMany
   */
  export type photos_tags_recherche_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags_recherche_links.
     */
    data: XOR<photos_tags_recherche_linkUpdateManyMutationInput, photos_tags_recherche_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags_recherche_links to update
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * Limit how many photos_tags_recherche_links to update.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche_link upsert
   */
  export type photos_tags_recherche_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags_recherche_link to update in case it exists.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
    /**
     * In case the photos_tags_recherche_link found by the `where` argument doesn't exist, create a new photos_tags_recherche_link with this data.
     */
    create: XOR<photos_tags_recherche_linkCreateInput, photos_tags_recherche_linkUncheckedCreateInput>
    /**
     * In case the photos_tags_recherche_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tags_recherche_linkUpdateInput, photos_tags_recherche_linkUncheckedUpdateInput>
  }

  /**
   * photos_tags_recherche_link delete
   */
  export type photos_tags_recherche_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_tags_recherche_link to delete.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link deleteMany
   */
  export type photos_tags_recherche_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherche_links to delete
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * Limit how many photos_tags_recherche_links to delete.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche_link without action
   */
  export type photos_tags_recherche_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
  }


  /**
   * Model photos_albums_tags_link
   */

  export type AggregatePhotos_albums_tags_link = {
    _count: Photos_albums_tags_linkCountAggregateOutputType | null
    _avg: Photos_albums_tags_linkAvgAggregateOutputType | null
    _sum: Photos_albums_tags_linkSumAggregateOutputType | null
    _min: Photos_albums_tags_linkMinAggregateOutputType | null
    _max: Photos_albums_tags_linkMaxAggregateOutputType | null
  }

  export type Photos_albums_tags_linkAvgAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkSumAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkMinAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkMaxAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkCountAggregateOutputType = {
    id_alb: number
    id_tags: number
    _all: number
  }


  export type Photos_albums_tags_linkAvgAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkSumAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkMinAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkMaxAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkCountAggregateInputType = {
    id_alb?: true
    id_tags?: true
    _all?: true
  }

  export type Photos_albums_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_tags_link to aggregate.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_albums_tags_links
    **/
    _count?: true | Photos_albums_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_albums_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_albums_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_albums_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_albums_tags_linkMaxAggregateInputType
  }

  export type GetPhotos_albums_tags_linkAggregateType<T extends Photos_albums_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_albums_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_albums_tags_link[P]>
      : GetScalarType<T[P], AggregatePhotos_albums_tags_link[P]>
  }




  export type photos_albums_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_tags_linkWhereInput
    orderBy?: photos_albums_tags_linkOrderByWithAggregationInput | photos_albums_tags_linkOrderByWithAggregationInput[]
    by: Photos_albums_tags_linkScalarFieldEnum[] | Photos_albums_tags_linkScalarFieldEnum
    having?: photos_albums_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_albums_tags_linkCountAggregateInputType | true
    _avg?: Photos_albums_tags_linkAvgAggregateInputType
    _sum?: Photos_albums_tags_linkSumAggregateInputType
    _min?: Photos_albums_tags_linkMinAggregateInputType
    _max?: Photos_albums_tags_linkMaxAggregateInputType
  }

  export type Photos_albums_tags_linkGroupByOutputType = {
    id_alb: number
    id_tags: number
    _count: Photos_albums_tags_linkCountAggregateOutputType | null
    _avg: Photos_albums_tags_linkAvgAggregateOutputType | null
    _sum: Photos_albums_tags_linkSumAggregateOutputType | null
    _min: Photos_albums_tags_linkMinAggregateOutputType | null
    _max: Photos_albums_tags_linkMaxAggregateOutputType | null
  }

  type GetPhotos_albums_tags_linkGroupByPayload<T extends photos_albums_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_albums_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_albums_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_albums_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_albums_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_albums_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alb?: boolean
    id_tags?: boolean
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_albums_tags_link"]>



  export type photos_albums_tags_linkSelectScalar = {
    id_alb?: boolean
    id_tags?: boolean
  }

  export type photos_albums_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_alb" | "id_tags", ExtArgs["result"]["photos_albums_tags_link"]>
  export type photos_albums_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }

  export type $photos_albums_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_albums_tags_link"
    objects: {
      photos_albums: Prisma.$photos_albumsPayload<ExtArgs>
      photos_tags: Prisma.$photos_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_alb: number
      id_tags: number
    }, ExtArgs["result"]["photos_albums_tags_link"]>
    composites: {}
  }

  type photos_albums_tags_linkGetPayload<S extends boolean | null | undefined | photos_albums_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_albums_tags_linkPayload, S>

  type photos_albums_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_albums_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_albums_tags_linkCountAggregateInputType | true
    }

  export interface photos_albums_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_albums_tags_link'], meta: { name: 'photos_albums_tags_link' } }
    /**
     * Find zero or one Photos_albums_tags_link that matches the filter.
     * @param {photos_albums_tags_linkFindUniqueArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_albums_tags_linkFindUniqueArgs>(args: SelectSubset<T, photos_albums_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_albums_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_albums_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_albums_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_albums_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkFindFirstArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_albums_tags_linkFindFirstArgs>(args?: SelectSubset<T, photos_albums_tags_linkFindFirstArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_albums_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_albums_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_albums_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_albums_tags_links
     * const photos_albums_tags_links = await prisma.photos_albums_tags_link.findMany()
     * 
     * // Get first 10 Photos_albums_tags_links
     * const photos_albums_tags_links = await prisma.photos_albums_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_alb`
     * const photos_albums_tags_linkWithId_albOnly = await prisma.photos_albums_tags_link.findMany({ select: { id_alb: true } })
     * 
     */
    findMany<T extends photos_albums_tags_linkFindManyArgs>(args?: SelectSubset<T, photos_albums_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_albums_tags_link.
     * @param {photos_albums_tags_linkCreateArgs} args - Arguments to create a Photos_albums_tags_link.
     * @example
     * // Create one Photos_albums_tags_link
     * const Photos_albums_tags_link = await prisma.photos_albums_tags_link.create({
     *   data: {
     *     // ... data to create a Photos_albums_tags_link
     *   }
     * })
     * 
     */
    create<T extends photos_albums_tags_linkCreateArgs>(args: SelectSubset<T, photos_albums_tags_linkCreateArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_albums_tags_links.
     * @param {photos_albums_tags_linkCreateManyArgs} args - Arguments to create many Photos_albums_tags_links.
     * @example
     * // Create many Photos_albums_tags_links
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_albums_tags_linkCreateManyArgs>(args?: SelectSubset<T, photos_albums_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_albums_tags_link.
     * @param {photos_albums_tags_linkDeleteArgs} args - Arguments to delete one Photos_albums_tags_link.
     * @example
     * // Delete one Photos_albums_tags_link
     * const Photos_albums_tags_link = await prisma.photos_albums_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_albums_tags_link
     *   }
     * })
     * 
     */
    delete<T extends photos_albums_tags_linkDeleteArgs>(args: SelectSubset<T, photos_albums_tags_linkDeleteArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_albums_tags_link.
     * @param {photos_albums_tags_linkUpdateArgs} args - Arguments to update one Photos_albums_tags_link.
     * @example
     * // Update one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_albums_tags_linkUpdateArgs>(args: SelectSubset<T, photos_albums_tags_linkUpdateArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_albums_tags_links.
     * @param {photos_albums_tags_linkDeleteManyArgs} args - Arguments to filter Photos_albums_tags_links to delete.
     * @example
     * // Delete a few Photos_albums_tags_links
     * const { count } = await prisma.photos_albums_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_albums_tags_linkDeleteManyArgs>(args?: SelectSubset<T, photos_albums_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_albums_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_albums_tags_links
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_albums_tags_linkUpdateManyArgs>(args: SelectSubset<T, photos_albums_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_albums_tags_link.
     * @param {photos_albums_tags_linkUpsertArgs} args - Arguments to update or create a Photos_albums_tags_link.
     * @example
     * // Update or create a Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.upsert({
     *   create: {
     *     // ... data to create a Photos_albums_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_albums_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_albums_tags_linkUpsertArgs>(args: SelectSubset<T, photos_albums_tags_linkUpsertArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_albums_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkCountArgs} args - Arguments to filter Photos_albums_tags_links to count.
     * @example
     * // Count the number of Photos_albums_tags_links
     * const count = await prisma.photos_albums_tags_link.count({
     *   where: {
     *     // ... the filter for the Photos_albums_tags_links we want to count
     *   }
     * })
    **/
    count<T extends photos_albums_tags_linkCountArgs>(
      args?: Subset<T, photos_albums_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_albums_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_albums_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_albums_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_albums_tags_linkAggregateArgs>(args: Subset<T, Photos_albums_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_albums_tags_linkAggregateType<T>>

    /**
     * Group by Photos_albums_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_albums_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_albums_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_albums_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_albums_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_albums_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_albums_tags_link model
   */
  readonly fields: photos_albums_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_albums_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_albums_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums<T extends photos_albumsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_albumsDefaultArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_tags<T extends photos_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_tagsDefaultArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_albums_tags_link model
   */
  interface photos_albums_tags_linkFieldRefs {
    readonly id_alb: FieldRef<"photos_albums_tags_link", 'Int'>
    readonly id_tags: FieldRef<"photos_albums_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_albums_tags_link findUnique
   */
  export type photos_albums_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link findUniqueOrThrow
   */
  export type photos_albums_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link findFirst
   */
  export type photos_albums_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_tags_links.
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_tags_links.
     */
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_tags_link findFirstOrThrow
   */
  export type photos_albums_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_tags_links.
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_tags_links.
     */
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_tags_link findMany
   */
  export type photos_albums_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_links to fetch.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_albums_tags_links.
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_tags_link create
   */
  export type photos_albums_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_albums_tags_link.
     */
    data: XOR<photos_albums_tags_linkCreateInput, photos_albums_tags_linkUncheckedCreateInput>
  }

  /**
   * photos_albums_tags_link createMany
   */
  export type photos_albums_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_albums_tags_links.
     */
    data: photos_albums_tags_linkCreateManyInput | photos_albums_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_albums_tags_link update
   */
  export type photos_albums_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_albums_tags_link.
     */
    data: XOR<photos_albums_tags_linkUpdateInput, photos_albums_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_albums_tags_link to update.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link updateMany
   */
  export type photos_albums_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_albums_tags_links.
     */
    data: XOR<photos_albums_tags_linkUpdateManyMutationInput, photos_albums_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_albums_tags_links to update
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * Limit how many photos_albums_tags_links to update.
     */
    limit?: number
  }

  /**
   * photos_albums_tags_link upsert
   */
  export type photos_albums_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_albums_tags_link to update in case it exists.
     */
    where: photos_albums_tags_linkWhereUniqueInput
    /**
     * In case the photos_albums_tags_link found by the `where` argument doesn't exist, create a new photos_albums_tags_link with this data.
     */
    create: XOR<photos_albums_tags_linkCreateInput, photos_albums_tags_linkUncheckedCreateInput>
    /**
     * In case the photos_albums_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_albums_tags_linkUpdateInput, photos_albums_tags_linkUncheckedUpdateInput>
  }

  /**
   * photos_albums_tags_link delete
   */
  export type photos_albums_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_albums_tags_link to delete.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link deleteMany
   */
  export type photos_albums_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_tags_links to delete
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * Limit how many photos_albums_tags_links to delete.
     */
    limit?: number
  }

  /**
   * photos_albums_tags_link without action
   */
  export type photos_albums_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account to aggregate.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountWhereInput
    orderBy?: accountOrderByWithAggregationInput | accountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>



  export type accountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type accountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>

  export type $accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "account"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type accountGetPayload<S extends boolean | null | undefined | accountDefaultArgs> = $Result.GetResult<Prisma.$accountPayload, S>

  type accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account'], meta: { name: 'account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {accountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountFindUniqueArgs>(args: SelectSubset<T, accountFindUniqueArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountFindUniqueOrThrowArgs>(args: SelectSubset<T, accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountFindFirstArgs>(args?: SelectSubset<T, accountFindFirstArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountFindFirstOrThrowArgs>(args?: SelectSubset<T, accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountFindManyArgs>(args?: SelectSubset<T, accountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {accountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends accountCreateArgs>(args: SelectSubset<T, accountCreateArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountCreateManyArgs>(args?: SelectSubset<T, accountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {accountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends accountDeleteArgs>(args: SelectSubset<T, accountDeleteArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {accountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountUpdateArgs>(args: SelectSubset<T, accountUpdateArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountDeleteManyArgs>(args?: SelectSubset<T, accountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountUpdateManyArgs>(args: SelectSubset<T, accountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {accountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends accountUpsertArgs>(args: SelectSubset<T, accountUpsertArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountCountArgs>(
      args?: Subset<T, accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountGroupByArgs['orderBy'] }
        : { orderBy?: accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the account model
   */
  readonly fields: accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the account model
   */
  interface accountFieldRefs {
    readonly id: FieldRef<"account", 'String'>
    readonly accountId: FieldRef<"account", 'String'>
    readonly providerId: FieldRef<"account", 'String'>
    readonly userId: FieldRef<"account", 'String'>
    readonly accessToken: FieldRef<"account", 'String'>
    readonly refreshToken: FieldRef<"account", 'String'>
    readonly idToken: FieldRef<"account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"account", 'DateTime'>
    readonly scope: FieldRef<"account", 'String'>
    readonly password: FieldRef<"account", 'String'>
    readonly createdAt: FieldRef<"account", 'DateTime'>
    readonly updatedAt: FieldRef<"account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * account findUnique
   */
  export type accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findUniqueOrThrow
   */
  export type accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findFirst
   */
  export type accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account findFirstOrThrow
   */
  export type accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account findMany
   */
  export type accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account create
   */
  export type accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The data needed to create a account.
     */
    data: XOR<accountCreateInput, accountUncheckedCreateInput>
  }

  /**
   * account createMany
   */
  export type accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountCreateManyInput | accountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * account update
   */
  export type accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The data needed to update a account.
     */
    data: XOR<accountUpdateInput, accountUncheckedUpdateInput>
    /**
     * Choose, which account to update.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account updateMany
   */
  export type accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * account upsert
   */
  export type accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The filter to search for the account to update in case it exists.
     */
    where: accountWhereUniqueInput
    /**
     * In case the account found by the `where` argument doesn't exist, create a new account with this data.
     */
    create: XOR<accountCreateInput, accountUncheckedCreateInput>
    /**
     * In case the account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountUpdateInput, accountUncheckedUpdateInput>
  }

  /**
   * account delete
   */
  export type accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter which account to delete.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account deleteMany
   */
  export type accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * account without action
   */
  export type accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }, ExtArgs["result"]["session"]>



  export type sessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly expiresAt: FieldRef<"session", 'DateTime'>
    readonly token: FieldRef<"session", 'String'>
    readonly createdAt: FieldRef<"session", 'DateTime'>
    readonly updatedAt: FieldRef<"session", 'DateTime'>
    readonly ipAddress: FieldRef<"session", 'String'>
    readonly userAgent: FieldRef<"session", 'String'>
    readonly userId: FieldRef<"session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly emailVerified: FieldRef<"user", 'Boolean'>
    readonly image: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
  }


  /**
   * Model verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification to aggregate.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type verificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: verificationWhereInput
    orderBy?: verificationOrderByWithAggregationInput | verificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: verificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends verificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type verificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>



  export type verificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type verificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $verificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type verificationGetPayload<S extends boolean | null | undefined | verificationDefaultArgs> = $Result.GetResult<Prisma.$verificationPayload, S>

  type verificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<verificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface verificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['verification'], meta: { name: 'verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {verificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends verificationFindUniqueArgs>(args: SelectSubset<T, verificationFindUniqueArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {verificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends verificationFindUniqueOrThrowArgs>(args: SelectSubset<T, verificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends verificationFindFirstArgs>(args?: SelectSubset<T, verificationFindFirstArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends verificationFindFirstOrThrowArgs>(args?: SelectSubset<T, verificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends verificationFindManyArgs>(args?: SelectSubset<T, verificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {verificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends verificationCreateArgs>(args: SelectSubset<T, verificationCreateArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {verificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends verificationCreateManyArgs>(args?: SelectSubset<T, verificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Verification.
     * @param {verificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends verificationDeleteArgs>(args: SelectSubset<T, verificationDeleteArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {verificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends verificationUpdateArgs>(args: SelectSubset<T, verificationUpdateArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {verificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends verificationDeleteManyArgs>(args?: SelectSubset<T, verificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends verificationUpdateManyArgs>(args: SelectSubset<T, verificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {verificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends verificationUpsertArgs>(args: SelectSubset<T, verificationUpsertArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends verificationCountArgs>(
      args?: Subset<T, verificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends verificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: verificationGroupByArgs['orderBy'] }
        : { orderBy?: verificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, verificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the verification model
   */
  readonly fields: verificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__verificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the verification model
   */
  interface verificationFieldRefs {
    readonly id: FieldRef<"verification", 'String'>
    readonly identifier: FieldRef<"verification", 'String'>
    readonly value: FieldRef<"verification", 'String'>
    readonly expiresAt: FieldRef<"verification", 'DateTime'>
    readonly createdAt: FieldRef<"verification", 'DateTime'>
    readonly updatedAt: FieldRef<"verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * verification findUnique
   */
  export type verificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification findUniqueOrThrow
   */
  export type verificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification findFirst
   */
  export type verificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification findFirstOrThrow
   */
  export type verificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification findMany
   */
  export type verificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verifications to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification create
   */
  export type verificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The data needed to create a verification.
     */
    data: XOR<verificationCreateInput, verificationUncheckedCreateInput>
  }

  /**
   * verification createMany
   */
  export type verificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many verifications.
     */
    data: verificationCreateManyInput | verificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * verification update
   */
  export type verificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The data needed to update a verification.
     */
    data: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>
    /**
     * Choose, which verification to update.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification updateMany
   */
  export type verificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update verifications.
     */
    data: XOR<verificationUpdateManyMutationInput, verificationUncheckedUpdateManyInput>
    /**
     * Filter which verifications to update
     */
    where?: verificationWhereInput
    /**
     * Limit how many verifications to update.
     */
    limit?: number
  }

  /**
   * verification upsert
   */
  export type verificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The filter to search for the verification to update in case it exists.
     */
    where: verificationWhereUniqueInput
    /**
     * In case the verification found by the `where` argument doesn't exist, create a new verification with this data.
     */
    create: XOR<verificationCreateInput, verificationUncheckedCreateInput>
    /**
     * In case the verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>
  }

  /**
   * verification delete
   */
  export type verificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter which verification to delete.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification deleteMany
   */
  export type verificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verifications to delete
     */
    where?: verificationWhereInput
    /**
     * Limit how many verifications to delete.
     */
    limit?: number
  }

  /**
   * verification without action
   */
  export type verificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AutreScalarFieldEnum: {
    id_autre: 'id_autre',
    titre: 'titre',
    description: 'description',
    miniature: 'miniature',
    lien_github: 'lien_github',
    lien_figma: 'lien_figma',
    lien_site: 'lien_site',
    categorie: 'categorie',
    tags: 'tags',
    date: 'date',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type AutreScalarFieldEnum = (typeof AutreScalarFieldEnum)[keyof typeof AutreScalarFieldEnum]


  export const Autre_tagsScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Autre_tagsScalarFieldEnum = (typeof Autre_tagsScalarFieldEnum)[keyof typeof Autre_tagsScalarFieldEnum]


  export const Autre_tags_linkScalarFieldEnum: {
    id_autre: 'id_autre',
    id_tags: 'id_tags'
  };

  export type Autre_tags_linkScalarFieldEnum = (typeof Autre_tags_linkScalarFieldEnum)[keyof typeof Autre_tags_linkScalarFieldEnum]


  export const ExperiencesScalarFieldEnum: {
    id_exp: 'id_exp',
    date: 'date',
    titre: 'titre',
    description: 'description',
    url_img: 'url_img',
    position_img: 'position_img',
    afficher: 'afficher'
  };

  export type ExperiencesScalarFieldEnum = (typeof ExperiencesScalarFieldEnum)[keyof typeof ExperiencesScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id_faq: 'id_faq',
    titre: 'titre',
    contenu: 'contenu',
    afficher: 'afficher'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const PhotosScalarFieldEnum: {
    id_pho: 'id_pho',
    lien_high: 'lien_high',
    lien_low: 'lien_low',
    largeur: 'largeur',
    hauteur: 'hauteur',
    alt: 'alt',
    date: 'date',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type PhotosScalarFieldEnum = (typeof PhotosScalarFieldEnum)[keyof typeof PhotosScalarFieldEnum]


  export const Photos_albumsScalarFieldEnum: {
    id_alb: 'id_alb',
    titre: 'titre',
    description: 'description',
    date: 'date',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type Photos_albumsScalarFieldEnum = (typeof Photos_albumsScalarFieldEnum)[keyof typeof Photos_albumsScalarFieldEnum]


  export const Photos_albums_linkScalarFieldEnum: {
    id_pho: 'id_pho',
    id_alb: 'id_alb',
    position: 'position'
  };

  export type Photos_albums_linkScalarFieldEnum = (typeof Photos_albums_linkScalarFieldEnum)[keyof typeof Photos_albums_linkScalarFieldEnum]


  export const Photos_experiencesScalarFieldEnum: {
    id_photo: 'id_photo',
    titre: 'titre',
    url: 'url',
    date: 'date'
  };

  export type Photos_experiencesScalarFieldEnum = (typeof Photos_experiencesScalarFieldEnum)[keyof typeof Photos_experiencesScalarFieldEnum]


  export const Photos_tagsScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Photos_tagsScalarFieldEnum = (typeof Photos_tagsScalarFieldEnum)[keyof typeof Photos_tagsScalarFieldEnum]


  export const Photos_tags_linkScalarFieldEnum: {
    id_pho: 'id_pho',
    id_tags: 'id_tags'
  };

  export type Photos_tags_linkScalarFieldEnum = (typeof Photos_tags_linkScalarFieldEnum)[keyof typeof Photos_tags_linkScalarFieldEnum]


  export const TemoignagesScalarFieldEnum: {
    id_tem: 'id_tem',
    contenu: 'contenu',
    client: 'client',
    plateforme: 'plateforme',
    date: 'date',
    afficher: 'afficher'
  };

  export type TemoignagesScalarFieldEnum = (typeof TemoignagesScalarFieldEnum)[keyof typeof TemoignagesScalarFieldEnum]


  export const UtilisateursScalarFieldEnum: {
    id_user: 'id_user',
    img: 'img',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type UtilisateursScalarFieldEnum = (typeof UtilisateursScalarFieldEnum)[keyof typeof UtilisateursScalarFieldEnum]


  export const VideosScalarFieldEnum: {
    id_vid: 'id_vid',
    titre: 'titre',
    description: 'description',
    tags: 'tags',
    lien: 'lien',
    date: 'date',
    media_webm: 'media_webm',
    media_mp4: 'media_mp4',
    duree: 'duree',
    afficher_competences: 'afficher_competences',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type VideosScalarFieldEnum = (typeof VideosScalarFieldEnum)[keyof typeof VideosScalarFieldEnum]


  export const Videos_tagsScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Videos_tagsScalarFieldEnum = (typeof Videos_tagsScalarFieldEnum)[keyof typeof Videos_tagsScalarFieldEnum]


  export const Videos_tags_linkScalarFieldEnum: {
    id_vid: 'id_vid',
    id_tags: 'id_tags'
  };

  export type Videos_tags_linkScalarFieldEnum = (typeof Videos_tags_linkScalarFieldEnum)[keyof typeof Videos_tags_linkScalarFieldEnum]


  export const Photos_tags_rechercheScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Photos_tags_rechercheScalarFieldEnum = (typeof Photos_tags_rechercheScalarFieldEnum)[keyof typeof Photos_tags_rechercheScalarFieldEnum]


  export const Photos_tags_recherche_linkScalarFieldEnum: {
    id_pho: 'id_pho',
    id_tags: 'id_tags'
  };

  export type Photos_tags_recherche_linkScalarFieldEnum = (typeof Photos_tags_recherche_linkScalarFieldEnum)[keyof typeof Photos_tags_recherche_linkScalarFieldEnum]


  export const Photos_albums_tags_linkScalarFieldEnum: {
    id_alb: 'id_alb',
    id_tags: 'id_tags'
  };

  export type Photos_albums_tags_linkScalarFieldEnum = (typeof Photos_albums_tags_linkScalarFieldEnum)[keyof typeof Photos_albums_tags_linkScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const autreOrderByRelevanceFieldEnum: {
    titre: 'titre',
    description: 'description',
    miniature: 'miniature',
    lien_github: 'lien_github',
    lien_figma: 'lien_figma',
    lien_site: 'lien_site',
    categorie: 'categorie',
    tags: 'tags'
  };

  export type autreOrderByRelevanceFieldEnum = (typeof autreOrderByRelevanceFieldEnum)[keyof typeof autreOrderByRelevanceFieldEnum]


  export const autre_tagsOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type autre_tagsOrderByRelevanceFieldEnum = (typeof autre_tagsOrderByRelevanceFieldEnum)[keyof typeof autre_tagsOrderByRelevanceFieldEnum]


  export const experiencesOrderByRelevanceFieldEnum: {
    titre: 'titre',
    description: 'description',
    url_img: 'url_img',
    position_img: 'position_img'
  };

  export type experiencesOrderByRelevanceFieldEnum = (typeof experiencesOrderByRelevanceFieldEnum)[keyof typeof experiencesOrderByRelevanceFieldEnum]


  export const faqOrderByRelevanceFieldEnum: {
    titre: 'titre',
    contenu: 'contenu'
  };

  export type faqOrderByRelevanceFieldEnum = (typeof faqOrderByRelevanceFieldEnum)[keyof typeof faqOrderByRelevanceFieldEnum]


  export const photosOrderByRelevanceFieldEnum: {
    lien_high: 'lien_high',
    lien_low: 'lien_low',
    alt: 'alt'
  };

  export type photosOrderByRelevanceFieldEnum = (typeof photosOrderByRelevanceFieldEnum)[keyof typeof photosOrderByRelevanceFieldEnum]


  export const photos_albumsOrderByRelevanceFieldEnum: {
    titre: 'titre',
    description: 'description'
  };

  export type photos_albumsOrderByRelevanceFieldEnum = (typeof photos_albumsOrderByRelevanceFieldEnum)[keyof typeof photos_albumsOrderByRelevanceFieldEnum]


  export const photos_experiencesOrderByRelevanceFieldEnum: {
    titre: 'titre',
    url: 'url',
    date: 'date'
  };

  export type photos_experiencesOrderByRelevanceFieldEnum = (typeof photos_experiencesOrderByRelevanceFieldEnum)[keyof typeof photos_experiencesOrderByRelevanceFieldEnum]


  export const photos_tagsOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type photos_tagsOrderByRelevanceFieldEnum = (typeof photos_tagsOrderByRelevanceFieldEnum)[keyof typeof photos_tagsOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const temoignagesOrderByRelevanceFieldEnum: {
    contenu: 'contenu',
    client: 'client',
    plateforme: 'plateforme',
    date: 'date'
  };

  export type temoignagesOrderByRelevanceFieldEnum = (typeof temoignagesOrderByRelevanceFieldEnum)[keyof typeof temoignagesOrderByRelevanceFieldEnum]


  export const utilisateursOrderByRelevanceFieldEnum: {
    img: 'img',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type utilisateursOrderByRelevanceFieldEnum = (typeof utilisateursOrderByRelevanceFieldEnum)[keyof typeof utilisateursOrderByRelevanceFieldEnum]


  export const videosOrderByRelevanceFieldEnum: {
    titre: 'titre',
    description: 'description',
    tags: 'tags',
    lien: 'lien',
    media_webm: 'media_webm',
    media_mp4: 'media_mp4',
    duree: 'duree',
    afficher_competences: 'afficher_competences'
  };

  export type videosOrderByRelevanceFieldEnum = (typeof videosOrderByRelevanceFieldEnum)[keyof typeof videosOrderByRelevanceFieldEnum]


  export const videos_tagsOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type videos_tagsOrderByRelevanceFieldEnum = (typeof videos_tagsOrderByRelevanceFieldEnum)[keyof typeof videos_tagsOrderByRelevanceFieldEnum]


  export const photos_tags_rechercheOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type photos_tags_rechercheOrderByRelevanceFieldEnum = (typeof photos_tags_rechercheOrderByRelevanceFieldEnum)[keyof typeof photos_tags_rechercheOrderByRelevanceFieldEnum]


  export const accountOrderByRelevanceFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    scope: 'scope',
    password: 'password'
  };

  export type accountOrderByRelevanceFieldEnum = (typeof accountOrderByRelevanceFieldEnum)[keyof typeof accountOrderByRelevanceFieldEnum]


  export const sessionOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type sessionOrderByRelevanceFieldEnum = (typeof sessionOrderByRelevanceFieldEnum)[keyof typeof sessionOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const verificationOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value'
  };

  export type verificationOrderByRelevanceFieldEnum = (typeof verificationOrderByRelevanceFieldEnum)[keyof typeof verificationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type autreWhereInput = {
    AND?: autreWhereInput | autreWhereInput[]
    OR?: autreWhereInput[]
    NOT?: autreWhereInput | autreWhereInput[]
    id_autre?: IntFilter<"autre"> | number
    titre?: StringFilter<"autre"> | string
    description?: StringFilter<"autre"> | string
    miniature?: StringFilter<"autre"> | string
    lien_github?: StringFilter<"autre"> | string
    lien_figma?: StringFilter<"autre"> | string
    lien_site?: StringFilter<"autre"> | string
    categorie?: StringFilter<"autre"> | string
    tags?: StringFilter<"autre"> | string
    date?: DateTimeFilter<"autre"> | Date | string
    afficher?: BoolFilter<"autre"> | boolean
    derniere_modification?: DateTimeFilter<"autre"> | Date | string
    autre_tags_link?: Autre_tags_linkListRelationFilter
  }

  export type autreOrderByWithRelationInput = {
    id_autre?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    miniature?: SortOrder
    lien_github?: SortOrder
    lien_figma?: SortOrder
    lien_site?: SortOrder
    categorie?: SortOrder
    tags?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    autre_tags_link?: autre_tags_linkOrderByRelationAggregateInput
    _relevance?: autreOrderByRelevanceInput
  }

  export type autreWhereUniqueInput = Prisma.AtLeast<{
    id_autre?: number
    AND?: autreWhereInput | autreWhereInput[]
    OR?: autreWhereInput[]
    NOT?: autreWhereInput | autreWhereInput[]
    titre?: StringFilter<"autre"> | string
    description?: StringFilter<"autre"> | string
    miniature?: StringFilter<"autre"> | string
    lien_github?: StringFilter<"autre"> | string
    lien_figma?: StringFilter<"autre"> | string
    lien_site?: StringFilter<"autre"> | string
    categorie?: StringFilter<"autre"> | string
    tags?: StringFilter<"autre"> | string
    date?: DateTimeFilter<"autre"> | Date | string
    afficher?: BoolFilter<"autre"> | boolean
    derniere_modification?: DateTimeFilter<"autre"> | Date | string
    autre_tags_link?: Autre_tags_linkListRelationFilter
  }, "id_autre">

  export type autreOrderByWithAggregationInput = {
    id_autre?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    miniature?: SortOrder
    lien_github?: SortOrder
    lien_figma?: SortOrder
    lien_site?: SortOrder
    categorie?: SortOrder
    tags?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: autreCountOrderByAggregateInput
    _avg?: autreAvgOrderByAggregateInput
    _max?: autreMaxOrderByAggregateInput
    _min?: autreMinOrderByAggregateInput
    _sum?: autreSumOrderByAggregateInput
  }

  export type autreScalarWhereWithAggregatesInput = {
    AND?: autreScalarWhereWithAggregatesInput | autreScalarWhereWithAggregatesInput[]
    OR?: autreScalarWhereWithAggregatesInput[]
    NOT?: autreScalarWhereWithAggregatesInput | autreScalarWhereWithAggregatesInput[]
    id_autre?: IntWithAggregatesFilter<"autre"> | number
    titre?: StringWithAggregatesFilter<"autre"> | string
    description?: StringWithAggregatesFilter<"autre"> | string
    miniature?: StringWithAggregatesFilter<"autre"> | string
    lien_github?: StringWithAggregatesFilter<"autre"> | string
    lien_figma?: StringWithAggregatesFilter<"autre"> | string
    lien_site?: StringWithAggregatesFilter<"autre"> | string
    categorie?: StringWithAggregatesFilter<"autre"> | string
    tags?: StringWithAggregatesFilter<"autre"> | string
    date?: DateTimeWithAggregatesFilter<"autre"> | Date | string
    afficher?: BoolWithAggregatesFilter<"autre"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"autre"> | Date | string
  }

  export type autre_tagsWhereInput = {
    AND?: autre_tagsWhereInput | autre_tagsWhereInput[]
    OR?: autre_tagsWhereInput[]
    NOT?: autre_tagsWhereInput | autre_tagsWhereInput[]
    id_tags?: IntFilter<"autre_tags"> | number
    titre?: StringFilter<"autre_tags"> | string
    important?: BoolFilter<"autre_tags"> | boolean
    autre_tags_link?: Autre_tags_linkListRelationFilter
  }

  export type autre_tagsOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    autre_tags_link?: autre_tags_linkOrderByRelationAggregateInput
    _relevance?: autre_tagsOrderByRelevanceInput
  }

  export type autre_tagsWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: autre_tagsWhereInput | autre_tagsWhereInput[]
    OR?: autre_tagsWhereInput[]
    NOT?: autre_tagsWhereInput | autre_tagsWhereInput[]
    titre?: StringFilter<"autre_tags"> | string
    important?: BoolFilter<"autre_tags"> | boolean
    autre_tags_link?: Autre_tags_linkListRelationFilter
  }, "id_tags">

  export type autre_tagsOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: autre_tagsCountOrderByAggregateInput
    _avg?: autre_tagsAvgOrderByAggregateInput
    _max?: autre_tagsMaxOrderByAggregateInput
    _min?: autre_tagsMinOrderByAggregateInput
    _sum?: autre_tagsSumOrderByAggregateInput
  }

  export type autre_tagsScalarWhereWithAggregatesInput = {
    AND?: autre_tagsScalarWhereWithAggregatesInput | autre_tagsScalarWhereWithAggregatesInput[]
    OR?: autre_tagsScalarWhereWithAggregatesInput[]
    NOT?: autre_tagsScalarWhereWithAggregatesInput | autre_tagsScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"autre_tags"> | number
    titre?: StringWithAggregatesFilter<"autre_tags"> | string
    important?: BoolWithAggregatesFilter<"autre_tags"> | boolean
  }

  export type autre_tags_linkWhereInput = {
    AND?: autre_tags_linkWhereInput | autre_tags_linkWhereInput[]
    OR?: autre_tags_linkWhereInput[]
    NOT?: autre_tags_linkWhereInput | autre_tags_linkWhereInput[]
    id_autre?: IntFilter<"autre_tags_link"> | number
    id_tags?: IntFilter<"autre_tags_link"> | number
    autre?: XOR<AutreScalarRelationFilter, autreWhereInput>
    autre_tags?: XOR<Autre_tagsScalarRelationFilter, autre_tagsWhereInput>
  }

  export type autre_tags_linkOrderByWithRelationInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
    autre?: autreOrderByWithRelationInput
    autre_tags?: autre_tagsOrderByWithRelationInput
  }

  export type autre_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_autre_id_tags?: autre_tags_linkId_autreId_tagsCompoundUniqueInput
    AND?: autre_tags_linkWhereInput | autre_tags_linkWhereInput[]
    OR?: autre_tags_linkWhereInput[]
    NOT?: autre_tags_linkWhereInput | autre_tags_linkWhereInput[]
    id_autre?: IntFilter<"autre_tags_link"> | number
    id_tags?: IntFilter<"autre_tags_link"> | number
    autre?: XOR<AutreScalarRelationFilter, autreWhereInput>
    autre_tags?: XOR<Autre_tagsScalarRelationFilter, autre_tagsWhereInput>
  }, "id_autre_id_tags">

  export type autre_tags_linkOrderByWithAggregationInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
    _count?: autre_tags_linkCountOrderByAggregateInput
    _avg?: autre_tags_linkAvgOrderByAggregateInput
    _max?: autre_tags_linkMaxOrderByAggregateInput
    _min?: autre_tags_linkMinOrderByAggregateInput
    _sum?: autre_tags_linkSumOrderByAggregateInput
  }

  export type autre_tags_linkScalarWhereWithAggregatesInput = {
    AND?: autre_tags_linkScalarWhereWithAggregatesInput | autre_tags_linkScalarWhereWithAggregatesInput[]
    OR?: autre_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: autre_tags_linkScalarWhereWithAggregatesInput | autre_tags_linkScalarWhereWithAggregatesInput[]
    id_autre?: IntWithAggregatesFilter<"autre_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"autre_tags_link"> | number
  }

  export type experiencesWhereInput = {
    AND?: experiencesWhereInput | experiencesWhereInput[]
    OR?: experiencesWhereInput[]
    NOT?: experiencesWhereInput | experiencesWhereInput[]
    id_exp?: IntFilter<"experiences"> | number
    date?: DateTimeFilter<"experiences"> | Date | string
    titre?: StringFilter<"experiences"> | string
    description?: StringFilter<"experiences"> | string
    url_img?: StringFilter<"experiences"> | string
    position_img?: StringFilter<"experiences"> | string
    afficher?: BoolFilter<"experiences"> | boolean
  }

  export type experiencesOrderByWithRelationInput = {
    id_exp?: SortOrder
    date?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    url_img?: SortOrder
    position_img?: SortOrder
    afficher?: SortOrder
    _relevance?: experiencesOrderByRelevanceInput
  }

  export type experiencesWhereUniqueInput = Prisma.AtLeast<{
    id_exp?: number
    AND?: experiencesWhereInput | experiencesWhereInput[]
    OR?: experiencesWhereInput[]
    NOT?: experiencesWhereInput | experiencesWhereInput[]
    date?: DateTimeFilter<"experiences"> | Date | string
    titre?: StringFilter<"experiences"> | string
    description?: StringFilter<"experiences"> | string
    url_img?: StringFilter<"experiences"> | string
    position_img?: StringFilter<"experiences"> | string
    afficher?: BoolFilter<"experiences"> | boolean
  }, "id_exp">

  export type experiencesOrderByWithAggregationInput = {
    id_exp?: SortOrder
    date?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    url_img?: SortOrder
    position_img?: SortOrder
    afficher?: SortOrder
    _count?: experiencesCountOrderByAggregateInput
    _avg?: experiencesAvgOrderByAggregateInput
    _max?: experiencesMaxOrderByAggregateInput
    _min?: experiencesMinOrderByAggregateInput
    _sum?: experiencesSumOrderByAggregateInput
  }

  export type experiencesScalarWhereWithAggregatesInput = {
    AND?: experiencesScalarWhereWithAggregatesInput | experiencesScalarWhereWithAggregatesInput[]
    OR?: experiencesScalarWhereWithAggregatesInput[]
    NOT?: experiencesScalarWhereWithAggregatesInput | experiencesScalarWhereWithAggregatesInput[]
    id_exp?: IntWithAggregatesFilter<"experiences"> | number
    date?: DateTimeWithAggregatesFilter<"experiences"> | Date | string
    titre?: StringWithAggregatesFilter<"experiences"> | string
    description?: StringWithAggregatesFilter<"experiences"> | string
    url_img?: StringWithAggregatesFilter<"experiences"> | string
    position_img?: StringWithAggregatesFilter<"experiences"> | string
    afficher?: BoolWithAggregatesFilter<"experiences"> | boolean
  }

  export type faqWhereInput = {
    AND?: faqWhereInput | faqWhereInput[]
    OR?: faqWhereInput[]
    NOT?: faqWhereInput | faqWhereInput[]
    id_faq?: IntFilter<"faq"> | number
    titre?: StringFilter<"faq"> | string
    contenu?: StringFilter<"faq"> | string
    afficher?: BoolFilter<"faq"> | boolean
  }

  export type faqOrderByWithRelationInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    afficher?: SortOrder
    _relevance?: faqOrderByRelevanceInput
  }

  export type faqWhereUniqueInput = Prisma.AtLeast<{
    id_faq?: number
    AND?: faqWhereInput | faqWhereInput[]
    OR?: faqWhereInput[]
    NOT?: faqWhereInput | faqWhereInput[]
    titre?: StringFilter<"faq"> | string
    contenu?: StringFilter<"faq"> | string
    afficher?: BoolFilter<"faq"> | boolean
  }, "id_faq">

  export type faqOrderByWithAggregationInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    afficher?: SortOrder
    _count?: faqCountOrderByAggregateInput
    _avg?: faqAvgOrderByAggregateInput
    _max?: faqMaxOrderByAggregateInput
    _min?: faqMinOrderByAggregateInput
    _sum?: faqSumOrderByAggregateInput
  }

  export type faqScalarWhereWithAggregatesInput = {
    AND?: faqScalarWhereWithAggregatesInput | faqScalarWhereWithAggregatesInput[]
    OR?: faqScalarWhereWithAggregatesInput[]
    NOT?: faqScalarWhereWithAggregatesInput | faqScalarWhereWithAggregatesInput[]
    id_faq?: IntWithAggregatesFilter<"faq"> | number
    titre?: StringWithAggregatesFilter<"faq"> | string
    contenu?: StringWithAggregatesFilter<"faq"> | string
    afficher?: BoolWithAggregatesFilter<"faq"> | boolean
  }

  export type photosWhereInput = {
    AND?: photosWhereInput | photosWhereInput[]
    OR?: photosWhereInput[]
    NOT?: photosWhereInput | photosWhereInput[]
    id_pho?: IntFilter<"photos"> | number
    lien_high?: StringFilter<"photos"> | string
    lien_low?: StringFilter<"photos"> | string
    largeur?: IntFilter<"photos"> | number
    hauteur?: IntFilter<"photos"> | number
    alt?: StringFilter<"photos"> | string
    date?: DateTimeFilter<"photos"> | Date | string
    afficher?: BoolFilter<"photos"> | boolean
    derniere_modification?: DateTimeFilter<"photos"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }

  export type photosOrderByWithRelationInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    photos_albums_link?: photos_albums_linkOrderByRelationAggregateInput
    photos_tags_link?: photos_tags_linkOrderByRelationAggregateInput
    photos_tags_recherche_link?: photos_tags_recherche_linkOrderByRelationAggregateInput
    _relevance?: photosOrderByRelevanceInput
  }

  export type photosWhereUniqueInput = Prisma.AtLeast<{
    id_pho?: number
    AND?: photosWhereInput | photosWhereInput[]
    OR?: photosWhereInput[]
    NOT?: photosWhereInput | photosWhereInput[]
    lien_high?: StringFilter<"photos"> | string
    lien_low?: StringFilter<"photos"> | string
    largeur?: IntFilter<"photos"> | number
    hauteur?: IntFilter<"photos"> | number
    alt?: StringFilter<"photos"> | string
    date?: DateTimeFilter<"photos"> | Date | string
    afficher?: BoolFilter<"photos"> | boolean
    derniere_modification?: DateTimeFilter<"photos"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }, "id_pho">

  export type photosOrderByWithAggregationInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: photosCountOrderByAggregateInput
    _avg?: photosAvgOrderByAggregateInput
    _max?: photosMaxOrderByAggregateInput
    _min?: photosMinOrderByAggregateInput
    _sum?: photosSumOrderByAggregateInput
  }

  export type photosScalarWhereWithAggregatesInput = {
    AND?: photosScalarWhereWithAggregatesInput | photosScalarWhereWithAggregatesInput[]
    OR?: photosScalarWhereWithAggregatesInput[]
    NOT?: photosScalarWhereWithAggregatesInput | photosScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos"> | number
    lien_high?: StringWithAggregatesFilter<"photos"> | string
    lien_low?: StringWithAggregatesFilter<"photos"> | string
    largeur?: IntWithAggregatesFilter<"photos"> | number
    hauteur?: IntWithAggregatesFilter<"photos"> | number
    alt?: StringWithAggregatesFilter<"photos"> | string
    date?: DateTimeWithAggregatesFilter<"photos"> | Date | string
    afficher?: BoolWithAggregatesFilter<"photos"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"photos"> | Date | string
  }

  export type photos_albumsWhereInput = {
    AND?: photos_albumsWhereInput | photos_albumsWhereInput[]
    OR?: photos_albumsWhereInput[]
    NOT?: photos_albumsWhereInput | photos_albumsWhereInput[]
    id_alb?: IntFilter<"photos_albums"> | number
    titre?: StringFilter<"photos_albums"> | string
    description?: StringFilter<"photos_albums"> | string
    date?: DateTimeFilter<"photos_albums"> | Date | string
    afficher?: BoolFilter<"photos_albums"> | boolean
    derniere_modification?: DateTimeFilter<"photos_albums"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
  }

  export type photos_albumsOrderByWithRelationInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    photos_albums_link?: photos_albums_linkOrderByRelationAggregateInput
    photos_albums_tags_link?: photos_albums_tags_linkOrderByRelationAggregateInput
    _relevance?: photos_albumsOrderByRelevanceInput
  }

  export type photos_albumsWhereUniqueInput = Prisma.AtLeast<{
    id_alb?: number
    AND?: photos_albumsWhereInput | photos_albumsWhereInput[]
    OR?: photos_albumsWhereInput[]
    NOT?: photos_albumsWhereInput | photos_albumsWhereInput[]
    titre?: StringFilter<"photos_albums"> | string
    description?: StringFilter<"photos_albums"> | string
    date?: DateTimeFilter<"photos_albums"> | Date | string
    afficher?: BoolFilter<"photos_albums"> | boolean
    derniere_modification?: DateTimeFilter<"photos_albums"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
  }, "id_alb">

  export type photos_albumsOrderByWithAggregationInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: photos_albumsCountOrderByAggregateInput
    _avg?: photos_albumsAvgOrderByAggregateInput
    _max?: photos_albumsMaxOrderByAggregateInput
    _min?: photos_albumsMinOrderByAggregateInput
    _sum?: photos_albumsSumOrderByAggregateInput
  }

  export type photos_albumsScalarWhereWithAggregatesInput = {
    AND?: photos_albumsScalarWhereWithAggregatesInput | photos_albumsScalarWhereWithAggregatesInput[]
    OR?: photos_albumsScalarWhereWithAggregatesInput[]
    NOT?: photos_albumsScalarWhereWithAggregatesInput | photos_albumsScalarWhereWithAggregatesInput[]
    id_alb?: IntWithAggregatesFilter<"photos_albums"> | number
    titre?: StringWithAggregatesFilter<"photos_albums"> | string
    description?: StringWithAggregatesFilter<"photos_albums"> | string
    date?: DateTimeWithAggregatesFilter<"photos_albums"> | Date | string
    afficher?: BoolWithAggregatesFilter<"photos_albums"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"photos_albums"> | Date | string
  }

  export type photos_albums_linkWhereInput = {
    AND?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    OR?: photos_albums_linkWhereInput[]
    NOT?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    id_pho?: IntFilter<"photos_albums_link"> | number
    id_alb?: IntFilter<"photos_albums_link"> | number
    position?: IntFilter<"photos_albums_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
  }

  export type photos_albums_linkOrderByWithRelationInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
    photos?: photosOrderByWithRelationInput
    photos_albums?: photos_albumsOrderByWithRelationInput
  }

  export type photos_albums_linkWhereUniqueInput = Prisma.AtLeast<{
    id_pho_id_alb?: photos_albums_linkId_phoId_albCompoundUniqueInput
    AND?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    OR?: photos_albums_linkWhereInput[]
    NOT?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    id_pho?: IntFilter<"photos_albums_link"> | number
    id_alb?: IntFilter<"photos_albums_link"> | number
    position?: IntFilter<"photos_albums_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
  }, "id_pho_id_alb">

  export type photos_albums_linkOrderByWithAggregationInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
    _count?: photos_albums_linkCountOrderByAggregateInput
    _avg?: photos_albums_linkAvgOrderByAggregateInput
    _max?: photos_albums_linkMaxOrderByAggregateInput
    _min?: photos_albums_linkMinOrderByAggregateInput
    _sum?: photos_albums_linkSumOrderByAggregateInput
  }

  export type photos_albums_linkScalarWhereWithAggregatesInput = {
    AND?: photos_albums_linkScalarWhereWithAggregatesInput | photos_albums_linkScalarWhereWithAggregatesInput[]
    OR?: photos_albums_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_albums_linkScalarWhereWithAggregatesInput | photos_albums_linkScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos_albums_link"> | number
    id_alb?: IntWithAggregatesFilter<"photos_albums_link"> | number
    position?: IntWithAggregatesFilter<"photos_albums_link"> | number
  }

  export type photos_experiencesWhereInput = {
    AND?: photos_experiencesWhereInput | photos_experiencesWhereInput[]
    OR?: photos_experiencesWhereInput[]
    NOT?: photos_experiencesWhereInput | photos_experiencesWhereInput[]
    id_photo?: IntFilter<"photos_experiences"> | number
    titre?: StringFilter<"photos_experiences"> | string
    url?: StringFilter<"photos_experiences"> | string
    date?: StringFilter<"photos_experiences"> | string
  }

  export type photos_experiencesOrderByWithRelationInput = {
    id_photo?: SortOrder
    titre?: SortOrder
    url?: SortOrder
    date?: SortOrder
    _relevance?: photos_experiencesOrderByRelevanceInput
  }

  export type photos_experiencesWhereUniqueInput = Prisma.AtLeast<{
    id_photo?: number
    AND?: photos_experiencesWhereInput | photos_experiencesWhereInput[]
    OR?: photos_experiencesWhereInput[]
    NOT?: photos_experiencesWhereInput | photos_experiencesWhereInput[]
    titre?: StringFilter<"photos_experiences"> | string
    url?: StringFilter<"photos_experiences"> | string
    date?: StringFilter<"photos_experiences"> | string
  }, "id_photo">

  export type photos_experiencesOrderByWithAggregationInput = {
    id_photo?: SortOrder
    titre?: SortOrder
    url?: SortOrder
    date?: SortOrder
    _count?: photos_experiencesCountOrderByAggregateInput
    _avg?: photos_experiencesAvgOrderByAggregateInput
    _max?: photos_experiencesMaxOrderByAggregateInput
    _min?: photos_experiencesMinOrderByAggregateInput
    _sum?: photos_experiencesSumOrderByAggregateInput
  }

  export type photos_experiencesScalarWhereWithAggregatesInput = {
    AND?: photos_experiencesScalarWhereWithAggregatesInput | photos_experiencesScalarWhereWithAggregatesInput[]
    OR?: photos_experiencesScalarWhereWithAggregatesInput[]
    NOT?: photos_experiencesScalarWhereWithAggregatesInput | photos_experiencesScalarWhereWithAggregatesInput[]
    id_photo?: IntWithAggregatesFilter<"photos_experiences"> | number
    titre?: StringWithAggregatesFilter<"photos_experiences"> | string
    url?: StringWithAggregatesFilter<"photos_experiences"> | string
    date?: StringWithAggregatesFilter<"photos_experiences"> | string
  }

  export type photos_tagsWhereInput = {
    AND?: photos_tagsWhereInput | photos_tagsWhereInput[]
    OR?: photos_tagsWhereInput[]
    NOT?: photos_tagsWhereInput | photos_tagsWhereInput[]
    id_tags?: IntFilter<"photos_tags"> | number
    titre?: StringFilter<"photos_tags"> | string
    important?: BoolFilter<"photos_tags"> | boolean
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
  }

  export type photos_tagsOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    photos_albums_tags_link?: photos_albums_tags_linkOrderByRelationAggregateInput
    photos_tags_link?: photos_tags_linkOrderByRelationAggregateInput
    _relevance?: photos_tagsOrderByRelevanceInput
  }

  export type photos_tagsWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: photos_tagsWhereInput | photos_tagsWhereInput[]
    OR?: photos_tagsWhereInput[]
    NOT?: photos_tagsWhereInput | photos_tagsWhereInput[]
    titre?: StringFilter<"photos_tags"> | string
    important?: BoolFilter<"photos_tags"> | boolean
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
  }, "id_tags">

  export type photos_tagsOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: photos_tagsCountOrderByAggregateInput
    _avg?: photos_tagsAvgOrderByAggregateInput
    _max?: photos_tagsMaxOrderByAggregateInput
    _min?: photos_tagsMinOrderByAggregateInput
    _sum?: photos_tagsSumOrderByAggregateInput
  }

  export type photos_tagsScalarWhereWithAggregatesInput = {
    AND?: photos_tagsScalarWhereWithAggregatesInput | photos_tagsScalarWhereWithAggregatesInput[]
    OR?: photos_tagsScalarWhereWithAggregatesInput[]
    NOT?: photos_tagsScalarWhereWithAggregatesInput | photos_tagsScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"photos_tags"> | number
    titre?: StringWithAggregatesFilter<"photos_tags"> | string
    important?: BoolWithAggregatesFilter<"photos_tags"> | boolean
  }

  export type photos_tags_linkWhereInput = {
    AND?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    OR?: photos_tags_linkWhereInput[]
    NOT?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_link"> | number
    id_tags?: IntFilter<"photos_tags_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }

  export type photos_tags_linkOrderByWithRelationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    photos?: photosOrderByWithRelationInput
    photos_tags?: photos_tagsOrderByWithRelationInput
  }

  export type photos_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_pho_id_tags?: photos_tags_linkId_phoId_tagsCompoundUniqueInput
    AND?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    OR?: photos_tags_linkWhereInput[]
    NOT?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_link"> | number
    id_tags?: IntFilter<"photos_tags_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }, "id_pho_id_tags">

  export type photos_tags_linkOrderByWithAggregationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    _count?: photos_tags_linkCountOrderByAggregateInput
    _avg?: photos_tags_linkAvgOrderByAggregateInput
    _max?: photos_tags_linkMaxOrderByAggregateInput
    _min?: photos_tags_linkMinOrderByAggregateInput
    _sum?: photos_tags_linkSumOrderByAggregateInput
  }

  export type photos_tags_linkScalarWhereWithAggregatesInput = {
    AND?: photos_tags_linkScalarWhereWithAggregatesInput | photos_tags_linkScalarWhereWithAggregatesInput[]
    OR?: photos_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_tags_linkScalarWhereWithAggregatesInput | photos_tags_linkScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"photos_tags_link"> | number
  }

  export type temoignagesWhereInput = {
    AND?: temoignagesWhereInput | temoignagesWhereInput[]
    OR?: temoignagesWhereInput[]
    NOT?: temoignagesWhereInput | temoignagesWhereInput[]
    id_tem?: IntFilter<"temoignages"> | number
    contenu?: StringFilter<"temoignages"> | string
    client?: StringFilter<"temoignages"> | string
    plateforme?: StringFilter<"temoignages"> | string
    date?: StringNullableFilter<"temoignages"> | string | null
    afficher?: BoolFilter<"temoignages"> | boolean
  }

  export type temoignagesOrderByWithRelationInput = {
    id_tem?: SortOrder
    contenu?: SortOrder
    client?: SortOrder
    plateforme?: SortOrder
    date?: SortOrderInput | SortOrder
    afficher?: SortOrder
    _relevance?: temoignagesOrderByRelevanceInput
  }

  export type temoignagesWhereUniqueInput = Prisma.AtLeast<{
    id_tem?: number
    AND?: temoignagesWhereInput | temoignagesWhereInput[]
    OR?: temoignagesWhereInput[]
    NOT?: temoignagesWhereInput | temoignagesWhereInput[]
    contenu?: StringFilter<"temoignages"> | string
    client?: StringFilter<"temoignages"> | string
    plateforme?: StringFilter<"temoignages"> | string
    date?: StringNullableFilter<"temoignages"> | string | null
    afficher?: BoolFilter<"temoignages"> | boolean
  }, "id_tem">

  export type temoignagesOrderByWithAggregationInput = {
    id_tem?: SortOrder
    contenu?: SortOrder
    client?: SortOrder
    plateforme?: SortOrder
    date?: SortOrderInput | SortOrder
    afficher?: SortOrder
    _count?: temoignagesCountOrderByAggregateInput
    _avg?: temoignagesAvgOrderByAggregateInput
    _max?: temoignagesMaxOrderByAggregateInput
    _min?: temoignagesMinOrderByAggregateInput
    _sum?: temoignagesSumOrderByAggregateInput
  }

  export type temoignagesScalarWhereWithAggregatesInput = {
    AND?: temoignagesScalarWhereWithAggregatesInput | temoignagesScalarWhereWithAggregatesInput[]
    OR?: temoignagesScalarWhereWithAggregatesInput[]
    NOT?: temoignagesScalarWhereWithAggregatesInput | temoignagesScalarWhereWithAggregatesInput[]
    id_tem?: IntWithAggregatesFilter<"temoignages"> | number
    contenu?: StringWithAggregatesFilter<"temoignages"> | string
    client?: StringWithAggregatesFilter<"temoignages"> | string
    plateforme?: StringWithAggregatesFilter<"temoignages"> | string
    date?: StringNullableWithAggregatesFilter<"temoignages"> | string | null
    afficher?: BoolWithAggregatesFilter<"temoignages"> | boolean
  }

  export type utilisateursWhereInput = {
    AND?: utilisateursWhereInput | utilisateursWhereInput[]
    OR?: utilisateursWhereInput[]
    NOT?: utilisateursWhereInput | utilisateursWhereInput[]
    id_user?: IntFilter<"utilisateurs"> | number
    img?: StringFilter<"utilisateurs"> | string
    email?: StringNullableFilter<"utilisateurs"> | string | null
    username?: StringFilter<"utilisateurs"> | string
    password?: StringFilter<"utilisateurs"> | string
    role?: StringFilter<"utilisateurs"> | string
  }

  export type utilisateursOrderByWithRelationInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _relevance?: utilisateursOrderByRelevanceInput
  }

  export type utilisateursWhereUniqueInput = Prisma.AtLeast<{
    id_user?: number
    AND?: utilisateursWhereInput | utilisateursWhereInput[]
    OR?: utilisateursWhereInput[]
    NOT?: utilisateursWhereInput | utilisateursWhereInput[]
    img?: StringFilter<"utilisateurs"> | string
    email?: StringNullableFilter<"utilisateurs"> | string | null
    username?: StringFilter<"utilisateurs"> | string
    password?: StringFilter<"utilisateurs"> | string
    role?: StringFilter<"utilisateurs"> | string
  }, "id_user">

  export type utilisateursOrderByWithAggregationInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: utilisateursCountOrderByAggregateInput
    _avg?: utilisateursAvgOrderByAggregateInput
    _max?: utilisateursMaxOrderByAggregateInput
    _min?: utilisateursMinOrderByAggregateInput
    _sum?: utilisateursSumOrderByAggregateInput
  }

  export type utilisateursScalarWhereWithAggregatesInput = {
    AND?: utilisateursScalarWhereWithAggregatesInput | utilisateursScalarWhereWithAggregatesInput[]
    OR?: utilisateursScalarWhereWithAggregatesInput[]
    NOT?: utilisateursScalarWhereWithAggregatesInput | utilisateursScalarWhereWithAggregatesInput[]
    id_user?: IntWithAggregatesFilter<"utilisateurs"> | number
    img?: StringWithAggregatesFilter<"utilisateurs"> | string
    email?: StringNullableWithAggregatesFilter<"utilisateurs"> | string | null
    username?: StringWithAggregatesFilter<"utilisateurs"> | string
    password?: StringWithAggregatesFilter<"utilisateurs"> | string
    role?: StringWithAggregatesFilter<"utilisateurs"> | string
  }

  export type videosWhereInput = {
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    id_vid?: IntFilter<"videos"> | number
    titre?: StringFilter<"videos"> | string
    description?: StringFilter<"videos"> | string
    tags?: StringFilter<"videos"> | string
    lien?: StringFilter<"videos"> | string
    date?: DateTimeFilter<"videos"> | Date | string
    media_webm?: StringFilter<"videos"> | string
    media_mp4?: StringFilter<"videos"> | string
    duree?: StringFilter<"videos"> | string
    afficher_competences?: StringFilter<"videos"> | string
    afficher?: BoolFilter<"videos"> | boolean
    derniere_modification?: DateTimeFilter<"videos"> | Date | string
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }

  export type videosOrderByWithRelationInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    media_webm?: SortOrder
    media_mp4?: SortOrder
    duree?: SortOrder
    afficher_competences?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    videos_tags_link?: videos_tags_linkOrderByRelationAggregateInput
    _relevance?: videosOrderByRelevanceInput
  }

  export type videosWhereUniqueInput = Prisma.AtLeast<{
    id_vid?: number
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    titre?: StringFilter<"videos"> | string
    description?: StringFilter<"videos"> | string
    tags?: StringFilter<"videos"> | string
    lien?: StringFilter<"videos"> | string
    date?: DateTimeFilter<"videos"> | Date | string
    media_webm?: StringFilter<"videos"> | string
    media_mp4?: StringFilter<"videos"> | string
    duree?: StringFilter<"videos"> | string
    afficher_competences?: StringFilter<"videos"> | string
    afficher?: BoolFilter<"videos"> | boolean
    derniere_modification?: DateTimeFilter<"videos"> | Date | string
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }, "id_vid">

  export type videosOrderByWithAggregationInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    media_webm?: SortOrder
    media_mp4?: SortOrder
    duree?: SortOrder
    afficher_competences?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: videosCountOrderByAggregateInput
    _avg?: videosAvgOrderByAggregateInput
    _max?: videosMaxOrderByAggregateInput
    _min?: videosMinOrderByAggregateInput
    _sum?: videosSumOrderByAggregateInput
  }

  export type videosScalarWhereWithAggregatesInput = {
    AND?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    OR?: videosScalarWhereWithAggregatesInput[]
    NOT?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    id_vid?: IntWithAggregatesFilter<"videos"> | number
    titre?: StringWithAggregatesFilter<"videos"> | string
    description?: StringWithAggregatesFilter<"videos"> | string
    tags?: StringWithAggregatesFilter<"videos"> | string
    lien?: StringWithAggregatesFilter<"videos"> | string
    date?: DateTimeWithAggregatesFilter<"videos"> | Date | string
    media_webm?: StringWithAggregatesFilter<"videos"> | string
    media_mp4?: StringWithAggregatesFilter<"videos"> | string
    duree?: StringWithAggregatesFilter<"videos"> | string
    afficher_competences?: StringWithAggregatesFilter<"videos"> | string
    afficher?: BoolWithAggregatesFilter<"videos"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"videos"> | Date | string
  }

  export type videos_tagsWhereInput = {
    AND?: videos_tagsWhereInput | videos_tagsWhereInput[]
    OR?: videos_tagsWhereInput[]
    NOT?: videos_tagsWhereInput | videos_tagsWhereInput[]
    id_tags?: IntFilter<"videos_tags"> | number
    titre?: StringFilter<"videos_tags"> | string
    important?: BoolFilter<"videos_tags"> | boolean
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }

  export type videos_tagsOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    videos_tags_link?: videos_tags_linkOrderByRelationAggregateInput
    _relevance?: videos_tagsOrderByRelevanceInput
  }

  export type videos_tagsWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: videos_tagsWhereInput | videos_tagsWhereInput[]
    OR?: videos_tagsWhereInput[]
    NOT?: videos_tagsWhereInput | videos_tagsWhereInput[]
    titre?: StringFilter<"videos_tags"> | string
    important?: BoolFilter<"videos_tags"> | boolean
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }, "id_tags">

  export type videos_tagsOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: videos_tagsCountOrderByAggregateInput
    _avg?: videos_tagsAvgOrderByAggregateInput
    _max?: videos_tagsMaxOrderByAggregateInput
    _min?: videos_tagsMinOrderByAggregateInput
    _sum?: videos_tagsSumOrderByAggregateInput
  }

  export type videos_tagsScalarWhereWithAggregatesInput = {
    AND?: videos_tagsScalarWhereWithAggregatesInput | videos_tagsScalarWhereWithAggregatesInput[]
    OR?: videos_tagsScalarWhereWithAggregatesInput[]
    NOT?: videos_tagsScalarWhereWithAggregatesInput | videos_tagsScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"videos_tags"> | number
    titre?: StringWithAggregatesFilter<"videos_tags"> | string
    important?: BoolWithAggregatesFilter<"videos_tags"> | boolean
  }

  export type videos_tags_linkWhereInput = {
    AND?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    OR?: videos_tags_linkWhereInput[]
    NOT?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    id_vid?: IntFilter<"videos_tags_link"> | number
    id_tags?: IntFilter<"videos_tags_link"> | number
    videos?: XOR<VideosScalarRelationFilter, videosWhereInput>
    videos_tags?: XOR<Videos_tagsScalarRelationFilter, videos_tagsWhereInput>
  }

  export type videos_tags_linkOrderByWithRelationInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
    videos?: videosOrderByWithRelationInput
    videos_tags?: videos_tagsOrderByWithRelationInput
  }

  export type videos_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_vid_id_tags?: videos_tags_linkId_vidId_tagsCompoundUniqueInput
    AND?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    OR?: videos_tags_linkWhereInput[]
    NOT?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    id_vid?: IntFilter<"videos_tags_link"> | number
    id_tags?: IntFilter<"videos_tags_link"> | number
    videos?: XOR<VideosScalarRelationFilter, videosWhereInput>
    videos_tags?: XOR<Videos_tagsScalarRelationFilter, videos_tagsWhereInput>
  }, "id_vid_id_tags">

  export type videos_tags_linkOrderByWithAggregationInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
    _count?: videos_tags_linkCountOrderByAggregateInput
    _avg?: videos_tags_linkAvgOrderByAggregateInput
    _max?: videos_tags_linkMaxOrderByAggregateInput
    _min?: videos_tags_linkMinOrderByAggregateInput
    _sum?: videos_tags_linkSumOrderByAggregateInput
  }

  export type videos_tags_linkScalarWhereWithAggregatesInput = {
    AND?: videos_tags_linkScalarWhereWithAggregatesInput | videos_tags_linkScalarWhereWithAggregatesInput[]
    OR?: videos_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: videos_tags_linkScalarWhereWithAggregatesInput | videos_tags_linkScalarWhereWithAggregatesInput[]
    id_vid?: IntWithAggregatesFilter<"videos_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"videos_tags_link"> | number
  }

  export type photos_tags_rechercheWhereInput = {
    AND?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    OR?: photos_tags_rechercheWhereInput[]
    NOT?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    id_tags?: IntFilter<"photos_tags_recherche"> | number
    titre?: StringFilter<"photos_tags_recherche"> | string
    important?: BoolFilter<"photos_tags_recherche"> | boolean
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }

  export type photos_tags_rechercheOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    photos_tags_recherche_link?: photos_tags_recherche_linkOrderByRelationAggregateInput
    _relevance?: photos_tags_rechercheOrderByRelevanceInput
  }

  export type photos_tags_rechercheWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    OR?: photos_tags_rechercheWhereInput[]
    NOT?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    titre?: StringFilter<"photos_tags_recherche"> | string
    important?: BoolFilter<"photos_tags_recherche"> | boolean
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }, "id_tags">

  export type photos_tags_rechercheOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: photos_tags_rechercheCountOrderByAggregateInput
    _avg?: photos_tags_rechercheAvgOrderByAggregateInput
    _max?: photos_tags_rechercheMaxOrderByAggregateInput
    _min?: photos_tags_rechercheMinOrderByAggregateInput
    _sum?: photos_tags_rechercheSumOrderByAggregateInput
  }

  export type photos_tags_rechercheScalarWhereWithAggregatesInput = {
    AND?: photos_tags_rechercheScalarWhereWithAggregatesInput | photos_tags_rechercheScalarWhereWithAggregatesInput[]
    OR?: photos_tags_rechercheScalarWhereWithAggregatesInput[]
    NOT?: photos_tags_rechercheScalarWhereWithAggregatesInput | photos_tags_rechercheScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"photos_tags_recherche"> | number
    titre?: StringWithAggregatesFilter<"photos_tags_recherche"> | string
    important?: BoolWithAggregatesFilter<"photos_tags_recherche"> | boolean
  }

  export type photos_tags_recherche_linkWhereInput = {
    AND?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    OR?: photos_tags_recherche_linkWhereInput[]
    NOT?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntFilter<"photos_tags_recherche_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags_recherche?: XOR<Photos_tags_rechercheScalarRelationFilter, photos_tags_rechercheWhereInput>
  }

  export type photos_tags_recherche_linkOrderByWithRelationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    photos?: photosOrderByWithRelationInput
    photos_tags_recherche?: photos_tags_rechercheOrderByWithRelationInput
  }

  export type photos_tags_recherche_linkWhereUniqueInput = Prisma.AtLeast<{
    id_pho_id_tags?: photos_tags_recherche_linkId_phoId_tagsCompoundUniqueInput
    AND?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    OR?: photos_tags_recherche_linkWhereInput[]
    NOT?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntFilter<"photos_tags_recherche_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags_recherche?: XOR<Photos_tags_rechercheScalarRelationFilter, photos_tags_rechercheWhereInput>
  }, "id_pho_id_tags">

  export type photos_tags_recherche_linkOrderByWithAggregationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    _count?: photos_tags_recherche_linkCountOrderByAggregateInput
    _avg?: photos_tags_recherche_linkAvgOrderByAggregateInput
    _max?: photos_tags_recherche_linkMaxOrderByAggregateInput
    _min?: photos_tags_recherche_linkMinOrderByAggregateInput
    _sum?: photos_tags_recherche_linkSumOrderByAggregateInput
  }

  export type photos_tags_recherche_linkScalarWhereWithAggregatesInput = {
    AND?: photos_tags_recherche_linkScalarWhereWithAggregatesInput | photos_tags_recherche_linkScalarWhereWithAggregatesInput[]
    OR?: photos_tags_recherche_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_tags_recherche_linkScalarWhereWithAggregatesInput | photos_tags_recherche_linkScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntWithAggregatesFilter<"photos_tags_recherche_link"> | number
  }

  export type photos_albums_tags_linkWhereInput = {
    AND?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    OR?: photos_albums_tags_linkWhereInput[]
    NOT?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    id_alb?: IntFilter<"photos_albums_tags_link"> | number
    id_tags?: IntFilter<"photos_albums_tags_link"> | number
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }

  export type photos_albums_tags_linkOrderByWithRelationInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
    photos_albums?: photos_albumsOrderByWithRelationInput
    photos_tags?: photos_tagsOrderByWithRelationInput
  }

  export type photos_albums_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_alb_id_tags?: photos_albums_tags_linkId_albId_tagsCompoundUniqueInput
    AND?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    OR?: photos_albums_tags_linkWhereInput[]
    NOT?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    id_alb?: IntFilter<"photos_albums_tags_link"> | number
    id_tags?: IntFilter<"photos_albums_tags_link"> | number
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }, "id_alb_id_tags">

  export type photos_albums_tags_linkOrderByWithAggregationInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
    _count?: photos_albums_tags_linkCountOrderByAggregateInput
    _avg?: photos_albums_tags_linkAvgOrderByAggregateInput
    _max?: photos_albums_tags_linkMaxOrderByAggregateInput
    _min?: photos_albums_tags_linkMinOrderByAggregateInput
    _sum?: photos_albums_tags_linkSumOrderByAggregateInput
  }

  export type photos_albums_tags_linkScalarWhereWithAggregatesInput = {
    AND?: photos_albums_tags_linkScalarWhereWithAggregatesInput | photos_albums_tags_linkScalarWhereWithAggregatesInput[]
    OR?: photos_albums_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_albums_tags_linkScalarWhereWithAggregatesInput | photos_albums_tags_linkScalarWhereWithAggregatesInput[]
    id_alb?: IntWithAggregatesFilter<"photos_albums_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"photos_albums_tags_link"> | number
  }

  export type accountWhereInput = {
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    id?: StringFilter<"account"> | string
    accountId?: StringFilter<"account"> | string
    providerId?: StringFilter<"account"> | string
    userId?: StringFilter<"account"> | string
    accessToken?: StringNullableFilter<"account"> | string | null
    refreshToken?: StringNullableFilter<"account"> | string | null
    idToken?: StringNullableFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    scope?: StringNullableFilter<"account"> | string | null
    password?: StringNullableFilter<"account"> | string | null
    createdAt?: DateTimeFilter<"account"> | Date | string
    updatedAt?: DateTimeFilter<"account"> | Date | string
  }

  export type accountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: accountOrderByRelevanceInput
  }

  export type accountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    accountId?: StringFilter<"account"> | string
    providerId?: StringFilter<"account"> | string
    userId?: StringFilter<"account"> | string
    accessToken?: StringNullableFilter<"account"> | string | null
    refreshToken?: StringNullableFilter<"account"> | string | null
    idToken?: StringNullableFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    scope?: StringNullableFilter<"account"> | string | null
    password?: StringNullableFilter<"account"> | string | null
    createdAt?: DateTimeFilter<"account"> | Date | string
    updatedAt?: DateTimeFilter<"account"> | Date | string
  }, "id">

  export type accountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: accountCountOrderByAggregateInput
    _max?: accountMaxOrderByAggregateInput
    _min?: accountMinOrderByAggregateInput
  }

  export type accountScalarWhereWithAggregatesInput = {
    AND?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    OR?: accountScalarWhereWithAggregatesInput[]
    NOT?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"account"> | string
    accountId?: StringWithAggregatesFilter<"account"> | string
    providerId?: StringWithAggregatesFilter<"account"> | string
    userId?: StringWithAggregatesFilter<"account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"account"> | string | null
    password?: StringNullableWithAggregatesFilter<"account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"account"> | Date | string
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    token?: StringFilter<"session"> | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    userId?: StringFilter<"session"> | string
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _relevance?: sessionOrderByRelevanceInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    userId?: StringFilter<"session"> | string
  }, "id" | "token">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    token?: StringWithAggregatesFilter<"session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"session"> | string | null
    userId?: StringWithAggregatesFilter<"session"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    image?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    image?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    emailVerified?: BoolWithAggregatesFilter<"user"> | boolean
    image?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type verificationWhereInput = {
    AND?: verificationWhereInput | verificationWhereInput[]
    OR?: verificationWhereInput[]
    NOT?: verificationWhereInput | verificationWhereInput[]
    id?: StringFilter<"verification"> | string
    identifier?: StringFilter<"verification"> | string
    value?: StringFilter<"verification"> | string
    expiresAt?: DateTimeFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"verification"> | Date | string | null
  }

  export type verificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: verificationOrderByRelevanceInput
  }

  export type verificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: verificationWhereInput | verificationWhereInput[]
    OR?: verificationWhereInput[]
    NOT?: verificationWhereInput | verificationWhereInput[]
    identifier?: StringFilter<"verification"> | string
    value?: StringFilter<"verification"> | string
    expiresAt?: DateTimeFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"verification"> | Date | string | null
  }, "id">

  export type verificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: verificationCountOrderByAggregateInput
    _max?: verificationMaxOrderByAggregateInput
    _min?: verificationMinOrderByAggregateInput
  }

  export type verificationScalarWhereWithAggregatesInput = {
    AND?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[]
    OR?: verificationScalarWhereWithAggregatesInput[]
    NOT?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"verification"> | string
    identifier?: StringWithAggregatesFilter<"verification"> | string
    value?: StringWithAggregatesFilter<"verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"verification"> | Date | string | null
  }

  export type autreCreateInput = {
    titre: string
    description: string
    miniature: string
    lien_github: string
    lien_figma: string
    lien_site: string
    categorie: string
    tags: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    autre_tags_link?: autre_tags_linkCreateNestedManyWithoutAutreInput
  }

  export type autreUncheckedCreateInput = {
    id_autre?: number
    titre: string
    description: string
    miniature: string
    lien_github: string
    lien_figma: string
    lien_site: string
    categorie: string
    tags: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    autre_tags_link?: autre_tags_linkUncheckedCreateNestedManyWithoutAutreInput
  }

  export type autreUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    miniature?: StringFieldUpdateOperationsInput | string
    lien_github?: StringFieldUpdateOperationsInput | string
    lien_figma?: StringFieldUpdateOperationsInput | string
    lien_site?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    autre_tags_link?: autre_tags_linkUpdateManyWithoutAutreNestedInput
  }

  export type autreUncheckedUpdateInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    miniature?: StringFieldUpdateOperationsInput | string
    lien_github?: StringFieldUpdateOperationsInput | string
    lien_figma?: StringFieldUpdateOperationsInput | string
    lien_site?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    autre_tags_link?: autre_tags_linkUncheckedUpdateManyWithoutAutreNestedInput
  }

  export type autreCreateManyInput = {
    id_autre?: number
    titre: string
    description: string
    miniature: string
    lien_github: string
    lien_figma: string
    lien_site: string
    categorie: string
    tags: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type autreUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    miniature?: StringFieldUpdateOperationsInput | string
    lien_github?: StringFieldUpdateOperationsInput | string
    lien_figma?: StringFieldUpdateOperationsInput | string
    lien_site?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type autreUncheckedUpdateManyInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    miniature?: StringFieldUpdateOperationsInput | string
    lien_github?: StringFieldUpdateOperationsInput | string
    lien_figma?: StringFieldUpdateOperationsInput | string
    lien_site?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type autre_tagsCreateInput = {
    titre: string
    important: boolean
    autre_tags_link?: autre_tags_linkCreateNestedManyWithoutAutre_tagsInput
  }

  export type autre_tagsUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    autre_tags_link?: autre_tags_linkUncheckedCreateNestedManyWithoutAutre_tagsInput
  }

  export type autre_tagsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    autre_tags_link?: autre_tags_linkUpdateManyWithoutAutre_tagsNestedInput
  }

  export type autre_tagsUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    autre_tags_link?: autre_tags_linkUncheckedUpdateManyWithoutAutre_tagsNestedInput
  }

  export type autre_tagsCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type autre_tagsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type autre_tagsUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type autre_tags_linkCreateInput = {
    autre: autreCreateNestedOneWithoutAutre_tags_linkInput
    autre_tags: autre_tagsCreateNestedOneWithoutAutre_tags_linkInput
  }

  export type autre_tags_linkUncheckedCreateInput = {
    id_autre: number
    id_tags: number
  }

  export type autre_tags_linkUpdateInput = {
    autre?: autreUpdateOneRequiredWithoutAutre_tags_linkNestedInput
    autre_tags?: autre_tagsUpdateOneRequiredWithoutAutre_tags_linkNestedInput
  }

  export type autre_tags_linkUncheckedUpdateInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type autre_tags_linkCreateManyInput = {
    id_autre: number
    id_tags: number
  }

  export type autre_tags_linkUpdateManyMutationInput = {

  }

  export type autre_tags_linkUncheckedUpdateManyInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type experiencesCreateInput = {
    date: Date | string
    titre: string
    description: string
    url_img: string
    position_img: string
    afficher: boolean
  }

  export type experiencesUncheckedCreateInput = {
    id_exp?: number
    date: Date | string
    titre: string
    description: string
    url_img: string
    position_img: string
    afficher: boolean
  }

  export type experiencesUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url_img?: StringFieldUpdateOperationsInput | string
    position_img?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type experiencesUncheckedUpdateInput = {
    id_exp?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url_img?: StringFieldUpdateOperationsInput | string
    position_img?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type experiencesCreateManyInput = {
    id_exp?: number
    date: Date | string
    titre: string
    description: string
    url_img: string
    position_img: string
    afficher: boolean
  }

  export type experiencesUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url_img?: StringFieldUpdateOperationsInput | string
    position_img?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type experiencesUncheckedUpdateManyInput = {
    id_exp?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url_img?: StringFieldUpdateOperationsInput | string
    position_img?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faqCreateInput = {
    titre: string
    contenu: string
    afficher: boolean
  }

  export type faqUncheckedCreateInput = {
    id_faq?: number
    titre: string
    contenu: string
    afficher: boolean
  }

  export type faqUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faqUncheckedUpdateInput = {
    id_faq?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faqCreateManyInput = {
    id_faq?: number
    titre: string
    contenu: string
    afficher: boolean
  }

  export type faqUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type faqUncheckedUpdateManyInput = {
    id_faq?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photosCreateInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosUpdateInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photosCreateManyInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type photosUpdateManyMutationInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photosUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photos_albumsCreateInput = {
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotos_albumsInput
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUncheckedCreateInput = {
    id_alb?: number
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotos_albumsNestedInput
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsUncheckedUpdateInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsCreateManyInput = {
    id_alb?: number
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type photos_albumsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photos_albumsUncheckedUpdateManyInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photos_albums_linkCreateInput = {
    position?: number
    photos: photosCreateNestedOneWithoutPhotos_albums_linkInput
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_linkInput
  }

  export type photos_albums_linkUncheckedCreateInput = {
    id_pho: number
    id_alb: number
    position?: number
  }

  export type photos_albums_linkUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    photos?: photosUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
  }

  export type photos_albums_linkUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkCreateManyInput = {
    id_pho: number
    id_alb: number
    position?: number
  }

  export type photos_albums_linkUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_experiencesCreateInput = {
    titre: string
    url: string
    date: string
  }

  export type photos_experiencesUncheckedCreateInput = {
    id_photo?: number
    titre: string
    url: string
    date: string
  }

  export type photos_experiencesUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type photos_experiencesUncheckedUpdateInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type photos_experiencesCreateManyInput = {
    id_photo?: number
    titre: string
    url: string
    date: string
  }

  export type photos_experiencesUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type photos_experiencesUncheckedUpdateManyInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type photos_tagsCreateInput = {
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_tagsInput
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type photos_tagsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tagsUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_linkCreateInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_linkInput
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_tags_linkInput
  }

  export type photos_tags_linkUncheckedCreateInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_linkUpdateInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
  }

  export type photos_tags_linkUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkCreateManyInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_linkUpdateManyMutationInput = {

  }

  export type photos_tags_linkUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type temoignagesCreateInput = {
    contenu: string
    client: string
    plateforme: string
    date?: string | null
    afficher: boolean
  }

  export type temoignagesUncheckedCreateInput = {
    id_tem?: number
    contenu: string
    client: string
    plateforme: string
    date?: string | null
    afficher: boolean
  }

  export type temoignagesUpdateInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    plateforme?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type temoignagesUncheckedUpdateInput = {
    id_tem?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    plateforme?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type temoignagesCreateManyInput = {
    id_tem?: number
    contenu: string
    client: string
    plateforme: string
    date?: string | null
    afficher: boolean
  }

  export type temoignagesUpdateManyMutationInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    plateforme?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type temoignagesUncheckedUpdateManyInput = {
    id_tem?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    plateforme?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type utilisateursCreateInput = {
    img: string
    email?: string | null
    username: string
    password: string
    role: string
  }

  export type utilisateursUncheckedCreateInput = {
    id_user?: number
    img: string
    email?: string | null
    username: string
    password: string
    role: string
  }

  export type utilisateursUpdateInput = {
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type utilisateursUncheckedUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type utilisateursCreateManyInput = {
    id_user?: number
    img: string
    email?: string | null
    username: string
    password: string
    role: string
  }

  export type utilisateursUpdateManyMutationInput = {
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type utilisateursUncheckedUpdateManyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type videosCreateInput = {
    titre: string
    description: string
    tags: string
    lien: string
    date: Date | string
    media_webm: string
    media_mp4: string
    duree: string
    afficher_competences: string
    afficher: boolean
    derniere_modification: Date | string
    videos_tags_link?: videos_tags_linkCreateNestedManyWithoutVideosInput
  }

  export type videosUncheckedCreateInput = {
    id_vid?: number
    titre: string
    description: string
    tags: string
    lien: string
    date: Date | string
    media_webm: string
    media_mp4: string
    duree: string
    afficher_competences: string
    afficher: boolean
    derniere_modification: Date | string
    videos_tags_link?: videos_tags_linkUncheckedCreateNestedManyWithoutVideosInput
  }

  export type videosUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    media_webm?: StringFieldUpdateOperationsInput | string
    media_mp4?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    afficher_competences?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    videos_tags_link?: videos_tags_linkUpdateManyWithoutVideosNestedInput
  }

  export type videosUncheckedUpdateInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    media_webm?: StringFieldUpdateOperationsInput | string
    media_mp4?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    afficher_competences?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    videos_tags_link?: videos_tags_linkUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type videosCreateManyInput = {
    id_vid?: number
    titre: string
    description: string
    tags: string
    lien: string
    date: Date | string
    media_webm: string
    media_mp4: string
    duree: string
    afficher_competences: string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type videosUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    media_webm?: StringFieldUpdateOperationsInput | string
    media_mp4?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    afficher_competences?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videosUncheckedUpdateManyInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    media_webm?: StringFieldUpdateOperationsInput | string
    media_mp4?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    afficher_competences?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videos_tagsCreateInput = {
    titre: string
    important: boolean
    videos_tags_link?: videos_tags_linkCreateNestedManyWithoutVideos_tagsInput
  }

  export type videos_tagsUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    videos_tags_link?: videos_tags_linkUncheckedCreateNestedManyWithoutVideos_tagsInput
  }

  export type videos_tagsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    videos_tags_link?: videos_tags_linkUpdateManyWithoutVideos_tagsNestedInput
  }

  export type videos_tagsUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    videos_tags_link?: videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsNestedInput
  }

  export type videos_tagsCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type videos_tagsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tagsUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tags_linkCreateInput = {
    videos: videosCreateNestedOneWithoutVideos_tags_linkInput
    videos_tags: videos_tagsCreateNestedOneWithoutVideos_tags_linkInput
  }

  export type videos_tags_linkUncheckedCreateInput = {
    id_vid: number
    id_tags: number
  }

  export type videos_tags_linkUpdateInput = {
    videos?: videosUpdateOneRequiredWithoutVideos_tags_linkNestedInput
    videos_tags?: videos_tagsUpdateOneRequiredWithoutVideos_tags_linkNestedInput
  }

  export type videos_tags_linkUncheckedUpdateInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkCreateManyInput = {
    id_vid: number
    id_tags: number
  }

  export type videos_tags_linkUpdateManyMutationInput = {

  }

  export type videos_tags_linkUncheckedUpdateManyInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_rechercheCreateInput = {
    titre: string
    important: boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotos_tags_rechercheInput
  }

  export type photos_tags_rechercheUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotos_tags_rechercheInput
  }

  export type photos_tags_rechercheUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotos_tags_rechercheNestedInput
  }

  export type photos_tags_rechercheUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheNestedInput
  }

  export type photos_tags_rechercheCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type photos_tags_rechercheUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_rechercheUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_recherche_linkCreateInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_recherche_linkInput
    photos_tags_recherche: photos_tags_rechercheCreateNestedOneWithoutPhotos_tags_recherche_linkInput
  }

  export type photos_tags_recherche_linkUncheckedCreateInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_recherche_linkUpdateInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
    photos_tags_recherche?: photos_tags_rechercheUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
  }

  export type photos_tags_recherche_linkUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkCreateManyInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_recherche_linkUpdateManyMutationInput = {

  }

  export type photos_tags_recherche_linkUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkCreateInput = {
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_tags_linkInput
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_albums_tags_linkInput
  }

  export type photos_albums_tags_linkUncheckedCreateInput = {
    id_alb: number
    id_tags: number
  }

  export type photos_albums_tags_linkUpdateInput = {
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
  }

  export type photos_albums_tags_linkUncheckedUpdateInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkCreateManyInput = {
    id_alb: number
    id_tags: number
  }

  export type photos_albums_tags_linkUpdateManyMutationInput = {

  }

  export type photos_albums_tags_linkUncheckedUpdateManyInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type accountCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type sessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Autre_tags_linkListRelationFilter = {
    every?: autre_tags_linkWhereInput
    some?: autre_tags_linkWhereInput
    none?: autre_tags_linkWhereInput
  }

  export type autre_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type autreOrderByRelevanceInput = {
    fields: autreOrderByRelevanceFieldEnum | autreOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type autreCountOrderByAggregateInput = {
    id_autre?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    miniature?: SortOrder
    lien_github?: SortOrder
    lien_figma?: SortOrder
    lien_site?: SortOrder
    categorie?: SortOrder
    tags?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type autreAvgOrderByAggregateInput = {
    id_autre?: SortOrder
  }

  export type autreMaxOrderByAggregateInput = {
    id_autre?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    miniature?: SortOrder
    lien_github?: SortOrder
    lien_figma?: SortOrder
    lien_site?: SortOrder
    categorie?: SortOrder
    tags?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type autreMinOrderByAggregateInput = {
    id_autre?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    miniature?: SortOrder
    lien_github?: SortOrder
    lien_figma?: SortOrder
    lien_site?: SortOrder
    categorie?: SortOrder
    tags?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type autreSumOrderByAggregateInput = {
    id_autre?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type autre_tagsOrderByRelevanceInput = {
    fields: autre_tagsOrderByRelevanceFieldEnum | autre_tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type autre_tagsCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type autre_tagsAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type autre_tagsMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type autre_tagsMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type autre_tagsSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type AutreScalarRelationFilter = {
    is?: autreWhereInput
    isNot?: autreWhereInput
  }

  export type Autre_tagsScalarRelationFilter = {
    is?: autre_tagsWhereInput
    isNot?: autre_tagsWhereInput
  }

  export type autre_tags_linkId_autreId_tagsCompoundUniqueInput = {
    id_autre: number
    id_tags: number
  }

  export type autre_tags_linkCountOrderByAggregateInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
  }

  export type autre_tags_linkAvgOrderByAggregateInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
  }

  export type autre_tags_linkMaxOrderByAggregateInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
  }

  export type autre_tags_linkMinOrderByAggregateInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
  }

  export type autre_tags_linkSumOrderByAggregateInput = {
    id_autre?: SortOrder
    id_tags?: SortOrder
  }

  export type experiencesOrderByRelevanceInput = {
    fields: experiencesOrderByRelevanceFieldEnum | experiencesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type experiencesCountOrderByAggregateInput = {
    id_exp?: SortOrder
    date?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    url_img?: SortOrder
    position_img?: SortOrder
    afficher?: SortOrder
  }

  export type experiencesAvgOrderByAggregateInput = {
    id_exp?: SortOrder
  }

  export type experiencesMaxOrderByAggregateInput = {
    id_exp?: SortOrder
    date?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    url_img?: SortOrder
    position_img?: SortOrder
    afficher?: SortOrder
  }

  export type experiencesMinOrderByAggregateInput = {
    id_exp?: SortOrder
    date?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    url_img?: SortOrder
    position_img?: SortOrder
    afficher?: SortOrder
  }

  export type experiencesSumOrderByAggregateInput = {
    id_exp?: SortOrder
  }

  export type faqOrderByRelevanceInput = {
    fields: faqOrderByRelevanceFieldEnum | faqOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type faqCountOrderByAggregateInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    afficher?: SortOrder
  }

  export type faqAvgOrderByAggregateInput = {
    id_faq?: SortOrder
  }

  export type faqMaxOrderByAggregateInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    afficher?: SortOrder
  }

  export type faqMinOrderByAggregateInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    afficher?: SortOrder
  }

  export type faqSumOrderByAggregateInput = {
    id_faq?: SortOrder
  }

  export type Photos_albums_linkListRelationFilter = {
    every?: photos_albums_linkWhereInput
    some?: photos_albums_linkWhereInput
    none?: photos_albums_linkWhereInput
  }

  export type Photos_tags_linkListRelationFilter = {
    every?: photos_tags_linkWhereInput
    some?: photos_tags_linkWhereInput
    none?: photos_tags_linkWhereInput
  }

  export type Photos_tags_recherche_linkListRelationFilter = {
    every?: photos_tags_recherche_linkWhereInput
    some?: photos_tags_recherche_linkWhereInput
    none?: photos_tags_recherche_linkWhereInput
  }

  export type photos_albums_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photos_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photos_tags_recherche_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photosOrderByRelevanceInput = {
    fields: photosOrderByRelevanceFieldEnum | photosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photosCountOrderByAggregateInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photosAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
  }

  export type photosMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photosMinOrderByAggregateInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photosSumOrderByAggregateInput = {
    id_pho?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
  }

  export type Photos_albums_tags_linkListRelationFilter = {
    every?: photos_albums_tags_linkWhereInput
    some?: photos_albums_tags_linkWhereInput
    none?: photos_albums_tags_linkWhereInput
  }

  export type photos_albums_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photos_albumsOrderByRelevanceInput = {
    fields: photos_albumsOrderByRelevanceFieldEnum | photos_albumsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_albumsCountOrderByAggregateInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photos_albumsAvgOrderByAggregateInput = {
    id_alb?: SortOrder
  }

  export type photos_albumsMaxOrderByAggregateInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photos_albumsMinOrderByAggregateInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photos_albumsSumOrderByAggregateInput = {
    id_alb?: SortOrder
  }

  export type PhotosScalarRelationFilter = {
    is?: photosWhereInput
    isNot?: photosWhereInput
  }

  export type Photos_albumsScalarRelationFilter = {
    is?: photos_albumsWhereInput
    isNot?: photos_albumsWhereInput
  }

  export type photos_albums_linkId_phoId_albCompoundUniqueInput = {
    id_pho: number
    id_alb: number
  }

  export type photos_albums_linkCountOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkMinOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkSumOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_experiencesOrderByRelevanceInput = {
    fields: photos_experiencesOrderByRelevanceFieldEnum | photos_experiencesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_experiencesCountOrderByAggregateInput = {
    id_photo?: SortOrder
    titre?: SortOrder
    url?: SortOrder
    date?: SortOrder
  }

  export type photos_experiencesAvgOrderByAggregateInput = {
    id_photo?: SortOrder
  }

  export type photos_experiencesMaxOrderByAggregateInput = {
    id_photo?: SortOrder
    titre?: SortOrder
    url?: SortOrder
    date?: SortOrder
  }

  export type photos_experiencesMinOrderByAggregateInput = {
    id_photo?: SortOrder
    titre?: SortOrder
    url?: SortOrder
    date?: SortOrder
  }

  export type photos_experiencesSumOrderByAggregateInput = {
    id_photo?: SortOrder
  }

  export type photos_tagsOrderByRelevanceInput = {
    fields: photos_tagsOrderByRelevanceFieldEnum | photos_tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_tagsCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tagsAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type photos_tagsMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tagsMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tagsSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type Photos_tagsScalarRelationFilter = {
    is?: photos_tagsWhereInput
    isNot?: photos_tagsWhereInput
  }

  export type photos_tags_linkId_phoId_tagsCompoundUniqueInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_linkCountOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkMinOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkSumOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type temoignagesOrderByRelevanceInput = {
    fields: temoignagesOrderByRelevanceFieldEnum | temoignagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type temoignagesCountOrderByAggregateInput = {
    id_tem?: SortOrder
    contenu?: SortOrder
    client?: SortOrder
    plateforme?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
  }

  export type temoignagesAvgOrderByAggregateInput = {
    id_tem?: SortOrder
  }

  export type temoignagesMaxOrderByAggregateInput = {
    id_tem?: SortOrder
    contenu?: SortOrder
    client?: SortOrder
    plateforme?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
  }

  export type temoignagesMinOrderByAggregateInput = {
    id_tem?: SortOrder
    contenu?: SortOrder
    client?: SortOrder
    plateforme?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
  }

  export type temoignagesSumOrderByAggregateInput = {
    id_tem?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type utilisateursOrderByRelevanceInput = {
    fields: utilisateursOrderByRelevanceFieldEnum | utilisateursOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type utilisateursCountOrderByAggregateInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type utilisateursAvgOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type utilisateursMaxOrderByAggregateInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type utilisateursMinOrderByAggregateInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type utilisateursSumOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type Videos_tags_linkListRelationFilter = {
    every?: videos_tags_linkWhereInput
    some?: videos_tags_linkWhereInput
    none?: videos_tags_linkWhereInput
  }

  export type videos_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type videosOrderByRelevanceInput = {
    fields: videosOrderByRelevanceFieldEnum | videosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type videosCountOrderByAggregateInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    media_webm?: SortOrder
    media_mp4?: SortOrder
    duree?: SortOrder
    afficher_competences?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type videosAvgOrderByAggregateInput = {
    id_vid?: SortOrder
  }

  export type videosMaxOrderByAggregateInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    media_webm?: SortOrder
    media_mp4?: SortOrder
    duree?: SortOrder
    afficher_competences?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type videosMinOrderByAggregateInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    media_webm?: SortOrder
    media_mp4?: SortOrder
    duree?: SortOrder
    afficher_competences?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type videosSumOrderByAggregateInput = {
    id_vid?: SortOrder
  }

  export type videos_tagsOrderByRelevanceInput = {
    fields: videos_tagsOrderByRelevanceFieldEnum | videos_tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type videos_tagsCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type videos_tagsAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type videos_tagsMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type videos_tagsMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type videos_tagsSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type VideosScalarRelationFilter = {
    is?: videosWhereInput
    isNot?: videosWhereInput
  }

  export type Videos_tagsScalarRelationFilter = {
    is?: videos_tagsWhereInput
    isNot?: videos_tagsWhereInput
  }

  export type videos_tags_linkId_vidId_tagsCompoundUniqueInput = {
    id_vid: number
    id_tags: number
  }

  export type videos_tags_linkCountOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkAvgOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkMaxOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkMinOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkSumOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_rechercheOrderByRelevanceInput = {
    fields: photos_tags_rechercheOrderByRelevanceFieldEnum | photos_tags_rechercheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_tags_rechercheCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tags_rechercheAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type photos_tags_rechercheMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tags_rechercheMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tags_rechercheSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type Photos_tags_rechercheScalarRelationFilter = {
    is?: photos_tags_rechercheWhereInput
    isNot?: photos_tags_rechercheWhereInput
  }

  export type photos_tags_recherche_linkId_phoId_tagsCompoundUniqueInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_recherche_linkCountOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkMinOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkSumOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkId_albId_tagsCompoundUniqueInput = {
    id_alb: number
    id_tags: number
  }

  export type photos_albums_tags_linkCountOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkAvgOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkMaxOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkMinOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkSumOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type accountOrderByRelevanceInput = {
    fields: accountOrderByRelevanceFieldEnum | accountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type sessionOrderByRelevanceInput = {
    fields: sessionOrderByRelevanceFieldEnum | sessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationOrderByRelevanceInput = {
    fields: verificationOrderByRelevanceFieldEnum | verificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type verificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type autre_tags_linkCreateNestedManyWithoutAutreInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutreInput, autre_tags_linkUncheckedCreateWithoutAutreInput> | autre_tags_linkCreateWithoutAutreInput[] | autre_tags_linkUncheckedCreateWithoutAutreInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutreInput | autre_tags_linkCreateOrConnectWithoutAutreInput[]
    createMany?: autre_tags_linkCreateManyAutreInputEnvelope
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
  }

  export type autre_tags_linkUncheckedCreateNestedManyWithoutAutreInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutreInput, autre_tags_linkUncheckedCreateWithoutAutreInput> | autre_tags_linkCreateWithoutAutreInput[] | autre_tags_linkUncheckedCreateWithoutAutreInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutreInput | autre_tags_linkCreateOrConnectWithoutAutreInput[]
    createMany?: autre_tags_linkCreateManyAutreInputEnvelope
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type autre_tags_linkUpdateManyWithoutAutreNestedInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutreInput, autre_tags_linkUncheckedCreateWithoutAutreInput> | autre_tags_linkCreateWithoutAutreInput[] | autre_tags_linkUncheckedCreateWithoutAutreInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutreInput | autre_tags_linkCreateOrConnectWithoutAutreInput[]
    upsert?: autre_tags_linkUpsertWithWhereUniqueWithoutAutreInput | autre_tags_linkUpsertWithWhereUniqueWithoutAutreInput[]
    createMany?: autre_tags_linkCreateManyAutreInputEnvelope
    set?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    disconnect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    delete?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    update?: autre_tags_linkUpdateWithWhereUniqueWithoutAutreInput | autre_tags_linkUpdateWithWhereUniqueWithoutAutreInput[]
    updateMany?: autre_tags_linkUpdateManyWithWhereWithoutAutreInput | autre_tags_linkUpdateManyWithWhereWithoutAutreInput[]
    deleteMany?: autre_tags_linkScalarWhereInput | autre_tags_linkScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type autre_tags_linkUncheckedUpdateManyWithoutAutreNestedInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutreInput, autre_tags_linkUncheckedCreateWithoutAutreInput> | autre_tags_linkCreateWithoutAutreInput[] | autre_tags_linkUncheckedCreateWithoutAutreInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutreInput | autre_tags_linkCreateOrConnectWithoutAutreInput[]
    upsert?: autre_tags_linkUpsertWithWhereUniqueWithoutAutreInput | autre_tags_linkUpsertWithWhereUniqueWithoutAutreInput[]
    createMany?: autre_tags_linkCreateManyAutreInputEnvelope
    set?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    disconnect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    delete?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    update?: autre_tags_linkUpdateWithWhereUniqueWithoutAutreInput | autre_tags_linkUpdateWithWhereUniqueWithoutAutreInput[]
    updateMany?: autre_tags_linkUpdateManyWithWhereWithoutAutreInput | autre_tags_linkUpdateManyWithWhereWithoutAutreInput[]
    deleteMany?: autre_tags_linkScalarWhereInput | autre_tags_linkScalarWhereInput[]
  }

  export type autre_tags_linkCreateNestedManyWithoutAutre_tagsInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutre_tagsInput, autre_tags_linkUncheckedCreateWithoutAutre_tagsInput> | autre_tags_linkCreateWithoutAutre_tagsInput[] | autre_tags_linkUncheckedCreateWithoutAutre_tagsInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutre_tagsInput | autre_tags_linkCreateOrConnectWithoutAutre_tagsInput[]
    createMany?: autre_tags_linkCreateManyAutre_tagsInputEnvelope
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
  }

  export type autre_tags_linkUncheckedCreateNestedManyWithoutAutre_tagsInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutre_tagsInput, autre_tags_linkUncheckedCreateWithoutAutre_tagsInput> | autre_tags_linkCreateWithoutAutre_tagsInput[] | autre_tags_linkUncheckedCreateWithoutAutre_tagsInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutre_tagsInput | autre_tags_linkCreateOrConnectWithoutAutre_tagsInput[]
    createMany?: autre_tags_linkCreateManyAutre_tagsInputEnvelope
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
  }

  export type autre_tags_linkUpdateManyWithoutAutre_tagsNestedInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutre_tagsInput, autre_tags_linkUncheckedCreateWithoutAutre_tagsInput> | autre_tags_linkCreateWithoutAutre_tagsInput[] | autre_tags_linkUncheckedCreateWithoutAutre_tagsInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutre_tagsInput | autre_tags_linkCreateOrConnectWithoutAutre_tagsInput[]
    upsert?: autre_tags_linkUpsertWithWhereUniqueWithoutAutre_tagsInput | autre_tags_linkUpsertWithWhereUniqueWithoutAutre_tagsInput[]
    createMany?: autre_tags_linkCreateManyAutre_tagsInputEnvelope
    set?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    disconnect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    delete?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    update?: autre_tags_linkUpdateWithWhereUniqueWithoutAutre_tagsInput | autre_tags_linkUpdateWithWhereUniqueWithoutAutre_tagsInput[]
    updateMany?: autre_tags_linkUpdateManyWithWhereWithoutAutre_tagsInput | autre_tags_linkUpdateManyWithWhereWithoutAutre_tagsInput[]
    deleteMany?: autre_tags_linkScalarWhereInput | autre_tags_linkScalarWhereInput[]
  }

  export type autre_tags_linkUncheckedUpdateManyWithoutAutre_tagsNestedInput = {
    create?: XOR<autre_tags_linkCreateWithoutAutre_tagsInput, autre_tags_linkUncheckedCreateWithoutAutre_tagsInput> | autre_tags_linkCreateWithoutAutre_tagsInput[] | autre_tags_linkUncheckedCreateWithoutAutre_tagsInput[]
    connectOrCreate?: autre_tags_linkCreateOrConnectWithoutAutre_tagsInput | autre_tags_linkCreateOrConnectWithoutAutre_tagsInput[]
    upsert?: autre_tags_linkUpsertWithWhereUniqueWithoutAutre_tagsInput | autre_tags_linkUpsertWithWhereUniqueWithoutAutre_tagsInput[]
    createMany?: autre_tags_linkCreateManyAutre_tagsInputEnvelope
    set?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    disconnect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    delete?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    connect?: autre_tags_linkWhereUniqueInput | autre_tags_linkWhereUniqueInput[]
    update?: autre_tags_linkUpdateWithWhereUniqueWithoutAutre_tagsInput | autre_tags_linkUpdateWithWhereUniqueWithoutAutre_tagsInput[]
    updateMany?: autre_tags_linkUpdateManyWithWhereWithoutAutre_tagsInput | autre_tags_linkUpdateManyWithWhereWithoutAutre_tagsInput[]
    deleteMany?: autre_tags_linkScalarWhereInput | autre_tags_linkScalarWhereInput[]
  }

  export type autreCreateNestedOneWithoutAutre_tags_linkInput = {
    create?: XOR<autreCreateWithoutAutre_tags_linkInput, autreUncheckedCreateWithoutAutre_tags_linkInput>
    connectOrCreate?: autreCreateOrConnectWithoutAutre_tags_linkInput
    connect?: autreWhereUniqueInput
  }

  export type autre_tagsCreateNestedOneWithoutAutre_tags_linkInput = {
    create?: XOR<autre_tagsCreateWithoutAutre_tags_linkInput, autre_tagsUncheckedCreateWithoutAutre_tags_linkInput>
    connectOrCreate?: autre_tagsCreateOrConnectWithoutAutre_tags_linkInput
    connect?: autre_tagsWhereUniqueInput
  }

  export type autreUpdateOneRequiredWithoutAutre_tags_linkNestedInput = {
    create?: XOR<autreCreateWithoutAutre_tags_linkInput, autreUncheckedCreateWithoutAutre_tags_linkInput>
    connectOrCreate?: autreCreateOrConnectWithoutAutre_tags_linkInput
    upsert?: autreUpsertWithoutAutre_tags_linkInput
    connect?: autreWhereUniqueInput
    update?: XOR<XOR<autreUpdateToOneWithWhereWithoutAutre_tags_linkInput, autreUpdateWithoutAutre_tags_linkInput>, autreUncheckedUpdateWithoutAutre_tags_linkInput>
  }

  export type autre_tagsUpdateOneRequiredWithoutAutre_tags_linkNestedInput = {
    create?: XOR<autre_tagsCreateWithoutAutre_tags_linkInput, autre_tagsUncheckedCreateWithoutAutre_tags_linkInput>
    connectOrCreate?: autre_tagsCreateOrConnectWithoutAutre_tags_linkInput
    upsert?: autre_tagsUpsertWithoutAutre_tags_linkInput
    connect?: autre_tagsWhereUniqueInput
    update?: XOR<XOR<autre_tagsUpdateToOneWithWhereWithoutAutre_tags_linkInput, autre_tagsUpdateWithoutAutre_tags_linkInput>, autre_tagsUncheckedUpdateWithoutAutre_tags_linkInput>
  }

  export type photos_albums_linkCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_tags_linkCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotosInput | photos_albums_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_tags_linkUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotosInput | photos_albums_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photos_albums_linkCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_albums_tags_linkUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photosCreateNestedOneWithoutPhotos_albums_linkInput = {
    create?: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_albums_linkInput
    connect?: photosWhereUniqueInput
  }

  export type photos_albumsCreateNestedOneWithoutPhotos_albums_linkInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_linkInput
    connect?: photos_albumsWhereUniqueInput
  }

  export type photosUpdateOneRequiredWithoutPhotos_albums_linkNestedInput = {
    create?: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_albums_linkInput
    upsert?: photosUpsertWithoutPhotos_albums_linkInput
    connect?: photosWhereUniqueInput
    update?: XOR<XOR<photosUpdateToOneWithWhereWithoutPhotos_albums_linkInput, photosUpdateWithoutPhotos_albums_linkInput>, photosUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsUpdateOneRequiredWithoutPhotos_albums_linkNestedInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_linkInput
    upsert?: photos_albumsUpsertWithoutPhotos_albums_linkInput
    connect?: photos_albumsWhereUniqueInput
    update?: XOR<XOR<photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_linkInput, photos_albumsUpdateWithoutPhotos_albums_linkInput>, photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photos_albums_tags_linkCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_linkCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photos_tags_linkUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photosCreateNestedOneWithoutPhotos_tags_linkInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_linkInput
    connect?: photosWhereUniqueInput
  }

  export type photos_tagsCreateNestedOneWithoutPhotos_tags_linkInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
  }

  export type photosUpdateOneRequiredWithoutPhotos_tags_linkNestedInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_linkInput
    upsert?: photosUpsertWithoutPhotos_tags_linkInput
    connect?: photosWhereUniqueInput
    update?: XOR<XOR<photosUpdateToOneWithWhereWithoutPhotos_tags_linkInput, photosUpdateWithoutPhotos_tags_linkInput>, photosUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photos_tagsUpdateOneRequiredWithoutPhotos_tags_linkNestedInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_tags_linkInput
    upsert?: photos_tagsUpsertWithoutPhotos_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
    update?: XOR<XOR<photos_tagsUpdateToOneWithWhereWithoutPhotos_tags_linkInput, photos_tagsUpdateWithoutPhotos_tags_linkInput>, photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type videos_tags_linkCreateNestedManyWithoutVideosInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUpdateManyWithoutVideosNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideosInput | videos_tags_linkUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideosInput | videos_tags_linkUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videos_tags_linkCreateNestedManyWithoutVideos_tagsInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUncheckedCreateNestedManyWithoutVideos_tagsInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUpdateManyWithoutVideos_tagsNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput | videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput | videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videosCreateNestedOneWithoutVideos_tags_linkInput = {
    create?: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videosCreateOrConnectWithoutVideos_tags_linkInput
    connect?: videosWhereUniqueInput
  }

  export type videos_tagsCreateNestedOneWithoutVideos_tags_linkInput = {
    create?: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videos_tagsCreateOrConnectWithoutVideos_tags_linkInput
    connect?: videos_tagsWhereUniqueInput
  }

  export type videosUpdateOneRequiredWithoutVideos_tags_linkNestedInput = {
    create?: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videosCreateOrConnectWithoutVideos_tags_linkInput
    upsert?: videosUpsertWithoutVideos_tags_linkInput
    connect?: videosWhereUniqueInput
    update?: XOR<XOR<videosUpdateToOneWithWhereWithoutVideos_tags_linkInput, videosUpdateWithoutVideos_tags_linkInput>, videosUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type videos_tagsUpdateOneRequiredWithoutVideos_tags_linkNestedInput = {
    create?: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videos_tagsCreateOrConnectWithoutVideos_tags_linkInput
    upsert?: videos_tagsUpsertWithoutVideos_tags_linkInput
    connect?: videos_tagsWhereUniqueInput
    update?: XOR<XOR<videos_tagsUpdateToOneWithWhereWithoutVideos_tags_linkInput, videos_tagsUpdateWithoutVideos_tags_linkInput>, videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type photos_tags_recherche_linkCreateNestedManyWithoutPhotos_tags_rechercheInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotos_tags_rechercheInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkUpdateManyWithoutPhotos_tags_rechercheNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photosCreateNestedOneWithoutPhotos_tags_recherche_linkInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    connect?: photosWhereUniqueInput
  }

  export type photos_tags_rechercheCreateNestedOneWithoutPhotos_tags_recherche_linkInput = {
    create?: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photos_tags_rechercheCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    connect?: photos_tags_rechercheWhereUniqueInput
  }

  export type photosUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    upsert?: photosUpsertWithoutPhotos_tags_recherche_linkInput
    connect?: photosWhereUniqueInput
    update?: XOR<XOR<photosUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput, photosUpdateWithoutPhotos_tags_recherche_linkInput>, photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_tags_rechercheUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput = {
    create?: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photos_tags_rechercheCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    upsert?: photos_tags_rechercheUpsertWithoutPhotos_tags_recherche_linkInput
    connect?: photos_tags_rechercheWhereUniqueInput
    update?: XOR<XOR<photos_tags_rechercheUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput>, photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_albumsCreateNestedOneWithoutPhotos_albums_tags_linkInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    connect?: photos_albumsWhereUniqueInput
  }

  export type photos_tagsCreateNestedOneWithoutPhotos_albums_tags_linkInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
  }

  export type photos_albumsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    upsert?: photos_albumsUpsertWithoutPhotos_albums_tags_linkInput
    connect?: photos_albumsWhereUniqueInput
    update?: XOR<XOR<photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput, photos_albumsUpdateWithoutPhotos_albums_tags_linkInput>, photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_tagsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    upsert?: photos_tagsUpsertWithoutPhotos_albums_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
    update?: XOR<XOR<photos_tagsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput, photos_tagsUpdateWithoutPhotos_albums_tags_linkInput>, photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type autre_tags_linkCreateWithoutAutreInput = {
    autre_tags: autre_tagsCreateNestedOneWithoutAutre_tags_linkInput
  }

  export type autre_tags_linkUncheckedCreateWithoutAutreInput = {
    id_tags: number
  }

  export type autre_tags_linkCreateOrConnectWithoutAutreInput = {
    where: autre_tags_linkWhereUniqueInput
    create: XOR<autre_tags_linkCreateWithoutAutreInput, autre_tags_linkUncheckedCreateWithoutAutreInput>
  }

  export type autre_tags_linkCreateManyAutreInputEnvelope = {
    data: autre_tags_linkCreateManyAutreInput | autre_tags_linkCreateManyAutreInput[]
    skipDuplicates?: boolean
  }

  export type autre_tags_linkUpsertWithWhereUniqueWithoutAutreInput = {
    where: autre_tags_linkWhereUniqueInput
    update: XOR<autre_tags_linkUpdateWithoutAutreInput, autre_tags_linkUncheckedUpdateWithoutAutreInput>
    create: XOR<autre_tags_linkCreateWithoutAutreInput, autre_tags_linkUncheckedCreateWithoutAutreInput>
  }

  export type autre_tags_linkUpdateWithWhereUniqueWithoutAutreInput = {
    where: autre_tags_linkWhereUniqueInput
    data: XOR<autre_tags_linkUpdateWithoutAutreInput, autre_tags_linkUncheckedUpdateWithoutAutreInput>
  }

  export type autre_tags_linkUpdateManyWithWhereWithoutAutreInput = {
    where: autre_tags_linkScalarWhereInput
    data: XOR<autre_tags_linkUpdateManyMutationInput, autre_tags_linkUncheckedUpdateManyWithoutAutreInput>
  }

  export type autre_tags_linkScalarWhereInput = {
    AND?: autre_tags_linkScalarWhereInput | autre_tags_linkScalarWhereInput[]
    OR?: autre_tags_linkScalarWhereInput[]
    NOT?: autre_tags_linkScalarWhereInput | autre_tags_linkScalarWhereInput[]
    id_autre?: IntFilter<"autre_tags_link"> | number
    id_tags?: IntFilter<"autre_tags_link"> | number
  }

  export type autre_tags_linkCreateWithoutAutre_tagsInput = {
    autre: autreCreateNestedOneWithoutAutre_tags_linkInput
  }

  export type autre_tags_linkUncheckedCreateWithoutAutre_tagsInput = {
    id_autre: number
  }

  export type autre_tags_linkCreateOrConnectWithoutAutre_tagsInput = {
    where: autre_tags_linkWhereUniqueInput
    create: XOR<autre_tags_linkCreateWithoutAutre_tagsInput, autre_tags_linkUncheckedCreateWithoutAutre_tagsInput>
  }

  export type autre_tags_linkCreateManyAutre_tagsInputEnvelope = {
    data: autre_tags_linkCreateManyAutre_tagsInput | autre_tags_linkCreateManyAutre_tagsInput[]
    skipDuplicates?: boolean
  }

  export type autre_tags_linkUpsertWithWhereUniqueWithoutAutre_tagsInput = {
    where: autre_tags_linkWhereUniqueInput
    update: XOR<autre_tags_linkUpdateWithoutAutre_tagsInput, autre_tags_linkUncheckedUpdateWithoutAutre_tagsInput>
    create: XOR<autre_tags_linkCreateWithoutAutre_tagsInput, autre_tags_linkUncheckedCreateWithoutAutre_tagsInput>
  }

  export type autre_tags_linkUpdateWithWhereUniqueWithoutAutre_tagsInput = {
    where: autre_tags_linkWhereUniqueInput
    data: XOR<autre_tags_linkUpdateWithoutAutre_tagsInput, autre_tags_linkUncheckedUpdateWithoutAutre_tagsInput>
  }

  export type autre_tags_linkUpdateManyWithWhereWithoutAutre_tagsInput = {
    where: autre_tags_linkScalarWhereInput
    data: XOR<autre_tags_linkUpdateManyMutationInput, autre_tags_linkUncheckedUpdateManyWithoutAutre_tagsInput>
  }

  export type autreCreateWithoutAutre_tags_linkInput = {
    titre: string
    description: string
    miniature: string
    lien_github: string
    lien_figma: string
    lien_site: string
    categorie: string
    tags: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type autreUncheckedCreateWithoutAutre_tags_linkInput = {
    id_autre?: number
    titre: string
    description: string
    miniature: string
    lien_github: string
    lien_figma: string
    lien_site: string
    categorie: string
    tags: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type autreCreateOrConnectWithoutAutre_tags_linkInput = {
    where: autreWhereUniqueInput
    create: XOR<autreCreateWithoutAutre_tags_linkInput, autreUncheckedCreateWithoutAutre_tags_linkInput>
  }

  export type autre_tagsCreateWithoutAutre_tags_linkInput = {
    titre: string
    important: boolean
  }

  export type autre_tagsUncheckedCreateWithoutAutre_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type autre_tagsCreateOrConnectWithoutAutre_tags_linkInput = {
    where: autre_tagsWhereUniqueInput
    create: XOR<autre_tagsCreateWithoutAutre_tags_linkInput, autre_tagsUncheckedCreateWithoutAutre_tags_linkInput>
  }

  export type autreUpsertWithoutAutre_tags_linkInput = {
    update: XOR<autreUpdateWithoutAutre_tags_linkInput, autreUncheckedUpdateWithoutAutre_tags_linkInput>
    create: XOR<autreCreateWithoutAutre_tags_linkInput, autreUncheckedCreateWithoutAutre_tags_linkInput>
    where?: autreWhereInput
  }

  export type autreUpdateToOneWithWhereWithoutAutre_tags_linkInput = {
    where?: autreWhereInput
    data: XOR<autreUpdateWithoutAutre_tags_linkInput, autreUncheckedUpdateWithoutAutre_tags_linkInput>
  }

  export type autreUpdateWithoutAutre_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    miniature?: StringFieldUpdateOperationsInput | string
    lien_github?: StringFieldUpdateOperationsInput | string
    lien_figma?: StringFieldUpdateOperationsInput | string
    lien_site?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type autreUncheckedUpdateWithoutAutre_tags_linkInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    miniature?: StringFieldUpdateOperationsInput | string
    lien_github?: StringFieldUpdateOperationsInput | string
    lien_figma?: StringFieldUpdateOperationsInput | string
    lien_site?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type autre_tagsUpsertWithoutAutre_tags_linkInput = {
    update: XOR<autre_tagsUpdateWithoutAutre_tags_linkInput, autre_tagsUncheckedUpdateWithoutAutre_tags_linkInput>
    create: XOR<autre_tagsCreateWithoutAutre_tags_linkInput, autre_tagsUncheckedCreateWithoutAutre_tags_linkInput>
    where?: autre_tagsWhereInput
  }

  export type autre_tagsUpdateToOneWithWhereWithoutAutre_tags_linkInput = {
    where?: autre_tagsWhereInput
    data: XOR<autre_tagsUpdateWithoutAutre_tags_linkInput, autre_tagsUncheckedUpdateWithoutAutre_tags_linkInput>
  }

  export type autre_tagsUpdateWithoutAutre_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type autre_tagsUncheckedUpdateWithoutAutre_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_albums_linkCreateWithoutPhotosInput = {
    position?: number
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_linkInput
  }

  export type photos_albums_linkUncheckedCreateWithoutPhotosInput = {
    id_alb: number
    position?: number
  }

  export type photos_albums_linkCreateOrConnectWithoutPhotosInput = {
    where: photos_albums_linkWhereUniqueInput
    create: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_albums_linkCreateManyPhotosInputEnvelope = {
    data: photos_albums_linkCreateManyPhotosInput | photos_albums_linkCreateManyPhotosInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_linkCreateWithoutPhotosInput = {
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_tags_linkInput
  }

  export type photos_tags_linkUncheckedCreateWithoutPhotosInput = {
    id_tags: number
  }

  export type photos_tags_linkCreateOrConnectWithoutPhotosInput = {
    where: photos_tags_linkWhereUniqueInput
    create: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_linkCreateManyPhotosInputEnvelope = {
    data: photos_tags_linkCreateManyPhotosInput | photos_tags_linkCreateManyPhotosInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_recherche_linkCreateWithoutPhotosInput = {
    photos_tags_recherche: photos_tags_rechercheCreateNestedOneWithoutPhotos_tags_recherche_linkInput
  }

  export type photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput = {
    id_tags: number
  }

  export type photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkCreateManyPhotosInputEnvelope = {
    data: photos_tags_recherche_linkCreateManyPhotosInput | photos_tags_recherche_linkCreateManyPhotosInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput = {
    where: photos_albums_linkWhereUniqueInput
    update: XOR<photos_albums_linkUpdateWithoutPhotosInput, photos_albums_linkUncheckedUpdateWithoutPhotosInput>
    create: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput = {
    where: photos_albums_linkWhereUniqueInput
    data: XOR<photos_albums_linkUpdateWithoutPhotosInput, photos_albums_linkUncheckedUpdateWithoutPhotosInput>
  }

  export type photos_albums_linkUpdateManyWithWhereWithoutPhotosInput = {
    where: photos_albums_linkScalarWhereInput
    data: XOR<photos_albums_linkUpdateManyMutationInput, photos_albums_linkUncheckedUpdateManyWithoutPhotosInput>
  }

  export type photos_albums_linkScalarWhereInput = {
    AND?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
    OR?: photos_albums_linkScalarWhereInput[]
    NOT?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
    id_pho?: IntFilter<"photos_albums_link"> | number
    id_alb?: IntFilter<"photos_albums_link"> | number
    position?: IntFilter<"photos_albums_link"> | number
  }

  export type photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_linkWhereUniqueInput
    update: XOR<photos_tags_linkUpdateWithoutPhotosInput, photos_tags_linkUncheckedUpdateWithoutPhotosInput>
    create: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_linkWhereUniqueInput
    data: XOR<photos_tags_linkUpdateWithoutPhotosInput, photos_tags_linkUncheckedUpdateWithoutPhotosInput>
  }

  export type photos_tags_linkUpdateManyWithWhereWithoutPhotosInput = {
    where: photos_tags_linkScalarWhereInput
    data: XOR<photos_tags_linkUpdateManyMutationInput, photos_tags_linkUncheckedUpdateManyWithoutPhotosInput>
  }

  export type photos_tags_linkScalarWhereInput = {
    AND?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
    OR?: photos_tags_linkScalarWhereInput[]
    NOT?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
    id_pho?: IntFilter<"photos_tags_link"> | number
    id_tags?: IntFilter<"photos_tags_link"> | number
  }

  export type photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    update: XOR<photos_tags_recherche_linkUpdateWithoutPhotosInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotosInput>
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    data: XOR<photos_tags_recherche_linkUpdateWithoutPhotosInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput = {
    where: photos_tags_recherche_linkScalarWhereInput
    data: XOR<photos_tags_recherche_linkUpdateManyMutationInput, photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkScalarWhereInput = {
    AND?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
    OR?: photos_tags_recherche_linkScalarWhereInput[]
    NOT?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
    id_pho?: IntFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntFilter<"photos_tags_recherche_link"> | number
  }

  export type photos_albums_linkCreateWithoutPhotos_albumsInput = {
    position?: number
    photos: photosCreateNestedOneWithoutPhotos_albums_linkInput
  }

  export type photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput = {
    id_pho: number
    position?: number
  }

  export type photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput = {
    where: photos_albums_linkWhereUniqueInput
    create: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_linkCreateManyPhotos_albumsInputEnvelope = {
    data: photos_albums_linkCreateManyPhotos_albumsInput | photos_albums_linkCreateManyPhotos_albumsInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_tags_linkCreateWithoutPhotos_albumsInput = {
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_albums_tags_linkInput
  }

  export type photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput = {
    id_tags: number
  }

  export type photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope = {
    data: photos_albums_tags_linkCreateManyPhotos_albumsInput | photos_albums_tags_linkCreateManyPhotos_albumsInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_linkWhereUniqueInput
    update: XOR<photos_albums_linkUpdateWithoutPhotos_albumsInput, photos_albums_linkUncheckedUpdateWithoutPhotos_albumsInput>
    create: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_linkWhereUniqueInput
    data: XOR<photos_albums_linkUpdateWithoutPhotos_albumsInput, photos_albums_linkUncheckedUpdateWithoutPhotos_albumsInput>
  }

  export type photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput = {
    where: photos_albums_linkScalarWhereInput
    data: XOR<photos_albums_linkUpdateManyMutationInput, photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    update: XOR<photos_albums_tags_linkUpdateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_albumsInput>
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    data: XOR<photos_albums_tags_linkUpdateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkScalarWhereInput
    data: XOR<photos_albums_tags_linkUpdateManyMutationInput, photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkScalarWhereInput = {
    AND?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
    OR?: photos_albums_tags_linkScalarWhereInput[]
    NOT?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
    id_alb?: IntFilter<"photos_albums_tags_link"> | number
    id_tags?: IntFilter<"photos_albums_tags_link"> | number
  }

  export type photosCreateWithoutPhotos_albums_linkInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateWithoutPhotos_albums_linkInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosCreateOrConnectWithoutPhotos_albums_linkInput = {
    where: photosWhereUniqueInput
    create: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsCreateWithoutPhotos_albums_linkInput = {
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput = {
    id_alb?: number
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsCreateOrConnectWithoutPhotos_albums_linkInput = {
    where: photos_albumsWhereUniqueInput
    create: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
  }

  export type photosUpsertWithoutPhotos_albums_linkInput = {
    update: XOR<photosUpdateWithoutPhotos_albums_linkInput, photosUncheckedUpdateWithoutPhotos_albums_linkInput>
    create: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
    where?: photosWhereInput
  }

  export type photosUpdateToOneWithWhereWithoutPhotos_albums_linkInput = {
    where?: photosWhereInput
    data: XOR<photosUpdateWithoutPhotos_albums_linkInput, photosUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photosUpdateWithoutPhotos_albums_linkInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateWithoutPhotos_albums_linkInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photos_albumsUpsertWithoutPhotos_albums_linkInput = {
    update: XOR<photos_albumsUpdateWithoutPhotos_albums_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput>
    create: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
    where?: photos_albumsWhereInput
  }

  export type photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_linkInput = {
    where?: photos_albumsWhereInput
    data: XOR<photos_albumsUpdateWithoutPhotos_albums_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsUpdateWithoutPhotos_albums_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albums_tags_linkCreateWithoutPhotos_tagsInput = {
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_tags_linkInput
  }

  export type photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput = {
    id_alb: number
  }

  export type photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope = {
    data: photos_albums_tags_linkCreateManyPhotos_tagsInput | photos_albums_tags_linkCreateManyPhotos_tagsInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_linkCreateWithoutPhotos_tagsInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_linkInput
  }

  export type photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput = {
    id_pho: number
  }

  export type photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput = {
    where: photos_tags_linkWhereUniqueInput
    create: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkCreateManyPhotos_tagsInputEnvelope = {
    data: photos_tags_linkCreateManyPhotos_tagsInput | photos_tags_linkCreateManyPhotos_tagsInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    update: XOR<photos_albums_tags_linkUpdateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    data: XOR<photos_albums_tags_linkUpdateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
  }

  export type photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkScalarWhereInput
    data: XOR<photos_albums_tags_linkUpdateManyMutationInput, photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_tags_linkWhereUniqueInput
    update: XOR<photos_tags_linkUpdateWithoutPhotos_tagsInput, photos_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
    create: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_tags_linkWhereUniqueInput
    data: XOR<photos_tags_linkUpdateWithoutPhotos_tagsInput, photos_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput = {
    where: photos_tags_linkScalarWhereInput
    data: XOR<photos_tags_linkUpdateManyMutationInput, photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput>
  }

  export type photosCreateWithoutPhotos_tags_linkInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateWithoutPhotos_tags_linkInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosCreateOrConnectWithoutPhotos_tags_linkInput = {
    where: photosWhereUniqueInput
    create: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
  }

  export type photos_tagsCreateWithoutPhotos_tags_linkInput = {
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsCreateOrConnectWithoutPhotos_tags_linkInput = {
    where: photos_tagsWhereUniqueInput
    create: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
  }

  export type photosUpsertWithoutPhotos_tags_linkInput = {
    update: XOR<photosUpdateWithoutPhotos_tags_linkInput, photosUncheckedUpdateWithoutPhotos_tags_linkInput>
    create: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
    where?: photosWhereInput
  }

  export type photosUpdateToOneWithWhereWithoutPhotos_tags_linkInput = {
    where?: photosWhereInput
    data: XOR<photosUpdateWithoutPhotos_tags_linkInput, photosUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photosUpdateWithoutPhotos_tags_linkInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateWithoutPhotos_tags_linkInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photos_tagsUpsertWithoutPhotos_tags_linkInput = {
    update: XOR<photos_tagsUpdateWithoutPhotos_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput>
    create: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
    where?: photos_tagsWhereInput
  }

  export type photos_tagsUpdateToOneWithWhereWithoutPhotos_tags_linkInput = {
    where?: photos_tagsWhereInput
    data: XOR<photos_tagsUpdateWithoutPhotos_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photos_tagsUpdateWithoutPhotos_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type videos_tags_linkCreateWithoutVideosInput = {
    videos_tags: videos_tagsCreateNestedOneWithoutVideos_tags_linkInput
  }

  export type videos_tags_linkUncheckedCreateWithoutVideosInput = {
    id_tags: number
  }

  export type videos_tags_linkCreateOrConnectWithoutVideosInput = {
    where: videos_tags_linkWhereUniqueInput
    create: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput>
  }

  export type videos_tags_linkCreateManyVideosInputEnvelope = {
    data: videos_tags_linkCreateManyVideosInput | videos_tags_linkCreateManyVideosInput[]
    skipDuplicates?: boolean
  }

  export type videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput = {
    where: videos_tags_linkWhereUniqueInput
    update: XOR<videos_tags_linkUpdateWithoutVideosInput, videos_tags_linkUncheckedUpdateWithoutVideosInput>
    create: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput>
  }

  export type videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput = {
    where: videos_tags_linkWhereUniqueInput
    data: XOR<videos_tags_linkUpdateWithoutVideosInput, videos_tags_linkUncheckedUpdateWithoutVideosInput>
  }

  export type videos_tags_linkUpdateManyWithWhereWithoutVideosInput = {
    where: videos_tags_linkScalarWhereInput
    data: XOR<videos_tags_linkUpdateManyMutationInput, videos_tags_linkUncheckedUpdateManyWithoutVideosInput>
  }

  export type videos_tags_linkScalarWhereInput = {
    AND?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
    OR?: videos_tags_linkScalarWhereInput[]
    NOT?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
    id_vid?: IntFilter<"videos_tags_link"> | number
    id_tags?: IntFilter<"videos_tags_link"> | number
  }

  export type videos_tags_linkCreateWithoutVideos_tagsInput = {
    videos: videosCreateNestedOneWithoutVideos_tags_linkInput
  }

  export type videos_tags_linkUncheckedCreateWithoutVideos_tagsInput = {
    id_vid: number
  }

  export type videos_tags_linkCreateOrConnectWithoutVideos_tagsInput = {
    where: videos_tags_linkWhereUniqueInput
    create: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput>
  }

  export type videos_tags_linkCreateManyVideos_tagsInputEnvelope = {
    data: videos_tags_linkCreateManyVideos_tagsInput | videos_tags_linkCreateManyVideos_tagsInput[]
    skipDuplicates?: boolean
  }

  export type videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput = {
    where: videos_tags_linkWhereUniqueInput
    update: XOR<videos_tags_linkUpdateWithoutVideos_tagsInput, videos_tags_linkUncheckedUpdateWithoutVideos_tagsInput>
    create: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput>
  }

  export type videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput = {
    where: videos_tags_linkWhereUniqueInput
    data: XOR<videos_tags_linkUpdateWithoutVideos_tagsInput, videos_tags_linkUncheckedUpdateWithoutVideos_tagsInput>
  }

  export type videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput = {
    where: videos_tags_linkScalarWhereInput
    data: XOR<videos_tags_linkUpdateManyMutationInput, videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsInput>
  }

  export type videosCreateWithoutVideos_tags_linkInput = {
    titre: string
    description: string
    tags: string
    lien: string
    date: Date | string
    media_webm: string
    media_mp4: string
    duree: string
    afficher_competences: string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type videosUncheckedCreateWithoutVideos_tags_linkInput = {
    id_vid?: number
    titre: string
    description: string
    tags: string
    lien: string
    date: Date | string
    media_webm: string
    media_mp4: string
    duree: string
    afficher_competences: string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type videosCreateOrConnectWithoutVideos_tags_linkInput = {
    where: videosWhereUniqueInput
    create: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
  }

  export type videos_tagsCreateWithoutVideos_tags_linkInput = {
    titre: string
    important: boolean
  }

  export type videos_tagsUncheckedCreateWithoutVideos_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type videos_tagsCreateOrConnectWithoutVideos_tags_linkInput = {
    where: videos_tagsWhereUniqueInput
    create: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
  }

  export type videosUpsertWithoutVideos_tags_linkInput = {
    update: XOR<videosUpdateWithoutVideos_tags_linkInput, videosUncheckedUpdateWithoutVideos_tags_linkInput>
    create: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
    where?: videosWhereInput
  }

  export type videosUpdateToOneWithWhereWithoutVideos_tags_linkInput = {
    where?: videosWhereInput
    data: XOR<videosUpdateWithoutVideos_tags_linkInput, videosUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type videosUpdateWithoutVideos_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    media_webm?: StringFieldUpdateOperationsInput | string
    media_mp4?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    afficher_competences?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videosUncheckedUpdateWithoutVideos_tags_linkInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    media_webm?: StringFieldUpdateOperationsInput | string
    media_mp4?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    afficher_competences?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videos_tagsUpsertWithoutVideos_tags_linkInput = {
    update: XOR<videos_tagsUpdateWithoutVideos_tags_linkInput, videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput>
    create: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
    where?: videos_tagsWhereInput
  }

  export type videos_tagsUpdateToOneWithWhereWithoutVideos_tags_linkInput = {
    where?: videos_tagsWhereInput
    data: XOR<videos_tagsUpdateWithoutVideos_tags_linkInput, videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type videos_tagsUpdateWithoutVideos_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_recherche_linkInput
  }

  export type photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput = {
    id_pho: number
  }

  export type photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput>
  }

  export type photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope = {
    data: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    update: XOR<photos_tags_recherche_linkUpdateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotos_tags_rechercheInput>
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput>
  }

  export type photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    data: XOR<photos_tags_recherche_linkUpdateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotos_tags_rechercheInput>
  }

  export type photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkScalarWhereInput
    data: XOR<photos_tags_recherche_linkUpdateManyMutationInput, photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheInput>
  }

  export type photosCreateWithoutPhotos_tags_recherche_linkInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosCreateOrConnectWithoutPhotos_tags_recherche_linkInput = {
    where: photosWhereUniqueInput
    create: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput = {
    titre: string
    important: boolean
  }

  export type photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type photos_tags_rechercheCreateOrConnectWithoutPhotos_tags_recherche_linkInput = {
    where: photos_tags_rechercheWhereUniqueInput
    create: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photosUpsertWithoutPhotos_tags_recherche_linkInput = {
    update: XOR<photosUpdateWithoutPhotos_tags_recherche_linkInput, photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
    create: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    where?: photosWhereInput
  }

  export type photosUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput = {
    where?: photosWhereInput
    data: XOR<photosUpdateWithoutPhotos_tags_recherche_linkInput, photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photosUpdateWithoutPhotos_tags_recherche_linkInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photos_tags_rechercheUpsertWithoutPhotos_tags_recherche_linkInput = {
    update: XOR<photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
    create: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    where?: photos_tags_rechercheWhereInput
  }

  export type photos_tags_rechercheUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput = {
    where?: photos_tags_rechercheWhereInput
    data: XOR<photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_albumsCreateWithoutPhotos_albums_tags_linkInput = {
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput = {
    id_alb?: number
    titre: string
    description: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsCreateOrConnectWithoutPhotos_albums_tags_linkInput = {
    where: photos_albumsWhereUniqueInput
    create: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_tagsCreateWithoutPhotos_albums_tags_linkInput = {
    titre: string
    important: boolean
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsCreateOrConnectWithoutPhotos_albums_tags_linkInput = {
    where: photos_tagsWhereUniqueInput
    create: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_albumsUpsertWithoutPhotos_albums_tags_linkInput = {
    update: XOR<photos_albumsUpdateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
    create: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    where?: photos_albumsWhereInput
  }

  export type photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput = {
    where?: photos_albumsWhereInput
    data: XOR<photos_albumsUpdateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_albumsUpdateWithoutPhotos_albums_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_tagsUpsertWithoutPhotos_albums_tags_linkInput = {
    update: XOR<photos_tagsUpdateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
    create: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    where?: photos_tagsWhereInput
  }

  export type photos_tagsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput = {
    where?: photos_tagsWhereInput
    data: XOR<photos_tagsUpdateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_tagsUpdateWithoutPhotos_albums_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type autre_tags_linkCreateManyAutreInput = {
    id_tags: number
  }

  export type autre_tags_linkUpdateWithoutAutreInput = {
    autre_tags?: autre_tagsUpdateOneRequiredWithoutAutre_tags_linkNestedInput
  }

  export type autre_tags_linkUncheckedUpdateWithoutAutreInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type autre_tags_linkUncheckedUpdateManyWithoutAutreInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type autre_tags_linkCreateManyAutre_tagsInput = {
    id_autre: number
  }

  export type autre_tags_linkUpdateWithoutAutre_tagsInput = {
    autre?: autreUpdateOneRequiredWithoutAutre_tags_linkNestedInput
  }

  export type autre_tags_linkUncheckedUpdateWithoutAutre_tagsInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
  }

  export type autre_tags_linkUncheckedUpdateManyWithoutAutre_tagsInput = {
    id_autre?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkCreateManyPhotosInput = {
    id_alb: number
    position?: number
  }

  export type photos_tags_linkCreateManyPhotosInput = {
    id_tags: number
  }

  export type photos_tags_recherche_linkCreateManyPhotosInput = {
    id_tags: number
  }

  export type photos_albums_linkUpdateWithoutPhotosInput = {
    position?: IntFieldUpdateOperationsInput | number
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
  }

  export type photos_albums_linkUncheckedUpdateWithoutPhotosInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotosInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUpdateWithoutPhotosInput = {
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
  }

  export type photos_tags_linkUncheckedUpdateWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkUpdateWithoutPhotosInput = {
    photos_tags_recherche?: photos_tags_rechercheUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
  }

  export type photos_tags_recherche_linkUncheckedUpdateWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkCreateManyPhotos_albumsInput = {
    id_pho: number
    position?: number
  }

  export type photos_albums_tags_linkCreateManyPhotos_albumsInput = {
    id_tags: number
  }

  export type photos_albums_linkUpdateWithoutPhotos_albumsInput = {
    position?: IntFieldUpdateOperationsInput | number
    photos?: photosUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
  }

  export type photos_albums_linkUncheckedUpdateWithoutPhotos_albumsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkUpdateWithoutPhotos_albumsInput = {
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
  }

  export type photos_albums_tags_linkUncheckedUpdateWithoutPhotos_albumsInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkCreateManyPhotos_tagsInput = {
    id_alb: number
  }

  export type photos_tags_linkCreateManyPhotos_tagsInput = {
    id_pho: number
  }

  export type photos_albums_tags_linkUpdateWithoutPhotos_tagsInput = {
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
  }

  export type photos_albums_tags_linkUncheckedUpdateWithoutPhotos_tagsInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUpdateWithoutPhotos_tagsInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
  }

  export type photos_tags_linkUncheckedUpdateWithoutPhotos_tagsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkCreateManyVideosInput = {
    id_tags: number
  }

  export type videos_tags_linkUpdateWithoutVideosInput = {
    videos_tags?: videos_tagsUpdateOneRequiredWithoutVideos_tags_linkNestedInput
  }

  export type videos_tags_linkUncheckedUpdateWithoutVideosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkCreateManyVideos_tagsInput = {
    id_vid: number
  }

  export type videos_tags_linkUpdateWithoutVideos_tagsInput = {
    videos?: videosUpdateOneRequiredWithoutVideos_tags_linkNestedInput
  }

  export type videos_tags_linkUncheckedUpdateWithoutVideos_tagsInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInput = {
    id_pho: number
  }

  export type photos_tags_recherche_linkUpdateWithoutPhotos_tags_rechercheInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
  }

  export type photos_tags_recherche_linkUncheckedUpdateWithoutPhotos_tags_rechercheInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}